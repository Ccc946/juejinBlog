/*
Navicat MySQL Data Transfer

Source Server         : chenin
Source Server Version : 80018
Source Host           : localhost:3306
Source Database       : blogweb

Target Server Type    : MYSQL
Target Server Version : 80018
File Encoding         : 65001

Date: 2019-12-23 12:39:21
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `admins`
-- ----------------------------
DROP TABLE IF EXISTS `admins`;
CREATE TABLE `admins` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `email` varchar(64) DEFAULT NULL,
  `password` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of admins
-- ----------------------------
INSERT INTO `admins` VALUES ('1', 'chenin', '1185288254@qq.com', '123456');

-- ----------------------------
-- Table structure for `articles`
-- ----------------------------
DROP TABLE IF EXISTS `articles`;
CREATE TABLE `articles` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `author` varchar(32) NOT NULL,
  `category` varchar(32) NOT NULL,
  `title` varchar(255) NOT NULL,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `like` int(11) NOT NULL DEFAULT '0',
  `comment` int(11) NOT NULL DEFAULT '0',
  `createtime` date NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of articles
-- ----------------------------
INSERT INTO `articles` VALUES ('1', 'chenin', '前端', 'vue、mock数据', '## vue2.x 使用mock\r\n\r\n​	在webpack.dev.conf.js的devServer中进行mock数据\r\n\r\n```js\r\ndevServer: {\r\n    before(app){\r\n      app.get(\'/api/goods\', function(req, res) {\r\n        res.json({\r\n          errno: 0,\r\n          data: goods\r\n        })\r\n      });\r\n      app.get(\'/api/ratings\', function(req, res) {\r\n        res.json({\r\n          errno: 0,\r\n          data: ratings\r\n        })\r\n      });\r\n    },\r\n```\r\n\r\n## vue3.x 使用mock\r\n\r\n在根目录创建vue.config.js中进行上述配置\r\n\r\n```js\r\nmodule.exports = {\r\n configureWebpack: {\r\n   devServer: {\r\n      before(app) {\r\n        app.get(\'/api/goods\', function(req,res){\r\n           res.json({\r\n            code:0,\r\n            list: [\r\n              { id: 1, text: \"Web全栈架构师\", price: 1000 },\r\n              { id: 2, text: \"Python架构师\", price: 1000 }\r\n           ]\r\n          })\r\n        }) \r\n      }\r\n    }\r\n }\r\n}\r\n```\r\n', '1263', '56455', '2019-12-15');
INSERT INTO `articles` VALUES ('3', 'chenccc', '前端', 'vue组件化', '## 组件设计\r\n\r\n---\r\n\r\n### 表单组件、组件分层\r\n\r\n1. From负责定义检验规则\r\n2. FromItem负责显示错误信息\r\n3. k-input负责数据双向绑定\r\n4. 使用provide和inject内部共享数据\r\n\r\n\r\n\r\n## provide&inject\r\n\r\n---\r\n\r\n~~~js\r\nprovide(){				\r\n	return	{						\r\n		form:\"kaikeba\"				\r\n	}		\r\n},\r\n//子组件注入\r\nvar	Child	=	{		\r\n	inject:	[\'form\'],		\r\n	created	()	{\r\n   		 console.log(this.form)		\r\n    }		\r\n  }\r\n~~~\r\n\r\n\r\n\r\n## k-input使用v-model实现双向数据绑定\r\n\r\n---\r\n\r\nv-model是一个特殊属性，相当于绑定：value和@input两个事件\r\n\r\n~~~vue\r\n<template>\r\n  <div>\r\n    <input :type=\"inputtype\" :value=\"inputValue\" @input=\"handleinput\" @blur=\"handleBlur\" />\r\n    <p>{{inputValue}}</p>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  props: {	//获取value初始值，input的类型type\r\n    value: {\r\n      type: String,\r\n      default: \"\",\r\n      required: true\r\n    },\r\n    type: {\r\n      type: String,\r\n      default: \"text\"\r\n    }\r\n  },\r\n  data() {\r\n    return {    //单向数据流原则：组件内不能修改props属性\r\n      inputValue: this.value,\r\n      inputtype: this.type\r\n    };\r\n  },\r\n  methods: {\r\n    handleinput(e) {\r\n      const value = e.target.value;\r\n      this.inputValue = value;\r\n      console.log(this.inputValue);\r\n      //通知父组件值更新\r\n      this.$emit(\"input\", value);\r\n\r\n      //通知FromItem做校验\r\n      this.$parent.$emit(\"validate\", this.inputValue);\r\n    },\r\n    handleBlur() {	//输入框失去焦点时通知FromItem做校验\r\n      this.$parent.$emit(\"validate\", this.inputValue);\r\n    }\r\n  }\r\n};\r\n</script>\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## FromItem\r\n\r\n---\r\n\r\n1. 获取当前输入框的规则\r\n2. 获取输入框的值对rules规则进行匹配过滤不是自己的输入事件\r\n3. 如果输入值和rules不匹配显示错误信息\r\n\r\n~~~vue\r\n<template>\r\n  <div>\r\n    <label v-if=\"label!=\'\'\">{{label}}</label>\r\n    <div>\r\n      <slot></slot>\r\n      <p v-if=\"validateStatus == \'error\'\" class=\"error\">{{errorMessage}}</p>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport schema from \"async-validator\";	//数据检验插件\r\nexport default {\r\n  inject: [\"from\"],	// 注入form，获取model和rules\r\n  props: {\r\n    label: {\r\n      type: String,\r\n      default: \"\"\r\n    },\r\n    prop: {\r\n      type: String\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      validateStatus: \"\",\r\n      errorMessage: \"\"\r\n    };\r\n  },\r\n  created() {\r\n    this.$on(\"validate\", this.validate);\r\n  },\r\n  mounted() {\r\n    //挂载到from上时，派发一个添加事件\r\n    if (this.prop) {\r\n      this.$parent.$emit(\"fromItemAdd\", this);\r\n    }\r\n  },\r\n  methods: {\r\n     validate() {\r\n      return new Promise(resolve => {\r\n        //npm install --save async-validator\r\n        //检验当前项 async-validate\r\n        const descriptor = {\r\n          //获取检验规则\r\n          [this.prop]: this.from.rules[this.prop]\r\n        };\r\n        const validator = new schema(descriptor);\r\n           // 使用es6计算属性动态设置key\r\n        validator.validate({ [this.prop]: this.from.model[this.prop] }, error => {\r\n          if (error) {\r\n            //检验失败\r\n            this.validateStatus = \"error\";\r\n            this.errorMessage = error[0].message;\r\n            resolve(false);\r\n          } else {\r\n            this.validateStatus = \"\";\r\n            this.errorMessage = \"\";\r\n            resolve(true);\r\n          }\r\n        });\r\n      });\r\n    }\r\n  }\r\n};\r\n</script>\r\n~~~\r\n\r\n\r\n\r\n## From\r\n\r\n---\r\n\r\n\r\n\r\n~~~vue\r\n<template>\r\n    <div>\r\n        <form>\r\n            <slot></slot>\r\n        </form>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        provide(){\r\n            return {    //将表单实列传递给后代\r\n                from: this\r\n            }\r\n        },\r\n        props: {\r\n            model: {\r\n                type: Object,\r\n                required: true\r\n            },\r\n            rules:{\r\n                type: Object\r\n            }\r\n        },\r\n        created () {\r\n            //缓存需要校验的表单项\r\n            this.fields = [];\r\n            this.$on(\'fromItemAdd\',item=>this.fields.push(item))\r\n        },\r\n        methods: {\r\n            async validate(callback) {\r\n                //将FromItem数组转换为validate（）返回的promise数组\r\n                const tasks = this.fields.map(item => item.validate())\r\n                //获取所有结果统一处理\r\n                const results = await Promise.all(tasks);\r\n                let ret = true;\r\n                results.forEach(valid =>{\r\n                    if(!valid){\r\n                        ret = false;//只要一个失败就失败\r\n                    }\r\n                });\r\n                callback(ret);\r\n            }\r\n        },\r\n    }\r\n</script>\r\n~~~\r\n\r\n\r\n\r\n## 组件使用\r\n\r\n---\r\n\r\n~~~vue\r\n<template>\r\n  <div>\r\n    <k-from :model=\"from\" :rules=\"rules\" ref=\"loginfrom\">\r\n      <k-fromitem label=\"用户名\" prop=\"name\">\r\n        <k-input v-model=\"from.name\"></k-input>\r\n      </k-fromitem>\r\n      <k-fromitem label=\"密码\" prop=\"password\">\r\n        <k-input v-model=\"from.password\" type=\"password\"></k-input>\r\n      </k-fromitem>\r\n      <k-fromitem>\r\n        <button @click=\"submit\">登录</button>\r\n      </k-fromitem>\r\n    </k-from>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport KInput from \"./Basefromitem/KInput.vue\";\r\nimport KFromitem from \"./Basefromitem/KFromitem.vue\";\r\nimport KFrom from \"./Basefromitem/KFrom.vue\";\r\n\r\nexport default {\r\n  components: {KInput, KFromitem,KFrom },\r\n  data() {\r\n    return {\r\n      from: {\r\n        name: \"\",\r\n        password: \"\"\r\n      },\r\n      rules: {	//检验规则\r\n        name: [\r\n          { required: true, message: \"用户名不能为空！\" },\r\n          { min: 6, max: 10, message: \"请输入6~10位用户名\" }\r\n        ],\r\n        password: [{ required: true, message: \"密码不能为空！\" }]\r\n      }\r\n    };\r\n  },\r\n  methods: {\r\n    submit() {\r\n      this.$refs.loginfrom.validate(valid => {\r\n        if (valid) {\r\n          alert(\"提交登录！\");\r\n        } else {\r\n          console.log(\"校验失败\");\r\n          return false;\r\n        }\r\n      });\r\n    }\r\n  }\r\n};\r\n</script>\r\n~~~\r\n', '456', '4654', '2019-12-16');
INSERT INTO `articles` VALUES ('4', 'chenin', '前端', '从ES6到ES10的新特性万字大总结（不得不收藏）', '## 介绍\r\n\r\nECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）在标准ECMA-262中定义的脚本语言规范。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。\r\n\r\n### 历史版本\r\n\r\n至发稿日为止有九个ECMA-262版本发表。其历史版本如下：\r\n\r\n1. 1997年6月：第一版\r\n2. 1998年6月：修改格式，使其与ISO/IEC16262国际标准一样\r\n3. 1999年12月：强大的正则表达式，更好的词法作用域链处理，新的控制指令，异常处理，错误定义更加明确，数据输出的格式化及其它改变\r\n4. 2009年12月：添加严格模式(`\"use strict\"`)。修改了前面版本模糊不清的概念。增加了getters，setters，JSON以及在对象属性上更完整的反射。\r\n5. 2011年6月：ECMAScript标5.1版形式上完全一致于国际标准ISO/IEC 16262:2011。\r\n6. 2015年6月：ECMAScript 2015（ES2015），第 6 版，最早被称作是 ECMAScript 6（ES6），添加了类和模块的语法，其他特性包括迭代器，Python风格的生成器和生成器表达式，箭头函数，二进制数据，静态类型数组，集合（maps，sets 和 weak maps），promise，reflection 和 proxies。作为最早的 ECMAScript Harmony 版本，也被叫做ES6 Harmony。\r\n7. 2016年6月：ECMAScript 2016（ES2016），第 7 版，多个新的概念和语言特性。\r\n8. 2017年6月：ECMAScript 2017（ES2017），第 8 版，多个新的概念和语言特性。\r\n9. 2018年6月：ECMAScript 2018 （ES2018），第 9 版，包含了异步循环，生成器，新的正则表达式特性和 rest/spread 语法。\r\n10. 2019年6月：ECMAScript 2019 （ES2019），第 10 版。\r\n\r\n### 发展标准\r\n\r\nTC39（Technical Committee 39）是一个推动JavaScript发展的委员会，它的成语来自各个主流浏览器的代表成语。会议实行多数决，每一项决策只有大部分人同意且没有强烈反对才能去实现。\r\n\r\nTC39成员制定着ECMAScript的未来。\r\n\r\n每一项新特性最终要进入到ECMAScript规范里，需要经历5个阶段，这5个阶段如下：\r\n\r\n- **Stage 0**: Strawperson\r\n\r\n  只要是TC39成员或者贡献者，都可以提交想法\r\n\r\n- **Stage 1**: Proposal\r\n\r\n  这个阶段确定一个正式的提案\r\n\r\n- **Stage 2**: draft\r\n\r\n  规范的第一个版本，进入此阶段的提案大概率会成为标准\r\n\r\n- **Stage 3**: Candidate\r\n\r\n  进一步完善提案细则\r\n\r\n- **Stage 4**: Finished\r\n\r\n  表示已准备好将其添加到正式的ECMAScript标准中\r\n\r\n**由于ES6以前的属性诞生年底久远，我们使用也比较普遍，遂不进行说明，ES6之后的语言风格跟ES5以前的差异比较大，所以单独拎出来做个记录。**', '87', '456', '2019-12-18');
INSERT INTO `articles` VALUES ('5', 'chenin', '前端', '2020年 我要这样写代码 | 年度征文', '在 9102 年年初，一位室友问我一个问题，如何才能够提升写代码的能力?\r\n\r\n可惜的是: 当时仅仅回复了一些自己的想法，如多看开源代码，多读书，多学习，多关注业界的动向与实践，同时也列了一些原则。但是这些并没有所总结，又或者说没有例子的语言始终是空泛的。所以在今年年底之际，对应着今年中遇到的形形色色的代码问题来一一讲解一下。\r\n\r\n## 好代码的用处\r\n\r\n> 实际上本书建立在一个相当不可靠的前提之上：好的代码是有意义的。我见过太多丑陋的代码给他们的主人赚着大把钞票，所以在我看来，软件要取得商业成功或者广泛使用，“好的代码质量”既不必要也不充分。即使如此，我仍然相信，尽管代码质量不能保证美好的未来，他仍然有其意义：有了质量良好的代码以后，业务需求能够被充满信心的开发和交付，软件用户能够及时调整方向以便应对机遇和竞争，开发团队能够再挑战和挫折面前保持高昂的斗志。总而言之，比起质量低劣，错误重重的代码，好的代码更有可能帮助用户取得业务上的成功。\r\n\r\n以上文字摘抄于《实现模式》的前言，距离本书翻译已经时隔 10 年了，但是这本书仍旧有着很大的价值。同时对于上述言论，我并不持否认意见。但是我认为，坏代码比好代码更加的费财(嗯，没打错，我确定)。对于相同的业务需求，坏代码需要投入的精力，时间更多，产出反而会更少。同时根据破窗理论( 此理论认为环境中的不良现象如果被放任存在，会诱使人们仿效，甚至变本加厉 )，坏代码会产生更坏的代码。这是一个恶性循环，如果不加以控制，完成需求的时间会慢慢失去控制。需要完成需求的人也会失落离开。\r\n\r\n也就是说，好代码可以实现多赢，能够让用户爽，能够让老板爽，能够让开发者爽。总之，大家爽才是真的爽。\r\n\r\n## 怎么写出好代码\r\n\r\n### 少即使多\r\n\r\n利用开源出来的设计与代码来减轻来自于业务线的时间压力。\r\n\r\n> The best way to write secure and reliable applications. Write nothing; deploy nowhere.\r\n\r\n以上取自 github  上最火的项目之一 [nocode](https://github.com/kelseyhightower/nocode)。懒惰是程序员的美德之一。所以学习业务，理解业务，拒绝不必要的需求也是一个程序员的必修功课。详情可以参考[如何杜绝一句话需求？](https://mp.weixin.qq.com/s/65pyUN7z8_MpiXk8kJTSqg) 这一篇 blog，当然，在大部分场景下，我们是不具备对需求说不的能力与权力的，但是无论如何，深度的理解业务，对客户有同理心是对程序员的更高要求。解决问题才是一个程序员需要做的事情。能够理解好题意才能解决问题。\r\n\r\n对于软件开发而言，时间一定是最宝贵，最有价值的资源。相应的，尽量把时间耗费在解决新的问题，而不是对已经存在确切解决方案的问题老调重弹。所以，尽量不要自己写代码，而是借用别人的设计与实现。而在事实上，你也很难在极短的时间压力下设计并完成比开源更加合适的代码。\r\n\r\n当然，开源作者一定是想让他的产品有更多的受众，所以从设计上而言，会采用较为通用的设计，如果你的需求较为特殊并且你觉得不能说服作者帮你“免费打工”(或者作者拒绝了)，那么你也只需要在特定之处进行包装与改写,但是要比完全重写要简单太多了。\r\n\r\n当然，调研新的技术方案并且使用到项目中是一种能力，但是千万不要因为一个小功能添加一个非常大的项目。\r\n\r\n笔者在之前就遇到过其他小伙伴因为无法使用数字四舍五入。说 fixed 方法有问题而使用 math.js  的小伙伴。\r\n\r\n```\r\n(11.545).toFixed(2)\r\n// \"11.54\"\r\n复制代码\r\n```\r\n\r\n如果想要了解 fixed 方法为何有问题的，可以参考 [为什么(2.55).toFixed(1)等于2.5？](https://zhuanlan.zhihu.com/p/31202697) 作者以 v8  源码来解释为何会有这样的问题，以及提供了部分修正 fixed 的方案。\r\n\r\n事实上如果没有很大的精度需求，前端完完全全利用一个函数便可以解决的问题，完全不需要复杂的math 这种高精度库。\r\n\r\n```\r\nfunction round(number, precision) {\r\n    return Math.round(+number + \'e\' + precision) / Math.pow(10, precision);\r\n}\r\n复制代码\r\n```\r\n\r\n当然，也有小伙伴来找我询问大量数据的表格优化，我第一反应就是 [React Infinite](https://github.com/seatgeek/react-infinite) 或者 [vue-infinite-scroll](https://github.com/ElemeFE/vue-infinite-scroll) 此类解决方案。但是对方能够多提供一些信息包括上下文，采用的技术栈，当前数据量大小，未来可能需要达到的大小，当前表格是否需要修改等。得到了这些信息，结合业务来看，相比于增加一个库，是否如下方式更为便捷与快速。\r\n\r\n```\r\n// 因为 vue 模型的原因，使用 Object.freeze 性能可以有很大增益\r\nthis.xxx = Object.freeze(xxx);\r\n复制代码\r\n```\r\n\r\n随着堆积业务，代码的增长。管理复杂度的成本与日俱增，把依赖降低。  利用开源代码使得任务更容易实现。时间就是成本。关键是让收益可以最大化。\r\n\r\n学习更多是为了做的更少。\r\n\r\n### 统一\r\n\r\n不同的人由于编码经验和编码偏好不同，项目中同一个功能的实现代码可能千差万别。但是如果不加以约束，让每一个人都按照自己的偏好写自己的模块，恐怕就会变成灾难。\r\n\r\n所以每次在学习一些新技术的时候，我总是想多看看作者的实例代码，作者是如何理解的，社区又是如何理解的。以求实现起来代码风格不至于偏离社区太多，这样的话可以提高沟通与协作的效率。类似于 《阿里巴巴Java开发手册》 或者  [vue 风格指南](https://cn.vuejs.org/v2/style-guide/) 这种取自大公司或社区的经验之谈，要多读几遍。因为他们所遇到的问题和业务更加复杂。\r\n\r\n对于公司内部开发来说，写一个组件时候，生命周期的代码放在文件上面还是放在最下面，如何把代码的一个功能点集中放置。通用型代码的修改。代码行数的限制。能够列出统一的方案，多利而少害。\r\n\r\n### 化繁为简（抽象）\r\n\r\n抽象是指从具体事物抽出、概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃的思维过程。\r\n\r\n如果你面对一个较大的系统，你会发现重构并不能解决根本问题，它仅仅只能减少少许的代码的复杂度以及代码行数，只有抽象才可以解决实质性问题。\r\n\r\n无论是数据库设计，架构设计，业务设计，代码设计，但凡设计都离不开抽象。抽象能力强的所面临的困难会比能力弱的少很多。\r\n\r\n或者说抽象能力弱一些的小伙伴遇到一些问题甚至需要重新推翻然后再设计，这个是在时间和业务开发中是不能被接受的。\r\n\r\n这里就谈谈代码，以下也举个例子,如 [axios](https://github.com/axios/axios) 库中有拦截器与本身业务，在没有看到源码之前，我一直认为他是分 3 阶段处理:\r\n\r\n- 请求拦截\r\n- 业务处理\r\n- 响应拦截\r\n\r\n但如果你去看源码,你就会发现其实在作者看来，这 3 个阶段其实都是在处理一个 Promise 队列而已。\r\n\r\n```\r\n// 业务处理\r\nvar chain = [dispatchRequest, undefined];\r\nvar promise = Promise.resolve(config);\r\n\r\nthis.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\r\n    // 前置请求拦截\r\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\r\n  });\r\nthis.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\r\n    // 后置响应拦截\r\n    chain.push(interceptor.fulfilled, interceptor.rejected);\r\n  });\r\n\r\n  while (chain.length) {\r\n    promise = promise.then(chain.shift(), chain.shift());\r\n  }\r\n\r\n  return promise;\r\n复制代码\r\n```\r\n\r\n这就是一种代码抽象能力。让自己的代码可以适应更多的场景是程序员需要思考的。代码不是给机器看的，是给人看的，更高的要求是: 代码不仅仅是给人看的，更是给人用的。需要考虑到协作的人与事，灵活的配置也是必须要考虑到的。就拿前端的 虚拟 dom 来说。能够适配更多的平台。\r\n\r\n当然了，抽象能力需要时间，需要经验，需要学习大量的设计。\r\n\r\n注意!:不要过早的抽象业务代码，甚至不要抽象业务代码。多写一点代码无所谓，千万别给自己找事做。 在业务上尽量保持简单和愚蠢。除非你是业务专家，确认当前业务不太会产生变化。\r\n\r\n### 权责对等(拆分与合并)\r\n\r\n责任与义务本质上就是对等的，且越对等的就越稳定。这几年，微服务架构，中台，微前端理论层出不穷，本质上就是为了权责对等，对于更加基础的服务，更有产出的业务投入更高的人力与物力以保证更稳定的运行是很正常的一件事。而不是之前的大锅饭(单体应用)。\r\n\r\n从代码上来看，某个模块是否承担了它不应该做的事情，或者某个模块过于简单，徒增复杂度。\r\n\r\n当然，事实上有些东西目前是做不到的让所有人都觉得满意，增一分则肥,减一分则瘦,刚刚好很难界定。就像 Dan Abramov 说的那样:\r\n\r\n> Flux libraries are like glasses: you’ll know when you need them.\r\n\r\n### 只做一件事\r\n\r\nUnix 哲学，这个很好理解，就像我今年想做的事情太多，反而什么都没有做(或者说都做了,但都不好)。\r\n\r\n代码上来看，不要因为一点点性能的原因，把几件事合在一起去做。例如在一次 for 循环中解决所有问题，或者将所有代码写在一个函数中，例如:\r\n\r\n```\r\ncreated() {\r\n  const {a,b,c,d} = this.data\r\n  // ... 三件事情彼此有交互同时需要 a,b,c,d\r\n  \r\n  // 完成之后的逻辑\r\n}\r\n复制代码\r\n```\r\n\r\n改造后:\r\n\r\n```\r\ncreated() {\r\n  const axx = doA()\r\n  doB()\r\n  const cxx =  doC()\r\n  // 完成之后的逻辑\r\n}\r\n\r\n// 分离出3个函数\r\ndoA() {\r\n   const {a,b,c} = this.data\r\n  // ... 三件事情彼此有交互同时需要 a,b,c,d\r\n  \r\n  // 完成之后的逻辑\r\n}\r\n// 其他代码\r\n复制代码\r\n```\r\n\r\n相比于第一个只需要一次取数，一次setData，第二个性能无疑更低，但是可维护性变高了，3 件事情都被拆分出来，后面修改代码时候，我可以追加一个 doD 而不是再次把第一份代码中逻辑整理清楚再小心翼翼的修改代码。\r\n\r\n### 命名与注释\r\n\r\n> There are only two hard things in Computer Science: cache invalidation and naming things.\r\n\r\n命名与缓存失效是两大难题，今年讲了不少缓存问题，同时，命名的确是很困难的一件事情。通过一句话来解释你们在做什么事情，通过一句话来解释一件事的意图。\r\n\r\n不说在程序世界中，在现实世界中也是如此。例如: 《震惊!xxx居然xxx》等新闻,虽然说看完后都会想要骂一句，但是，正如这样的名字才能吸引人家点击进入，让人情不自禁的被骗一次又一次。所以在项目没有发布前，要取一个简单而又好记的名字。\r\n\r\n但在程序内部，我们不需要“骗取”人家的点击量，反而是要务实点，不要欺骗另外的同伴，比如说写了一个简单的名字，结果内部却封装了很多的业务代码。同时我认为这也是函数越写越短的理由，因为大家难以通过命名来解释那一大坨代码的意图。所以，需要编写可以自我解释的代码，而这种代码最佳实践就是好的命名。\r\n\r\n对于开源代码，你往往会发现，这些文件开头都会有一系列注释，这个注释告诉我们了这个模块的意图与目的。让你无需看代码就可以进行开发。\r\n\r\n对于业务开发而言，仅在你不能通过代码清晰解释其含义的地方，才写注释。在多个条件下都无法解释你的代码。\r\n\r\n- 项目名\r\n- 模块名\r\n- 文件名(类名)\r\n- 函数名(方法名)\r\n\r\n这并不是让你不写注释。但是我觉得更多的注释应该放在数据结构而不是代码逻辑上。聪明的数据结构和笨拙的代码要比相反的搭配工作的更好。更多的时候，看数据结构我能了解业务是如何运行的，但是仅仅看到代码并不能实际想象出来。\r\n\r\n实际上，随着时间的推移，代码做出了许多改动，但注释并没有随之修改，这是一个很大的问题。注释反而变得更有欺骗性。\r\n\r\n这里也提供一篇 [export default 有害](https://jkchao.github.io/typescript-book-chinese/tips/avoidExportDefault.html) 的文章。我觉得 export default 导出一个可以随意命名的模块就是一种欺骗性代码(随着时间的推移，该模块的意图会发生变化)。\r\n\r\n### 考虑场景\r\n\r\n没有放眼四海皆准的方案，所以我们必须要考虑到场景的问题，我们总是说可修改性，可读性是第一位的(往往可读，可修改的代码性能都不差)。但是如果是急切需求性能的场景下，有些事情是需要再考虑的。\r\n\r\nif 是业务处理中最常用的，在每次使用前要考虑以下，哪个更适合作为主体，哪个更适合放在前面进行判断。如果有两个维度上的参数，一个是角色，一个是事件。一定是会先判断角色参数，然后再去判断事件参数，反之则一定不好。因为前者更符合人的思维模式。在同一维度下，至于哪个放前面，一定是更多被使用的参数放在前面更好，因为更符合机器的执行过程。\r\n\r\n就像在 if 中你究竟是使用 else 还是 return。大部分情况下处理业务逻辑互斥使用 else,处理错误使用return。因为这样的代码最符合人的思维逻辑。\r\n\r\n但是在这里我也要举出来自《代码之美》的例子，在第五章中，作者 Elliotte Rusty Harold 设计了一个 xml 验证器，其中有一段在验证数字字符:\r\n\r\n```\r\npublic static boolean isXMLDigit(char c) {\r\n  if (c >= 0x0030 && c <= 0x0039) return true;\r\n  if (c >= 0x0660 && c <= 0x0669) return true;\r\n  if (c >= 0x06F0 && c <= 0x06F9) return true;\r\n  // ...\r\n  return false\r\n}\r\n复制代码\r\n```\r\n\r\n这个优化之后如下:\r\n\r\n```\r\npublic static boolean isXMLDigit(char c) {\r\n  if (c < 0x0030) return false; if (c <= 0x0039) return true;\r\n  if (c < 0x0660) return false; if (c <= 0x0669) return true;\r\n  if (c < 0x06F0) return false; if (c <= 0x06F0) return true;\r\n  // ...\r\n  return false\r\n}\r\n复制代码\r\n```\r\n\r\n### 全局思考，善于交流\r\n\r\n软件开发已经不是一个人打天下的时代了，你要不停的触达边界。在前后端分离的时代，前端可以不知道数据库如何优化，后端也可以不清楚浏览器的渲染机制，但是却不能不明白对方在做什么。否则等于鸡同鸭讲，也会浪费时间。在开发时候，把一段逻辑放在那一端取决安全的思考以及简化逻辑。\r\n\r\n善于交流是一种能力，在与别人交流时给与足够的上下文，让你的 leader 沟通，让她知道你的难处。和小伙伴沟通，说服他人按照你的想法推进，同时，善于聆听才能不断进步。\r\n\r\n### 算法\r\n\r\n我不是一个算法达人( leetcode 中等题目都费劲 )，但这个没什么可说的，你拿你的 O(n**3) 算法去对战人家 O(n * logn) 算法就是费财。所以，知道自己某方面不够好去努力就行了。\r\n\r\n## 辅助工具\r\n\r\n### TypeScript\r\n\r\n虽然早就接触和实践过，但是以往都是 AnyScript。今年也算重度使用了。才体会到该工具的利好。一个好的开发工具并不是让你少写那一点点代码，而是让你在交付代码时候能够更加自信。\r\n\r\nTypeScript  最大的好处就是让你在写代码前先思考，先做设计。就像之前说的。聪明的数据结构和笨拙的代码要比相反的搭配工作的更好。\r\n\r\nTypeScript 同时也可以让大部分运行时错误变为编译时，并且可以减少使用中的防御性编程(信任但是仍要验证)。你不是一个人在写代码，协作优先。\r\n\r\n在开发中，如果你接触过复杂性数据结构，并且还要在模块中不断进行数据转化，你就会不断的遇到：我的数据呢？到底在那一步丢失了？并且即使是代码对的，你仍旧害怕，仍旧怀疑。我已经过了那个“写 bug 是因为想的不够多，不够彻底”的年龄。\r\n\r\n### 函数式思维\r\n\r\njs 是有函数式的血统的，当年一直听说，函数是一等公民，只是当时完全不能理解。\r\n\r\n纯函数，数据不可变以及代码即数据这三点是我认为是函数式思维对代码能力提升最大的三点。\r\n\r\n这个我不想展开去聊，因为我没有熟练掌握过任何一门纯函数式语言。但是我的代码一定有函数式的影子，并且它的确让我的代码更优美。\r\n\r\n### 其他\r\n\r\n单元测试，代码审查，安全等等都没有讲到，这个我也需要足够的学习才能有所输出。不过这里列出一些资料供大家学习与了解:\r\n\r\n[谷歌代码审查指南](https://jimmysong.io/eng-practices/docs/review/)\r\n\r\n[SaaS型初创企业安全101](https://github.com/forter/security-101-for-saas-startups/blob/chinese/readme.md)\r\n\r\n## 有理有据就是好代码\r\n\r\n工作在别人遗留的糟糕代码上是常有的事情，同时面对开发需求实际表，为了兼容，我们也不得不写出一些不那么好的代码。但是面对他人的疑问，我们需要给与别人这样做的理由，也就是你的每一行代码写下去一定有充分的理由和依据。', '587', '8543', '2019-12-18');
INSERT INTO `articles` VALUES ('6', 'chenin', '开发工具', 'Markdown编辑器教程', '## 概览\r\n\r\n### 宗旨\r\n\r\nMarkdown 的目标是实现「易读易写」。\r\n\r\n可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 [Setext](http://docutils.sourceforge.net/mirror/setext.html)、[atx](http://www.aaronsw.com/2002/atx/)、[Textile](http://textism.com/tools/textile/)、[reStructuredText](http://docutils.sourceforge.net/rst.html)、[Grutatext](http://www.triptico.com/software/grutatxt.html) 和 [EtText](http://ettext.taint.org/doc/)，而最大灵感来源其实是纯文本电子邮件的格式。\r\n\r\n### 兼容 HTML\r\n\r\nMarkdown 语法的目标是：成为一种适用于网络的书写语言。\r\n\r\nMarkdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。\r\n\r\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。\r\n\r\n要制约的只有一些 HTML 区块元素――比如 <div>、<table>、<pre>、<p> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <p> 标签。\r\n\r\n例子如下，在 Markdown 文件里加上一段 HTML 表格：\r\n\r\n```html\r\n这是一个普通段落。\r\n\r\n<table>\r\n    <tr>\r\n        <td>Foo</td>\r\n    </tr>\r\n</table>\r\n\r\n这是另一个普通段落。\r\n```\r\n\r\n请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。\r\n\r\nHTML 的区段（行内）标签如 <span>、<cite>、<del> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <a> 或 <img> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。\r\n\r\n和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。\r\n\r\n### 特殊字符自动转换\r\n\r\n在 HTML 文件中，有两个字符需要特殊处理： < 和 & 。 < 符号用于起始标签，& 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt; 和 &amp;。\r\n\r\n& 字符尤其让网络文档编写者受折磨，如果你要打「AT&T」 ，你必须要写成「AT&amp;T」。而网址中的 & 字符也要转换。比如你要链接到：\r\n\r\nhttp://images.google.com/images?num=30&q=larry+bird\r\n\r\n你必须要把网址转换写为：\r\n\r\nhttp://images.google.com/images?num=30&q=larry+bird\r\n\r\n才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。\r\n\r\nMarkdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 & 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;。\r\n\r\n所以你如果要在文档中插入一个版权符号©，你可以这样写：\r\n\r\n```html\r\n&copy;\r\n```\r\n\r\nMarkdown 会保留它不动。而若你写：\r\n\r\n```html\r\nAT&T\r\n```\r\n\r\nMarkdown 就会将它转为：\r\n\r\n```html\r\nAT&amp;T\r\n```\r\n\r\n类似的状况也会发生在 < 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 < 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：\r\n\r\n```html\r\n4 < 5\r\n```\r\n\r\nMarkdown 将会把它转换为：\r\n\r\n```html\r\n4 &lt; 5\r\n```\r\n\r\n不过需要注意的是，code 范围内，不论是行内还是区块， < 和 & 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 < 和 & 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）\r\n\r\n## 区块元素\r\n\r\n### 段落和换行\r\n\r\n一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。\r\n\r\n「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <br /> 标签。\r\n\r\n如果你确实想要依赖 Markdown 来插入 <br /> 标签的话，在插入处先按入两个以上的空格然后回车。\r\n\r\n的确，需要多费点事（多加空格）来产生 <br /> ，但是简单地「每个换行都转换为 <br />」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。\r\n\r\n### 标题\r\n\r\nMarkdown 支持两种标题的语法，类 Setext 和类 atx 形式。\r\n\r\n类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：\r\n\r\n```html\r\nThis is an H1\r\n=============\r\n\r\nThis is an H2\r\n-------------\r\n```\r\n\r\n任何数量的 = 和 - 都可以有效果。\r\n\r\n类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：\r\n\r\n```html\r\n# 这是 H1\r\n\r\n## 这是 H2\r\n\r\n###### 这是 H6\r\n```\r\n\r\n你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：\r\n\r\n```html\r\n# 这是 H1 #\r\n\r\n## 这是 H2 ##\r\n\r\n### 这是 H3 ######\r\n```\r\n\r\n### 区块引用Blockquotes\r\n\r\nMarkdown 标记区块引用是使用类似 email 中用 > 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 > ：\r\n\r\n```md\r\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\r\n> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\r\n> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\r\n> \r\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\r\n> id sem consectetuer libero luctus adipiscing.\r\n```\r\n\r\nMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 > ：\r\n\r\n```md\r\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\r\nconsectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\r\nVestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\r\n\r\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\r\nid sem consectetuer libero luctus adipiscing.\r\n```\r\n\r\n区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 > ：\r\n\r\n```md\r\n This is the first level of quoting.\r\n>\r\n> > This is nested blockquote.\r\n>\r\n> Back to the first level.\r\n```\r\n\r\n引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\r\n\r\n```md\r\n> ## 这是一个标题。\r\n> \r\n> 1.   这是第一行列表项。\r\n> 2.   这是第二行列表项。\r\n> \r\n> 给出一些例子代码：\r\n> \r\n>     return shell_exec(\"echo $input | $markdown_script\");\r\n```\r\n\r\n任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。\r\n\r\n### 列表\r\n\r\nMarkdown 支持有序列表和无序列表。\r\n\r\n无序列表使用星号、加号或是减号作为列表标记：\r\n\r\n```md\r\n*   Red\r\n*   Green\r\n*   Blue\r\n```\r\n\r\n等同于：\r\n\r\n```md\r\n+   Red\r\n+   Green\r\n+   Blue\r\n```\r\n\r\n也等同于：\r\n\r\n```md\r\n-   Red\r\n-   Green\r\n-   Blue\r\n```\r\n\r\n有序列表则使用数字接着一个英文句点：\r\n\r\n```md\r\n1.  Bird\r\n2.  McHale\r\n3.  Parish\r\n```\r\n\r\n很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：\r\n\r\n```md\r\n<ol>\r\n<li>Bird</li>\r\n<li>McHale</li>\r\n<li>Parish</li>\r\n</ol>\r\n```\r\n\r\n如果你的列表标记写成：\r\n\r\n```md\r\n1.  Bird\r\n1.  McHale\r\n1.  Parish\r\n```\r\n\r\n或甚至是：\r\n\r\n```md\r\n3. Bird\r\n1. McHale\r\n8. Parish\r\n```\r\n\r\n你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。\r\n\r\n如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。\r\n\r\n列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。\r\n\r\n要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：\r\n\r\n```md\r\n*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\r\n    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\r\n    viverra nec, fringilla in, laoreet vitae, risus.\r\n*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\r\n    Suspendisse id sem consectetuer libero luctus adipiscing.\r\n```\r\n\r\n但是如果你懒，那也行：\r\n\r\n```md\r\n*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\r\nAliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\r\nviverra nec, fringilla in, laoreet vitae, risus.\r\n*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\r\nSuspendisse id sem consectetuer libero luctus adipiscing.\r\n```\r\n\r\n如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <p> 标签包起来，举例来说：\r\n\r\n```md\r\n*   Bird\r\n*   Magic\r\n```\r\n\r\n会被转换为：\r\n\r\n```md\r\n<ul>\r\n<li>Bird</li>\r\n<li>Magic</li>\r\n</ul>\r\n```\r\n\r\n但是这个：\r\n\r\n```md\r\n*   Bird\r\n\r\n*   Magic\r\n```\r\n\r\n会被转换为：\r\n\r\n```md\r\n<ul>\r\n<li><p>Bird</p></li>\r\n<li><p>Magic</p></li>\r\n</ul>\r\n```\r\n\r\n列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：\r\n\r\n```md\r\n1.  This is a list item with two paragraphs. Lorem ipsum dolor\r\n    sit amet, consectetuer adipiscing elit. Aliquam hendrerit\r\n    mi posuere lectus.\r\n\r\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet\r\n    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum\r\n    sit amet velit.\r\n\r\n2.  Suspendisse id sem consectetuer libero luctus adipiscing.\r\n```\r\n\r\n如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：\r\n\r\n```md\r\n*   This is a list item with two paragraphs.\r\n\r\n    This is the second paragraph in the list item. You\'re\r\nonly required to indent the first line. Lorem ipsum dolor\r\nsit amet, consectetuer adipiscing elit.\r\n\r\n*   Another item in the same list.\r\n```\r\n\r\n如果要在列表项目内放进引用，那 > 就需要缩进：\r\n\r\n```md\r\n*   A list item with a blockquote:\r\n\r\n    > This is a blockquote\r\n    > inside a list item.\r\n```\r\n\r\n如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：\r\n\r\n```md\r\n*   一列表项包含一个列表区块：\r\n\r\n        <代码写在这>\r\n```\r\n\r\n当然，项目列表很可能会不小心产生，像是下面这样的写法\r\n\r\n```md\r\n1986. What a great season.\r\n```\r\n\r\n换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。\r\n\r\n```md\r\n1986\\. What a great season.\r\n```\r\n\r\n### 代码区块\r\n\r\n和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <pre> 和 <code> 标签来把代码区块包起来。\r\n\r\n要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：\r\n\r\n```md\r\n这是一个普通段落：\r\n\r\n    这是一个代码区块。\r\n```\r\n\r\nMarkdown 会转换成：\r\n\r\n```md\r\n<p>这是一个普通段落：</p>\r\n\r\n<pre><code>这是一个代码区块。\r\n</code></pre>\r\n```\r\n\r\n这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：\r\n\r\n```md\r\nHere is an example of AppleScript:\r\n\r\n    tell application \"Foo\"\r\n        beep\r\n    end tell\r\n```\r\n\r\n会被转换为：\r\n\r\n```md\r\n<p>Here is an example of AppleScript:</p>\r\n\r\n<pre><code>tell application \"Foo\"\r\n    beep\r\nend tell\r\n</code></pre>\r\n```\r\n\r\n一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\r\n\r\n在代码区块里面， & 、 < 和 > 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：\r\n\r\n```md\r\n<div class=\"footer\">\r\n  &copy; 2004 Foo Corporation\r\n</div>\r\n```\r\n\r\n会被转换为：\r\n\r\n```md\r\n<pre><code>&lt;div class=\"footer\"&gt;\r\n    &amp;copy; 2004 Foo Corporation\r\n&lt;/div&gt;\r\n</code></pre>\r\n```\r\n\r\n代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。\r\n\r\n### 分隔线\r\n\r\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\r\n\r\n```md\r\n* * *\r\n\r\n***\r\n\r\n*****\r\n\r\n- - -\r\n\r\n---------------------------------------\r\n```\r\n\r\n## 区段元素\r\n\r\n### 链接\r\n\r\nMarkdown 支持两种形式的链接语法： 行内式和参考式两种形式。\r\n\r\n不管是哪一种，链接文字都是用 [方括号] 来标记。\r\n\r\n要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：\r\n\r\n```md\r\nThis is [an example](http://example.com/ \"Title\") inline link.\r\n\r\n[This link](http://example.net/) has no title attribute.\r\n```\r\n\r\n会产生：\r\n\r\n```md\r\n<p>This is <a href=\"http://example.com/\" title=\"Title\">\r\nan example</a> inline link.</p>\r\n\r\n<p><a href=\"http://example.net/\">This link</a> has no\r\ntitle attribute.</p>\r\n```\r\n\r\n如果你是要链接到同样主机的资源，你可以使用相对路径：\r\n\r\n```md\r\nSee my [About](/about/) page for details.\r\n```\r\n\r\n参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：\r\n\r\n```md\r\nThis is [an example][id] reference-style link.\r\n```\r\n\r\n你也可以选择性地在两个方括号中间加上一个空格：\r\n\r\n```md\r\nThis is [an example] [id] reference-style link.\r\n```\r\n\r\n接着，在文件的任意处，你可以把这个标记的链接内容定义出来：\r\n\r\n```md\r\n[id]: http://example.com/  \"Optional Title Here\"\r\n```\r\n\r\n链接内容定义的形式为：\r\n\r\n- 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字\r\n- 接着一个冒号\r\n- 接着一个以上的空格或制表符\r\n- 接着链接的网址\r\n- 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着\r\n\r\n下面这三种链接的定义都是相同：\r\n\r\n```md\r\n[foo]: http://example.com/  \"Optional Title Here\"\r\n[foo]: http://example.com/  \'Optional Title Here\'\r\n[foo]: http://example.com/  (Optional Title Here)\r\n```\r\n\r\n**请注意：**有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。\r\n\r\n链接网址也可以用方括号包起来：\r\n\r\n```md\r\n[id]: \"Optional Title Here\"\r\n```\r\n\r\n你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：\r\n\r\n```md\r\n[id]: http://example.com/longish/path/to/resource/here\r\n    \"Optional Title Here\"\r\n```\r\n\r\n网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。\r\n\r\n链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的：\r\n\r\n```md\r\n[link text][a]\r\n[link text][A]\r\n```\r\n\r\n隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 \"Google\" 链接到 google.com，你可以简化成：\r\n\r\n```md\r\n[Google][]\r\n```\r\n\r\n然后定义链接内容：\r\n\r\n```md\r\n[Google]: http://google.com/\r\n```\r\n\r\n由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：\r\n\r\n```md\r\nVisit [Daring Fireball][] for more information.\r\n```\r\n\r\n然后接着定义链接\r\n\r\n```md\r\n[Daring Fireball]: http://daringfireball.net/\r\n```\r\n\r\n链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。\r\n\r\n下面是一个参考式链接的范例：\r\n\r\n```md\r\nI get 10 times more traffic from [Google] [1] than from\r\n[Yahoo] [2] or [MSN] [3].\r\n\r\n  [1]: http://google.com/        \"Google\"\r\n  [2]: http://search.yahoo.com/  \"Yahoo Search\"\r\n  [3]: http://search.msn.com/    \"MSN Search\"\r\n```\r\n\r\n如果改成用链接名称的方式写：\r\n\r\n```md\r\nI get 10 times more traffic from [Google][] than from\r\n[Yahoo][] or [MSN][].\r\n\r\n  [google]: http://google.com/        \"Google\"\r\n  [yahoo]:  http://search.yahoo.com/  \"Yahoo Search\"\r\n  [msn]:    http://search.msn.com/    \"MSN Search\"\r\n```\r\n\r\n上面两种写法都会产生下面的 HTML。\r\n\r\n```md\r\n<p>I get 10 times more traffic from <a href=\"http://google.com/\"\r\ntitle=\"Google\">Google</a> than from\r\n<a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\">Yahoo</a>\r\nor <a href=\"http://search.msn.com/\" title=\"MSN Search\">MSN</a>.</p>\r\n```\r\n\r\n下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：\r\n\r\n```md\r\nI get 10 times more traffic from [Google](http://google.com/ \"Google\")\r\nthan from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or\r\n[MSN](http://search.msn.com/ \"MSN Search\").\r\n```\r\n\r\n参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。\r\n\r\n使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。\r\n\r\n### 强调\r\n\r\nMarkdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 <em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 <strong>，例如：\r\n\r\n```md\r\n*single asterisks*\r\n\r\n_single underscores_\r\n\r\n**double asterisks**\r\n\r\n__double underscores__\r\n```\r\n\r\n会转成：\r\n\r\n```md\r\n<em>single asterisks</em>\r\n\r\n<em>single underscores</em>\r\n\r\n<strong>double asterisks</strong>\r\n\r\n<strong>double underscores</strong>\r\n```\r\n\r\n你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。\r\n\r\n强调也可以直接插在文字中间：\r\n\r\n```md\r\nun*frigging*believable\r\n```\r\n\r\n但是**如果你的 \\* 和 _ 两边都有空白的话，它们就只会被当成普通的符号。**\r\n\r\n如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：\r\n\r\n```md\r\n\\*this text is surrounded by literal asterisks\\*\r\n```\r\n\r\n### 代码\r\n\r\n如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：\r\n\r\n```md\r\nUse the `printf()` function.\r\n```\r\n\r\n会产生：\r\n\r\n```md\r\n<p>Use the <code>printf()</code> function.</p>\r\n```\r\n\r\n如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：\r\n\r\n```md\r\n``There is a literal backtick (`) here.``\r\n```\r\n\r\n这段语法会产生：\r\n\r\n```md\r\n<p><code>There is a literal backtick (`) here.</code></p>\r\n```\r\n\r\n代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：\r\n\r\n```md\r\nA single backtick in a code span: `` ` ``\r\n\r\nA backtick-delimited string in a code span: `` `foo` ``\r\n```\r\n\r\n会产生：\r\n\r\n```md\r\n<p>A single backtick in a code span: <code>`</code></p>\r\n\r\n<p>A backtick-delimited string in a code span: <code>`foo`</code></p>\r\n```\r\n\r\n在代码区段内，& 和方括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：\r\n\r\n```md\r\nPlease don\'t use any `<blink>` tags.\r\n```\r\n\r\n转为：\r\n\r\n```md\r\n<p>Please don\'t use any <code><blink></code> tags.</p>\r\n```\r\n\r\n你也可以这样写：\r\n\r\n```md\r\n`&#8212;` is the decimal-encoded equivalent of `&mdash;`.\r\n```\r\n\r\n以产生：\r\n\r\n```md\r\n<p><code>&amp;#8212;</code> is the decimal-encoded\r\nequivalent of <code>&amp;mdash;</code>.</p>\r\n```\r\n\r\n### 图片\r\n\r\n很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。\r\n\r\nMarkdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。\r\n\r\n行内式的图片语法看起来像是：\r\n\r\n```md\r\n![Alt text](/path/to/img.jpg)\r\n\r\n![Alt text](/path/to/img.jpg \"Optional title\")\r\n```\r\n\r\n详细叙述如下：\r\n\r\n- 一个惊叹号 !\r\n- 接着一个方括号，里面放上图片的替代文字\r\n- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 \'title\' 文字。\r\n\r\n参考式的图片语法则长得像这样：\r\n\r\n```md\r\n![Alt text][id]\r\n```\r\n\r\n「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：\r\n\r\n```md\r\n[id]: url/to/image  \"Optional title attribute\"\r\n```\r\n\r\n到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <img> 标签。\r\n\r\n## 其它\r\n\r\n### 反斜杠\r\n\r\nMarkdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <em> 标签），你可以在星号的前面加上反斜杠：\r\n\r\n```md\r\n\\*literal asterisks\\*\r\n```\r\n\r\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\r\n\r\n```md\r\n\\   反斜线\r\n`   反引号\r\n*   星号\r\n_   底线\r\n{}  花括号\r\n[]  方括号\r\n()  括弧\r\n#   井字号\r\n+   加号\r\n-   减号\r\n.   英文句点\r\n!   惊叹号\r\n```\r\n\r\n### 自动链接\r\n\r\nMarkdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\r\n\r\n```md\r\n<http://example.com/>\r\n```\r\n\r\nMarkdown 会转为：\r\n\r\n```md\r\n<a href=\"http://example.com/\">http://example.com/</a>\r\n```\r\n\r\n邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：\r\n\r\n```md\r\n<address@example.com>\r\n```\r\n\r\nMarkdown 会转成：\r\n\r\n```md\r\n<a href=\"mailto:addre\r\nss@example.co\r\nm\">address@exa\r\nmple.com</a>\r\n```\r\n\r\n在浏览器里面，这段字串（其实是 <a href=\"mailto:address@example.com\">address@example.com</a>）会变成一个可以点击的「address@example.com」链接。\r\n\r\n（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）', '5557', '4545', '2019-12-19');
INSERT INTO `articles` VALUES ('7', 'chenin', '开发工具', 'markdown', '## 概览\n\n### 宗旨\n\nMarkdown 的目标是实现「易读易写」。\n\n可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 [Setext](http://docutils.sourceforge.net/mirror/setext.html)、[atx](http://www.aaronsw.com/2002/atx/)、[Textile](http://textism.com/tools/textile/)、[reStructuredText](http://docutils.sourceforge.net/rst.html)、[Grutatext](http://www.triptico.com/software/grutatxt.html) 和 [EtText](http://ettext.taint.org/doc/)，而最大灵感来源其实是纯文本电子邮件的格式。\n\n### 兼容 HTML\n\nMarkdown 语法的目标是：成为一种适用于网络的书写语言。\n\nMarkdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。\n\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。\n\n要制约的只有一些 HTML 区块元素――比如 <div>、<table>、<pre>、<p> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <p> 标签。\n\n例子如下，在 Markdown 文件里加上一段 HTML 表格：\n\n```html\n这是一个普通段落。\n\n<table>\n    <tr>\n        <td>Foo</td>\n    </tr>\n</table>\n\n这是另一个普通段落。\n```\n\n请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。\n\nHTML 的区段（行内）标签如 <span>、<cite>、<del> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <a> 或 <img> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。\n\n和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。\n\n### 特殊字符自动转换\n\n在 HTML 文件中，有两个字符需要特殊处理： < 和 & 。 < 符号用于起始标签，& 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt; 和 &amp;。\n\n& 字符尤其让网络文档编写者受折磨，如果你要打「AT&T」 ，你必须要写成「AT&amp;T」。而网址中的 & 字符也要转换。比如你要链接到：\n\nhttp://images.google.com/images?num=30&q=larry+bird\n\n你必须要把网址转换写为：\n\nhttp://images.google.com/images?num=30&q=larry+bird\n\n才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。\n\nMarkdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 & 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;。\n\n所以你如果要在文档中插入一个版权符号©，你可以这样写：\n\n```html\n&copy;\n```\n\nMarkdown 会保留它不动。而若你写：\n\n```html\nAT&T\n```\n\nMarkdown 就会将它转为：\n\n```html\nAT&amp;T\n```\n\n类似的状况也会发生在 < 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 < 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：\n\n```html\n4 < 5\n```\n\nMarkdown 将会把它转换为：\n\n```html\n4 &lt; 5\n```\n\n不过需要注意的是，code 范围内，不论是行内还是区块， < 和 & 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 < 和 & 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）\n\n## 区块元素\n\n### 段落和换行\n\n一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。\n\n「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <br /> 标签。\n\n如果你确实想要依赖 Markdown 来插入 <br /> 标签的话，在插入处先按入两个以上的空格然后回车。\n\n的确，需要多费点事（多加空格）来产生 <br /> ，但是简单地「每个换行都转换为 <br />」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。\n\n### 标题\n\nMarkdown 支持两种标题的语法，类 Setext 和类 atx 形式。\n\n类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：\n\n```html\nThis is an H1\n=============\n\nThis is an H2\n-------------\n```\n\n任何数量的 = 和 - 都可以有效果。\n\n类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：\n\n```html\n# 这是 H1\n\n## 这是 H2\n\n###### 这是 H6\n```\n\n你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：\n\n```html\n# 这是 H1 #\n\n## 这是 H2 ##\n\n### 这是 H3 ######\n```\n\n### 区块引用Blockquotes\n\nMarkdown 标记区块引用是使用类似 email 中用 > 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 > ：\n\n```md\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n> \n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n> id sem consectetuer libero luctus adipiscing.\n```\n\nMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 > ：\n\n```md\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\nconsectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\nVestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\nid sem consectetuer libero luctus adipiscing.\n```\n\n区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 > ：\n\n```md\n This is the first level of quoting.\n>\n> > This is nested blockquote.\n>\n> Back to the first level.\n```\n\n引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\n\n```md\n> ## 这是一个标题。\n> \n> 1.   这是第一行列表项。\n> 2.   这是第二行列表项。\n> \n> 给出一些例子代码：\n> \n>     return shell_exec(\"echo $input | $markdown_script\");\n```\n\n任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。\n\n### 列表\n\nMarkdown 支持有序列表和无序列表。\n\n无序列表使用星号、加号或是减号作为列表标记：\n\n```md\n*   Red\n*   Green\n*   Blue\n```\n\n等同于：\n\n```md\n+   Red\n+   Green\n+   Blue\n```\n\n也等同于：\n\n```md\n-   Red\n-   Green\n-   Blue\n```\n\n有序列表则使用数字接着一个英文句点：\n\n```md\n1.  Bird\n2.  McHale\n3.  Parish\n```\n\n很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：\n\n```md\n<ol>\n<li>Bird</li>\n<li>McHale</li>\n<li>Parish</li>\n</ol>\n```\n\n如果你的列表标记写成：\n\n```md\n1.  Bird\n1.  McHale\n1.  Parish\n```\n\n或甚至是：\n\n```md\n3. Bird\n1. McHale\n8. Parish\n```\n\n你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。\n\n如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。\n\n列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。\n\n要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：\n\n```md\n*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\n    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\n    viverra nec, fringilla in, laoreet vitae, risus.\n*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\n    Suspendisse id sem consectetuer libero luctus adipiscing.\n```\n\n但是如果你懒，那也行：\n\n```md\n*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\nAliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\nviverra nec, fringilla in, laoreet vitae, risus.\n*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\nSuspendisse id sem consectetuer libero luctus adipiscing.\n```\n\n如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <p> 标签包起来，举例来说：\n\n```md\n*   Bird\n*   Magic\n```\n\n会被转换为：\n\n```md\n<ul>\n<li>Bird</li>\n<li>Magic</li>\n</ul>\n```\n\n但是这个：\n\n```md\n*   Bird\n\n*   Magic\n```\n\n会被转换为：\n\n```md\n<ul>\n<li><p>Bird</p></li>\n<li><p>Magic</p></li>\n</ul>\n```\n\n列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：\n\n```md\n1.  This is a list item with two paragraphs. Lorem ipsum dolor\n    sit amet, consectetuer adipiscing elit. Aliquam hendrerit\n    mi posuere lectus.\n\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet\n    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum\n    sit amet velit.\n\n2.  Suspendisse id sem consectetuer libero luctus adipiscing.\n```\n\n如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：\n\n```md\n*   This is a list item with two paragraphs.\n\n    This is the second paragraph in the list item. You\'re\nonly required to indent the first line. Lorem ipsum dolor\nsit amet, consectetuer adipiscing elit.\n\n*   Another item in the same list.\n```\n\n如果要在列表项目内放进引用，那 > 就需要缩进：\n\n```md\n*   A list item with a blockquote:\n\n    > This is a blockquote\n    > inside a list item.\n```\n\n如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：\n\n```md\n*   一列表项包含一个列表区块：\n\n        <代码写在这>\n```\n\n当然，项目列表很可能会不小心产生，像是下面这样的写法\n\n```md\n1986. What a great season.\n```\n\n换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。\n\n```md\n1986\\. What a great season.\n```\n\n### 代码区块\n\n和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <pre> 和 <code> 标签来把代码区块包起来。\n\n要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：\n\n```md\n这是一个普通段落：\n\n    这是一个代码区块。\n```\n\nMarkdown 会转换成：\n\n```md\n<p>这是一个普通段落：</p>\n\n<pre><code>这是一个代码区块。\n</code></pre>\n```\n\n这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：\n\n```md\nHere is an example of AppleScript:\n\n    tell application \"Foo\"\n        beep\n    end tell\n```\n\n会被转换为：\n\n```md\n<p>Here is an example of AppleScript:</p>\n\n<pre><code>tell application \"Foo\"\n    beep\nend tell\n</code></pre>\n```\n\n一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\n\n在代码区块里面， & 、 < 和 > 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：\n\n```md\n<div class=\"footer\">\n  &copy; 2004 Foo Corporation\n</div>\n```\n\n会被转换为：\n\n```md\n<pre><code>&lt;div class=\"footer\"&gt;\n    &amp;copy; 2004 Foo Corporation\n&lt;/div&gt;\n</code></pre>\n```\n\n代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。\n\n### 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n```md\n* * *\n\n***\n\n*****\n\n- - -\n\n---------------------------------------\n```\n\n## 区段元素\n\n### 链接\n\nMarkdown 支持两种形式的链接语法： 行内式和参考式两种形式。\n\n不管是哪一种，链接文字都是用 [方括号] 来标记。\n\n要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：\n\n```md\nThis is [an example](http://example.com/ \"Title\") inline link.\n\n[This link](http://example.net/) has no title attribute.\n```\n\n会产生：\n\n```md\n<p>This is <a href=\"http://example.com/\" title=\"Title\">\nan example</a> inline link.</p>\n\n<p><a href=\"http://example.net/\">This link</a> has no\ntitle attribute.</p>\n```\n\n如果你是要链接到同样主机的资源，你可以使用相对路径：\n\n```md\nSee my [About](/about/) page for details.\n```\n\n参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：\n\n```md\nThis is [an example][id] reference-style link.\n```\n\n你也可以选择性地在两个方括号中间加上一个空格：\n\n```md\nThis is [an example] [id] reference-style link.\n```\n\n接着，在文件的任意处，你可以把这个标记的链接内容定义出来：\n\n```md\n[id]: http://example.com/  \"Optional Title Here\"\n```\n\n链接内容定义的形式为：\n\n- 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字\n- 接着一个冒号\n- 接着一个以上的空格或制表符\n- 接着链接的网址\n- 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着\n\n下面这三种链接的定义都是相同：\n\n```md\n[foo]: http://example.com/  \"Optional Title Here\"\n[foo]: http://example.com/  \'Optional Title Here\'\n[foo]: http://example.com/  (Optional Title Here)\n```\n\n**请注意：**有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。\n\n链接网址也可以用方括号包起来：\n\n```md\n[id]: \"Optional Title Here\"\n```\n\n你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：\n\n```md\n[id]: http://example.com/longish/path/to/resource/here\n    \"Optional Title Here\"\n```\n\n网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。\n\n链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的：\n\n```md\n[link text][a]\n[link text][A]\n```\n\n隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 \"Google\" 链接到 google.com，你可以简化成：\n\n```md\n[Google][]\n```\n\n然后定义链接内容：\n\n```md\n[Google]: http://google.com/\n```\n\n由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：\n\n```md\nVisit [Daring Fireball][] for more information.\n```\n\n然后接着定义链接\n\n```md\n[Daring Fireball]: http://daringfireball.net/\n```\n\n链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。\n\n下面是一个参考式链接的范例：\n\n```md\nI get 10 times more traffic from [Google] [1] than from\n[Yahoo] [2] or [MSN] [3].\n\n  [1]: http://google.com/        \"Google\"\n  [2]: http://search.yahoo.com/  \"Yahoo Search\"\n  [3]: http://search.msn.com/    \"MSN Search\"\n```\n\n如果改成用链接名称的方式写：\n\n```md\nI get 10 times more traffic from [Google][] than from\n[Yahoo][] or [MSN][].\n\n  [google]: http://google.com/        \"Google\"\n  [yahoo]:  http://search.yahoo.com/  \"Yahoo Search\"\n  [msn]:    http://search.msn.com/    \"MSN Search\"\n```\n\n上面两种写法都会产生下面的 HTML。\n\n```md\n<p>I get 10 times more traffic from <a href=\"http://google.com/\"\ntitle=\"Google\">Google</a> than from\n<a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\">Yahoo</a>\nor <a href=\"http://search.msn.com/\" title=\"MSN Search\">MSN</a>.</p>\n```\n\n下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：\n\n```md\nI get 10 times more traffic from [Google](http://google.com/ \"Google\")\nthan from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or\n[MSN](http://search.msn.com/ \"MSN Search\").\n```\n\n参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。\n\n使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。\n\n### 强调\n\nMarkdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 <em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 <strong>，例如：\n\n```md\n*single asterisks*\n\n_single underscores_\n\n**double asterisks**\n\n__double underscores__\n```\n\n会转成：\n\n```md\n<em>single asterisks</em>\n\n<em>single underscores</em>\n\n<strong>double asterisks</strong>\n\n<strong>double underscores</strong>\n```\n\n你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。\n\n强调也可以直接插在文字中间：\n\n```md\nun*frigging*believable\n```\n\n但是**如果你的 \\* 和 _ 两边都有空白的话，它们就只会被当成普通的符号。**\n\n如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：\n\n```md\n\\*this text is surrounded by literal asterisks\\*\n```\n\n### 代码\n\n如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：\n\n```md\nUse the `printf()` function.\n```\n\n会产生：\n\n```md\n<p>Use the <code>printf()</code> function.</p>\n```\n\n如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：\n\n```md\n``There is a literal backtick (`) here.``\n```\n\n这段语法会产生：\n\n```md\n<p><code>There is a literal backtick (`) here.</code></p>\n```\n\n代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：\n\n```md\nA single backtick in a code span: `` ` ``\n\nA backtick-delimited string in a code span: `` `foo` ``\n```\n\n会产生：\n\n```md\n<p>A single backtick in a code span: <code>`</code></p>\n\n<p>A backtick-delimited string in a code span: <code>`foo`</code></p>\n```\n\n在代码区段内，& 和方括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：\n\n```md\nPlease don\'t use any `<blink>` tags.\n```\n\n转为：\n\n```md\n<p>Please don\'t use any <code><blink></code> tags.</p>\n```\n\n你也可以这样写：\n\n```md\n`&#8212;` is the decimal-encoded equivalent of `&mdash;`.\n```\n\n以产生：\n\n```md\n<p><code>&amp;#8212;</code> is the decimal-encoded\nequivalent of <code>&amp;mdash;</code>.</p>\n```\n\n### 图片\n\n很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。\n\nMarkdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。\n\n行内式的图片语法看起来像是：\n\n```md\n![Alt text](/path/to/img.jpg)\n\n![Alt text](/path/to/img.jpg \"Optional title\")\n```\n\n详细叙述如下：\n\n- 一个惊叹号 !\n- 接着一个方括号，里面放上图片的替代文字\n- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 \'title\' 文字。\n\n参考式的图片语法则长得像这样：\n\n```md\n![Alt text][id]\n```\n\n「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：\n\n```md\n[id]: url/to/image  \"Optional title attribute\"\n```\n\n到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <img> 标签。\n\n## 其它\n\n### 反斜杠\n\nMarkdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <em> 标签），你可以在星号的前面加上反斜杠：\n\n```md\n\\*literal asterisks\\*\n```\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n```md\n\\   反斜线\n`   反引号\n*   星号\n_   底线\n{}  花括号\n[]  方括号\n()  括弧\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   惊叹号\n```\n\n### 自动链接\n\nMarkdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n\n```md\n<http://example.com/>\n```\n\nMarkdown 会转为：\n\n```md\n<a href=\"http://example.com/\">http://example.com/</a>\n```\n\n邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：\n\n```md\n<address@example.com>\n```\n\nMarkdown 会转成：\n\n```md\n<a href=\"mailto:addre\nss@example.co\nm\">address@exa\nmple.com</a>\n```\n\n在浏览器里面，这段字串（其实是 <a href=\"mailto:address@example.com\">address@example.com</a>）会变成一个可以点击的「address@example.com」链接。\n\n（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）', '556', '458', '2019-12-19');
INSERT INTO `articles` VALUES ('8', 'chenin', 'Android', 'Android 后台运行白名单设置，优雅实现进程保活', '# 保活现状\n\n我们知道，Android 系统会存在杀后台进程的情况，并且随着系统版本的更新，杀进程的力度还有越来越大的趋势。系统这种做法本身出发点是好的，因为可以节省内存，降低功耗，也避免了一些流氓行为。\n\n但有一部分应用，应用本身的使用场景就需要在后台运行，用户也是愿意让它在后台运行的，比如跑步类应用。一方面流氓软件用各种流氓手段进行保活，另一方面系统加大杀后台的力度，导致我们一些真正需要在后台运行的应用被误杀，苦不堪言。\n\n# 优雅保活？\n\n为了做到保活，出现了不少「黑科技」，比如 1 个像素的 Activity，播放无声音频，双进程互相守护等。这些做法可以说是很流氓了，甚至破坏了 Android 的生态，好在随着 Android 系统版本的更新，这些非常规的保活手段很多都已失效了。\n\n对于那些确实需要在后台运行的应用，我们如何做到优雅的保活呢？\n\n# 后台运行白名单\n\n从 Android 6.0 开始，系统为了省电增加了休眠模式，系统待机一段时间后，会杀死后台正在运行的进程。但系统会有一个后台运行白名单，白名单里的应用将不会受到影响，在原生系统下，通过「设置」 - 「电池」 - 「电池优化」 - 「未优化应用」，可以看到这个白名单，通常会看到下面这两位：\n\n下次被产品说「 XXX 都可以保活，为什么我们不行！」的时候，你就知道怎么怼回去了。大厂通过和手机厂商的合作，将自己的应用默认加入到白名单中。如果你在一个能谈成这种合作的大厂，也就不用往下看了。\n\n好在系统还没有抛弃我们，允许我们申请把应用加入白名单。\n\n首先，可以通过以下方法，判断我们的应用是否在白名单中：\n\n```\n@RequiresApi(api = Build.VERSION_CODES.M)\nprivate boolean isIgnoringBatteryOptimizations() {\n    boolean isIgnoring = false;\n    PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);\n    if (powerManager != null) {\n        isIgnoring = powerManager.isIgnoringBatteryOptimizations(getPackageName());\n    }\n    return isIgnoring;\n}\n复制代码\n```\n\n如果不在白名单中，可以通过以下代码申请加入白名单：\n\n```\n@RequiresApi(api = Build.VERSION_CODES.M)\npublic void requestIgnoreBatteryOptimizations() {\n    try {\n        Intent intent = new Intent(\"android.settings.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\");\n        intent.setData(Uri.parse(\"package:\" + getPackageName()));\n        startActivity(intent);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n复制代码\n```\n\n# 厂商后台管理\n\nAndroid 开发的一个难点在于，各大手机厂商对原生系统进行了不同的定制，导致我们需要进行不同的适配，后台管理就是一个很好的体现。几乎各个厂商都有自己的后台管理，就算应用加入了后台运行白名单，仍然可能会被厂商自己的后台管理干掉。\n\n如果能把应用加入厂商系统的后台管理白名单，可以进一步降低进程被杀的概率。不同的厂商在不同的地方进行设置，一般是在各自的「手机管家」，但更难的是，就算同一个厂商的系统，不同的版本也可能是在不同地方设置。\n\n最理想的做法是，我们根据不同手机，甚至是不同的系统版本，给用户呈现一个图文操作步骤，并且提供一个按钮，直接跳转到指定页面进行设置。但需要对每个厂商每个版本进行适配，工作量是比较大的。我使用真机测试了大部分主流 Android 厂商的手机后，整理出了部分手机的相关资料。\n\n首先我们可以定义这样两个方法：\n\n```\n/**\n * 跳转到指定应用的首页\n */\nprivate void showActivity(@NonNull String packageName) {\n    Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);\n    startActivity(intent);\n}\n\n/**\n * 跳转到指定应用的指定页面\n */\nprivate void showActivity(@NonNull String packageName, @NonNull String activityDir) {\n    Intent intent = new Intent();\n    intent.setComponent(new ComponentName(packageName, activityDir));\n    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    startActivity(intent);\n}\n复制代码\n```\n\n以下是部分手机的厂商判断，跳转方法及对应设置步骤，跳转方法不保证在所有版本上都能成功跳转，都需要加 try catch。\n\n## 华为\n\n厂商判断\n\n```\npublic boolean isHuawei() {\n    if (Build.BRAND == null) {\n        return false;\n    } else {\n        return Build.BRAND.toLowerCase().equals(\"huawei\") || Build.BRAND.toLowerCase().equals(\"honor\");\n    }\n}\n复制代码\n```\n\n跳转华为手机管家的启动管理页：\n\n```\nprivate void goHuaweiSetting() {\n    try {\n        showActivity(\"com.huawei.systemmanager\",\n            \"com.huawei.systemmanager.startupmgr.ui.StartupNormalAppListActivity\");\n    } catch (Exception e) {\n        showActivity(\"com.huawei.systemmanager\",\n            \"com.huawei.systemmanager.optimize.bootstart.BootStartActivity\");\n    }\n}\n复制代码\n```\n\n操作步骤：应用启动管理 -> 关闭应用开关 -> 打开允许自启动\n\n## 小米\n\n厂商判断\n\n```\npublic static boolean isXiaomi() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"xiaomi\");\n}\n复制代码\n```\n\n跳转小米安全中心的自启动管理页面：\n\n```\nprivate void goXiaomiSetting() {\n    showActivity(\"com.miui.securitycenter\",\n        \"com.miui.permcenter.autostart.AutoStartManagementActivity\");\n}\n复制代码\n```\n\n操作步骤：授权管理 -> 自启动管理 -> 允许应用自启动\n\n## OPPO\n\n厂商判断\n\n```\npublic static boolean isOPPO() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"oppo\");\n}\n复制代码\n```\n\n跳转 OPPO 手机管家：\n\n```\nprivate void goOPPOSetting() {\n    try {\n        showActivity(\"com.coloros.phonemanager\");\n    } catch (Exception e1) {\n        try {\n            showActivity(\"com.oppo.safe\");\n        } catch (Exception e2) {\n            try {\n                showActivity(\"com.coloros.oppoguardelf\");\n            } catch (Exception e3) {\n                showActivity(\"com.coloros.safecenter\");\n            }\n        }\n    }\n}\n复制代码\n```\n\n操作步骤：权限隐私 -> 自启动管理 -> 允许应用自启动\n\n## VIVO\n\n厂商判断\n\n```\npublic static boolean isVIVO() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"vivo\");\n}\n复制代码\n```\n\n跳转 VIVO 手机管家：\n\n```\nprivate void goVIVOSetting() {\n    showActivity(\"com.iqoo.secure\");\n}\n复制代码\n```\n\n操作步骤：权限管理 -> 自启动 -> 允许应用自启动\n\n## 魅族\n\n厂商判断\n\n```\npublic static boolean isMeizu() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"meizu\");\n}\n复制代码\n```\n\n跳转魅族手机管家：\n\n```\nprivate void goMeizuSetting() {\n    showActivity(\"com.meizu.safe\");\n}\n复制代码\n```\n\n操作步骤：权限管理 -> 后台管理 -> 点击应用 -> 允许后台运行\n\n## 三星\n\n厂商判断\n\n```\npublic static boolean isSamsung() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"samsung\");\n}\n复制代码\n```\n\n跳转三星智能管理器：\n\n```\nprivate void goSamsungSetting() {\n    try {\n        showActivity(\"com.samsung.android.sm_cn\");\n    } catch (Exception e) {\n        showActivity(\"com.samsung.android.sm\");\n    }\n}\n复制代码\n```\n\n操作步骤：自动运行应用程序 -> 打开应用开关 -> 电池管理 -> 未监视的应用程序 -> 添加应用\n\n## 乐视\n\n厂商判断\n\n```\npublic static boolean isLeTV() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"letv\");\n}\n复制代码\n```\n\n跳转乐视手机管家：\n\n```\nprivate void goLetvSetting() {\n    showActivity(\"com.letv.android.letvsafe\", \n        \"com.letv.android.letvsafe.AutobootManageActivity\");\n}\n复制代码\n```\n\n操作步骤：自启动管理 -> 允许应用自启动\n\n## 锤子\n\n厂商判断\n\n```\n    public static boolean isSmartisan() {\n        return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"smartisan\");\n    }\n复制代码\n```\n\n跳转手机管理：\n\n```\nprivate void goSmartisanSetting() {\n    showActivity(\"com.smartisanos.security\");\n}\n复制代码\n```\n\n操作步骤：权限管理 -> 自启动权限管理 -> 点击应用 -> 允许被系统启动\n\n', '612', '456', '2019-12-19');
INSERT INTO `articles` VALUES ('9', 'chenin', 'Android', 'Android', '# 保活现状\n\n我们知道，Android 系统会存在杀后台进程的情况，并且随着系统版本的更新，杀进程的力度还有越来越大的趋势。系统这种做法本身出发点是好的，因为可以节省内存，降低功耗，也避免了一些流氓行为。\n\n但有一部分应用，应用本身的使用场景就需要在后台运行，用户也是愿意让它在后台运行的，比如跑步类应用。一方面流氓软件用各种流氓手段进行保活，另一方面系统加大杀后台的力度，导致我们一些真正需要在后台运行的应用被误杀，苦不堪言。\n\n# 优雅保活？\n\n为了做到保活，出现了不少「黑科技」，比如 1 个像素的 Activity，播放无声音频，双进程互相守护等。这些做法可以说是很流氓了，甚至破坏了 Android 的生态，好在随着 Android 系统版本的更新，这些非常规的保活手段很多都已失效了。\n\n对于那些确实需要在后台运行的应用，我们如何做到优雅的保活呢？\n\n# 后台运行白名单\n\n从 Android 6.0 开始，系统为了省电增加了休眠模式，系统待机一段时间后，会杀死后台正在运行的进程。但系统会有一个后台运行白名单，白名单里的应用将不会受到影响，在原生系统下，通过「设置」 - 「电池」 - 「电池优化」 - 「未优化应用」，可以看到这个白名单，通常会看到下面这两位：\n\n下次被产品说「 XXX 都可以保活，为什么我们不行！」的时候，你就知道怎么怼回去了。大厂通过和手机厂商的合作，将自己的应用默认加入到白名单中。如果你在一个能谈成这种合作的大厂，也就不用往下看了。\n\n好在系统还没有抛弃我们，允许我们申请把应用加入白名单。\n\n首先，可以通过以下方法，判断我们的应用是否在白名单中：\n\n```\n@RequiresApi(api = Build.VERSION_CODES.M)\nprivate boolean isIgnoringBatteryOptimizations() {\n    boolean isIgnoring = false;\n    PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);\n    if (powerManager != null) {\n        isIgnoring = powerManager.isIgnoringBatteryOptimizations(getPackageName());\n    }\n    return isIgnoring;\n}\n复制代码\n```\n\n如果不在白名单中，可以通过以下代码申请加入白名单：\n\n```\n@RequiresApi(api = Build.VERSION_CODES.M)\npublic void requestIgnoreBatteryOptimizations() {\n    try {\n        Intent intent = new Intent(\"android.settings.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\");\n        intent.setData(Uri.parse(\"package:\" + getPackageName()));\n        startActivity(intent);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n复制代码\n```\n\n# 厂商后台管理\n\nAndroid 开发的一个难点在于，各大手机厂商对原生系统进行了不同的定制，导致我们需要进行不同的适配，后台管理就是一个很好的体现。几乎各个厂商都有自己的后台管理，就算应用加入了后台运行白名单，仍然可能会被厂商自己的后台管理干掉。\n\n如果能把应用加入厂商系统的后台管理白名单，可以进一步降低进程被杀的概率。不同的厂商在不同的地方进行设置，一般是在各自的「手机管家」，但更难的是，就算同一个厂商的系统，不同的版本也可能是在不同地方设置。\n\n最理想的做法是，我们根据不同手机，甚至是不同的系统版本，给用户呈现一个图文操作步骤，并且提供一个按钮，直接跳转到指定页面进行设置。但需要对每个厂商每个版本进行适配，工作量是比较大的。我使用真机测试了大部分主流 Android 厂商的手机后，整理出了部分手机的相关资料。\n\n首先我们可以定义这样两个方法：\n\n```\n/**\n * 跳转到指定应用的首页\n */\nprivate void showActivity(@NonNull String packageName) {\n    Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);\n    startActivity(intent);\n}\n\n/**\n * 跳转到指定应用的指定页面\n */\nprivate void showActivity(@NonNull String packageName, @NonNull String activityDir) {\n    Intent intent = new Intent();\n    intent.setComponent(new ComponentName(packageName, activityDir));\n    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    startActivity(intent);\n}\n复制代码\n```\n\n以下是部分手机的厂商判断，跳转方法及对应设置步骤，跳转方法不保证在所有版本上都能成功跳转，都需要加 try catch。\n\n## 华为\n\n厂商判断\n\n```\npublic boolean isHuawei() {\n    if (Build.BRAND == null) {\n        return false;\n    } else {\n        return Build.BRAND.toLowerCase().equals(\"huawei\") || Build.BRAND.toLowerCase().equals(\"honor\");\n    }\n}\n复制代码\n```\n\n跳转华为手机管家的启动管理页：\n\n```\nprivate void goHuaweiSetting() {\n    try {\n        showActivity(\"com.huawei.systemmanager\",\n            \"com.huawei.systemmanager.startupmgr.ui.StartupNormalAppListActivity\");\n    } catch (Exception e) {\n        showActivity(\"com.huawei.systemmanager\",\n            \"com.huawei.systemmanager.optimize.bootstart.BootStartActivity\");\n    }\n}\n复制代码\n```\n\n操作步骤：应用启动管理 -> 关闭应用开关 -> 打开允许自启动\n\n## 小米\n\n厂商判断\n\n```\npublic static boolean isXiaomi() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"xiaomi\");\n}\n复制代码\n```\n\n跳转小米安全中心的自启动管理页面：\n\n```\nprivate void goXiaomiSetting() {\n    showActivity(\"com.miui.securitycenter\",\n        \"com.miui.permcenter.autostart.AutoStartManagementActivity\");\n}\n复制代码\n```\n\n操作步骤：授权管理 -> 自启动管理 -> 允许应用自启动\n\n## OPPO\n\n厂商判断\n\n```\npublic static boolean isOPPO() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"oppo\");\n}\n复制代码\n```\n\n跳转 OPPO 手机管家：\n\n```\nprivate void goOPPOSetting() {\n    try {\n        showActivity(\"com.coloros.phonemanager\");\n    } catch (Exception e1) {\n        try {\n            showActivity(\"com.oppo.safe\");\n        } catch (Exception e2) {\n            try {\n                showActivity(\"com.coloros.oppoguardelf\");\n            } catch (Exception e3) {\n                showActivity(\"com.coloros.safecenter\");\n            }\n        }\n    }\n}\n复制代码\n```\n\n操作步骤：权限隐私 -> 自启动管理 -> 允许应用自启动\n\n## VIVO\n\n厂商判断\n\n```\npublic static boolean isVIVO() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"vivo\");\n}\n复制代码\n```\n\n跳转 VIVO 手机管家：\n\n```\nprivate void goVIVOSetting() {\n    showActivity(\"com.iqoo.secure\");\n}\n复制代码\n```\n\n操作步骤：权限管理 -> 自启动 -> 允许应用自启动\n\n## 魅族\n\n厂商判断\n\n```\npublic static boolean isMeizu() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"meizu\");\n}\n复制代码\n```\n\n跳转魅族手机管家：\n\n```\nprivate void goMeizuSetting() {\n    showActivity(\"com.meizu.safe\");\n}\n复制代码\n```\n\n操作步骤：权限管理 -> 后台管理 -> 点击应用 -> 允许后台运行\n\n## 三星\n\n厂商判断\n\n```\npublic static boolean isSamsung() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"samsung\");\n}\n复制代码\n```\n\n跳转三星智能管理器：\n\n```\nprivate void goSamsungSetting() {\n    try {\n        showActivity(\"com.samsung.android.sm_cn\");\n    } catch (Exception e) {\n        showActivity(\"com.samsung.android.sm\");\n    }\n}\n复制代码\n```\n\n操作步骤：自动运行应用程序 -> 打开应用开关 -> 电池管理 -> 未监视的应用程序 -> 添加应用\n\n## 乐视\n\n厂商判断\n\n```\npublic static boolean isLeTV() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"letv\");\n}\n复制代码\n```\n\n跳转乐视手机管家：\n\n```\nprivate void goLetvSetting() {\n    showActivity(\"com.letv.android.letvsafe\", \n        \"com.letv.android.letvsafe.AutobootManageActivity\");\n}\n复制代码\n```\n\n操作步骤：自启动管理 -> 允许应用自启动\n\n## 锤子\n\n厂商判断\n\n```\n    public static boolean isSmartisan() {\n        return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"smartisan\");\n    }\n复制代码\n```\n\n跳转手机管理：\n\n```\nprivate void goSmartisanSetting() {\n    showActivity(\"com.smartisanos.security\");\n}\n复制代码\n```\n\n操作步骤：权限管理 -> 自启动权限管理 -> 点击应用 -> 允许被系统启动\n\n', '4123', '455', '2019-12-19');
INSERT INTO `articles` VALUES ('10', 'chenin', 'Android', '关于Android学习', '# 保活现状\n\n我们知道，Android 系统会存在杀后台进程的情况，并且随着系统版本的更新，杀进程的力度还有越来越大的趋势。系统这种做法本身出发点是好的，因为可以节省内存，降低功耗，也避免了一些流氓行为。\n\n但有一部分应用，应用本身的使用场景就需要在后台运行，用户也是愿意让它在后台运行的，比如跑步类应用。一方面流氓软件用各种流氓手段进行保活，另一方面系统加大杀后台的力度，导致我们一些真正需要在后台运行的应用被误杀，苦不堪言。\n\n# 优雅保活？\n\n为了做到保活，出现了不少「黑科技」，比如 1 个像素的 Activity，播放无声音频，双进程互相守护等。这些做法可以说是很流氓了，甚至破坏了 Android 的生态，好在随着 Android 系统版本的更新，这些非常规的保活手段很多都已失效了。\n\n对于那些确实需要在后台运行的应用，我们如何做到优雅的保活呢？\n\n# 后台运行白名单\n\n从 Android 6.0 开始，系统为了省电增加了休眠模式，系统待机一段时间后，会杀死后台正在运行的进程。但系统会有一个后台运行白名单，白名单里的应用将不会受到影响，在原生系统下，通过「设置」 - 「电池」 - 「电池优化」 - 「未优化应用」，可以看到这个白名单，通常会看到下面这两位：\n\n下次被产品说「 XXX 都可以保活，为什么我们不行！」的时候，你就知道怎么怼回去了。大厂通过和手机厂商的合作，将自己的应用默认加入到白名单中。如果你在一个能谈成这种合作的大厂，也就不用往下看了。\n\n好在系统还没有抛弃我们，允许我们申请把应用加入白名单。\n\n首先，可以通过以下方法，判断我们的应用是否在白名单中：\n\n```\n@RequiresApi(api = Build.VERSION_CODES.M)\nprivate boolean isIgnoringBatteryOptimizations() {\n    boolean isIgnoring = false;\n    PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);\n    if (powerManager != null) {\n        isIgnoring = powerManager.isIgnoringBatteryOptimizations(getPackageName());\n    }\n    return isIgnoring;\n}\n复制代码\n```\n\n如果不在白名单中，可以通过以下代码申请加入白名单：\n\n```\n@RequiresApi(api = Build.VERSION_CODES.M)\npublic void requestIgnoreBatteryOptimizations() {\n    try {\n        Intent intent = new Intent(\"android.settings.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\");\n        intent.setData(Uri.parse(\"package:\" + getPackageName()));\n        startActivity(intent);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n复制代码\n```\n\n# 厂商后台管理\n\nAndroid 开发的一个难点在于，各大手机厂商对原生系统进行了不同的定制，导致我们需要进行不同的适配，后台管理就是一个很好的体现。几乎各个厂商都有自己的后台管理，就算应用加入了后台运行白名单，仍然可能会被厂商自己的后台管理干掉。\n\n如果能把应用加入厂商系统的后台管理白名单，可以进一步降低进程被杀的概率。不同的厂商在不同的地方进行设置，一般是在各自的「手机管家」，但更难的是，就算同一个厂商的系统，不同的版本也可能是在不同地方设置。\n\n最理想的做法是，我们根据不同手机，甚至是不同的系统版本，给用户呈现一个图文操作步骤，并且提供一个按钮，直接跳转到指定页面进行设置。但需要对每个厂商每个版本进行适配，工作量是比较大的。我使用真机测试了大部分主流 Android 厂商的手机后，整理出了部分手机的相关资料。\n\n首先我们可以定义这样两个方法：\n\n```\n/**\n * 跳转到指定应用的首页\n */\nprivate void showActivity(@NonNull String packageName) {\n    Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);\n    startActivity(intent);\n}\n\n/**\n * 跳转到指定应用的指定页面\n */\nprivate void showActivity(@NonNull String packageName, @NonNull String activityDir) {\n    Intent intent = new Intent();\n    intent.setComponent(new ComponentName(packageName, activityDir));\n    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    startActivity(intent);\n}\n复制代码\n```\n\n以下是部分手机的厂商判断，跳转方法及对应设置步骤，跳转方法不保证在所有版本上都能成功跳转，都需要加 try catch。\n\n## 华为\n\n厂商判断\n\n```\npublic boolean isHuawei() {\n    if (Build.BRAND == null) {\n        return false;\n    } else {\n        return Build.BRAND.toLowerCase().equals(\"huawei\") || Build.BRAND.toLowerCase().equals(\"honor\");\n    }\n}\n复制代码\n```\n\n跳转华为手机管家的启动管理页：\n\n```\nprivate void goHuaweiSetting() {\n    try {\n        showActivity(\"com.huawei.systemmanager\",\n            \"com.huawei.systemmanager.startupmgr.ui.StartupNormalAppListActivity\");\n    } catch (Exception e) {\n        showActivity(\"com.huawei.systemmanager\",\n            \"com.huawei.systemmanager.optimize.bootstart.BootStartActivity\");\n    }\n}\n复制代码\n```\n\n操作步骤：应用启动管理 -> 关闭应用开关 -> 打开允许自启动\n\n## 小米\n\n厂商判断\n\n```\npublic static boolean isXiaomi() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"xiaomi\");\n}\n复制代码\n```\n\n跳转小米安全中心的自启动管理页面：\n\n```\nprivate void goXiaomiSetting() {\n    showActivity(\"com.miui.securitycenter\",\n        \"com.miui.permcenter.autostart.AutoStartManagementActivity\");\n}\n复制代码\n```\n\n操作步骤：授权管理 -> 自启动管理 -> 允许应用自启动\n\n## OPPO\n\n厂商判断\n\n```\npublic static boolean isOPPO() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"oppo\");\n}\n复制代码\n```\n\n跳转 OPPO 手机管家：\n\n```\nprivate void goOPPOSetting() {\n    try {\n        showActivity(\"com.coloros.phonemanager\");\n    } catch (Exception e1) {\n        try {\n            showActivity(\"com.oppo.safe\");\n        } catch (Exception e2) {\n            try {\n                showActivity(\"com.coloros.oppoguardelf\");\n            } catch (Exception e3) {\n                showActivity(\"com.coloros.safecenter\");\n            }\n        }\n    }\n}\n复制代码\n```\n\n操作步骤：权限隐私 -> 自启动管理 -> 允许应用自启动\n\n## VIVO\n\n厂商判断\n\n```\npublic static boolean isVIVO() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"vivo\");\n}\n复制代码\n```\n\n跳转 VIVO 手机管家：\n\n```\nprivate void goVIVOSetting() {\n    showActivity(\"com.iqoo.secure\");\n}\n复制代码\n```\n\n操作步骤：权限管理 -> 自启动 -> 允许应用自启动\n\n## 魅族\n\n厂商判断\n\n```\npublic static boolean isMeizu() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"meizu\");\n}\n复制代码\n```\n\n跳转魅族手机管家：\n\n```\nprivate void goMeizuSetting() {\n    showActivity(\"com.meizu.safe\");\n}\n复制代码\n```\n\n操作步骤：权限管理 -> 后台管理 -> 点击应用 -> 允许后台运行\n\n## 三星\n\n厂商判断\n\n```\npublic static boolean isSamsung() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"samsung\");\n}\n复制代码\n```\n\n跳转三星智能管理器：\n\n```\nprivate void goSamsungSetting() {\n    try {\n        showActivity(\"com.samsung.android.sm_cn\");\n    } catch (Exception e) {\n        showActivity(\"com.samsung.android.sm\");\n    }\n}\n复制代码\n```\n\n操作步骤：自动运行应用程序 -> 打开应用开关 -> 电池管理 -> 未监视的应用程序 -> 添加应用\n\n## 乐视\n\n厂商判断\n\n```\npublic static boolean isLeTV() {\n    return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"letv\");\n}\n复制代码\n```\n\n跳转乐视手机管家：\n\n```\nprivate void goLetvSetting() {\n    showActivity(\"com.letv.android.letvsafe\", \n        \"com.letv.android.letvsafe.AutobootManageActivity\");\n}\n复制代码\n```\n\n操作步骤：自启动管理 -> 允许应用自启动\n\n## 锤子\n\n厂商判断\n\n```\n    public static boolean isSmartisan() {\n        return Build.BRAND != null && Build.BRAND.toLowerCase().equals(\"smartisan\");\n    }\n复制代码\n```\n\n跳转手机管理：\n\n```\nprivate void goSmartisanSetting() {\n    showActivity(\"com.smartisanos.security\");\n}\n复制代码\n```\n\n操作步骤：权限管理 -> 自启动权限管理 -> 点击应用 -> 允许被系统启动\n\n', '456', '45', '2019-12-19');
INSERT INTO `articles` VALUES ('11', 'chenin', '后端', '《程序人生》2020无畏年少青春，迎风潇洒前行 | 年度征文', '面试是一个很奇怪的过程，都是拧螺丝的。但是问的都是如何造火箭，一个敢问，一个敢答。\n\n面试不可怕，可怕的是你get不到面试官的点。\n\n更可怕的是，你觉得你知道答案，但不是面试官想要的。\n\n最可怕的是，面试官也不知道这题的答案是什么。\n\n# 送分题?送命题?\n\n前段时间有个小伙伴在一个群里分享了一道亲身经历的面试题，这题乍一看好像张口就能答，但是仔细一想，面试官是想要这样的回答吗?具体可以看截图。\n\n> 无畏年少青春，迎风潇洒前行\n>\n> 点赞再看，养成习惯\n>\n> 本文 **GitHub** [github.com/JavaFamily](https://github.com/AobingJava/JavaFamily) 已收录，有一线大厂面试点思维导图，也整理了很多我的文档，欢迎Star和完善，大家面试可以参照考点复习，希望我们一起有点东西。\n\n## 前言\n\n人生是一个漫长的过程，我们怀有太多的期望，就难免会遭遇失望与挫折。\n\n把理想束之高阁，回过头来却发现我们像是一条鱼，一直以为自己有翅膀便是飞鸟，却终于知道自己飞不了。\n\n**生活如水，时而浑浊，时而清澈**，我们在社会这个大缸中挣扎——“我常常觉得生活亏待了我，别人为什么总比自己幸福和快乐呢？”。\n\n面对挫折，我们抱怨生活欺骗了我们，我们以为自己的人生已经没有希望。\n\n我们经常把自己比喻为迷失的天鹅，却忘记了自己要怎样去飞翔。\n\n这期是我自己2019的小总结，2019感恩遇见，2019感谢遇见。\n\n写这篇文章的时候本来是没什么的思路的，但是我划着2019年自己的朋友圈，突然就知道了怎么写了，我把自己的盆友圈，按照时间线写出来那不就是我过去一年发生的大事了不是嘛？\n\n昂创作鬼才，就是我，我就是你们的丙丙。\n\n**Tip**：文章中的不好情绪希望不要影响到您，这个文章估计得不到收获，但是可以图个乐呵，阅读会比较顺畅。\n\n## 正文\n\n### 一年技术变化 \n\n这一年技术的广度变化很大，接触了很多不同的技术栈，跟之前实习公司的技术栈截然不同，深度也在慢慢深入，特别是进入蘑菇之后，公司全是自研的，让我看到了优良中间件的特性，基于RocketMQ和Kafka有点研发的消息中间件可还行。\n\n从阿里学姐那得知终面我的老大居然是RocketMQ的开山鼻祖之一，身边卧虎藏龙的优秀仔太多了，得好好学习。\n\n现在负责公司的广告投放系统，希望把它做大做强！！！\n\n自己写文章也在不断给自己扫盲，回顾知识点细节，其实还算是个好事情。\n\n### 现状 \n\n11.12号创建的git，现在star已经3.6k了，也在一个月内上了五次Trending，刚满月的他，以后承蒙大家多多关照了，希望以后能成为大家**面试突击扫盲还有学习新知识点**的地方，我们一起养肥他。\n\n### 我写了哪些系列？ \n\n《吊打面试官》系列：\n\n- 我之所以会选择面试题材，是因为这次跳槽我几乎面了所有杭州叫得上名字的公司了，效果都挺不错的，其实我的技术一般性，但是我骚嘛，所以我表达会好很多，面试官的感觉都不错，那我就在想为啥不把自己知道的面试点，用自己的话语表达出来呢？\n\n  于是就有了这个系列，但是我这个人**为了博眼球就取了这个名字**，所以后面很多人就喷我，诺现在文章的前言我都加了下面这句话，希望大家下次喷我换个支点喷我。\n\n> 所有文章的名字只是我的噱头，我们应该有一颗谦逊的心，所以希望大家怀着空杯心态好好学，一起进步。\n\n《程序人生》系列:\n\n- 这个系列主要是分享自己和身边小伙伴的个人经历，经验等等。\n\n  因为我身边的励志的例子太多太多了，我就很想出这样的一个专题去写出来给大家看，比如我专科的亦师亦友的朋友，这两天拿了阿里技术专家的offer，我专科的昊哥做字节的Leader，还有渣本的腾讯吴，渣本的Google杰等等等….\n\n  这个专题就当是鸡汤吧大家，能影响一个人是一个人吧，还是那句话我发现读者很多还是学生，或者是刚出社会的盆友，能让大家少走点弯路也是好的，而且很多多年经验的学长也说还是有些许收获的。\n\n  还是那句话，很多人就喷我这样都是少数啊什么什么的，但是在我身边就是很多。\n\n  **对于学生，我们说的每句话可能都是他们对社会的认知，大家喷的时候私聊我就好了，别破了别人的梦，自己不努力，也别拉别人下水。**\n\n《吐血整理》系列：\n\n- 写这个的系列的初衷就是想把大家常用的工具，书单等整理出来，把好的东西安利给大家，也希望从大家那等到一些好东西，后续还会写大家希望我整理的东西的。\n\n  **一样的还是我整理个书单也有人喷，还是那句话，不爱看不看就好了，私聊我喷，总有需要的人。**\n\n《大厂面试》系列：\n\n- 筹备中，形式应该先写一部分身边小伙伴大厂的面试经历和面试题讲解，后续只能靠投稿了。\n\n《有生之年》系列：\n\n- 突然想到的一个系列，只是突然想到这个名字哈哈。\n\n### 回馈 \n\n每个月恰饭的钱不多，但是也是大家赏脸的结果，我就拿一部分出来回馈大家，我喜欢书籍，所以我也决定了每个月都会送一些书给大家，书可能也不会太贵，但是是我的一份心意。\n\n### 2020期许 \n\n没啥期许，希望明年这个时候我还没放弃写作，家里一切ok，最好能找个女仔哈哈。\n\n做个俗人，贪财好色。\n\n### 总结 \n\n过去的一年，总的来说是美好的一年，我也知道新的一年是更加美好的一年，大家是不是发现我没你们想象的那么风光，以为我的工资肯定过的很潇洒，相反我也偶尔要借钱生活，不过明年肯定不会了，毕竟家里的好起来了。\n\n你看，我这不是就帮家里换了那个村里唯一的大头电视，买了家里的第一个冰箱，这不就好起来了嘛。\n', '123', '99', '2019-12-19');
INSERT INTO `articles` VALUES ('12', 'chenin', '后端', 'Java', '面试是一个很奇怪的过程，都是拧螺丝的。但是问的都是如何造火箭，一个敢问，一个敢答。\n\n面试不可怕，可怕的是你get不到面试官的点。\n\n更可怕的是，你觉得你知道答案，但不是面试官想要的。\n\n最可怕的是，面试官也不知道这题的答案是什么。\n\n# 送分题?送命题?\n\n前段时间有个小伙伴在一个群里分享了一道亲身经历的面试题，这题乍一看好像张口就能答，但是仔细一想，面试官是想要这样的回答吗?具体可以看截图。\n\n> 无畏年少青春，迎风潇洒前行\n>\n> 点赞再看，养成习惯\n>\n> 本文 **GitHub** [github.com/JavaFamily](https://github.com/AobingJava/JavaFamily) 已收录，有一线大厂面试点思维导图，也整理了很多我的文档，欢迎Star和完善，大家面试可以参照考点复习，希望我们一起有点东西。\n\n## 前言\n\n人生是一个漫长的过程，我们怀有太多的期望，就难免会遭遇失望与挫折。\n\n把理想束之高阁，回过头来却发现我们像是一条鱼，一直以为自己有翅膀便是飞鸟，却终于知道自己飞不了。\n\n**生活如水，时而浑浊，时而清澈**，我们在社会这个大缸中挣扎——“我常常觉得生活亏待了我，别人为什么总比自己幸福和快乐呢？”。\n\n面对挫折，我们抱怨生活欺骗了我们，我们以为自己的人生已经没有希望。\n\n我们经常把自己比喻为迷失的天鹅，却忘记了自己要怎样去飞翔。\n\n这期是我自己2019的小总结，2019感恩遇见，2019感谢遇见。\n\n写这篇文章的时候本来是没什么的思路的，但是我划着2019年自己的朋友圈，突然就知道了怎么写了，我把自己的盆友圈，按照时间线写出来那不就是我过去一年发生的大事了不是嘛？\n\n昂创作鬼才，就是我，我就是你们的丙丙。\n\n**Tip**：文章中的不好情绪希望不要影响到您，这个文章估计得不到收获，但是可以图个乐呵，阅读会比较顺畅。\n\n## 正文\n\n### 一年技术变化 \n\n这一年技术的广度变化很大，接触了很多不同的技术栈，跟之前实习公司的技术栈截然不同，深度也在慢慢深入，特别是进入蘑菇之后，公司全是自研的，让我看到了优良中间件的特性，基于RocketMQ和Kafka有点研发的消息中间件可还行。\n\n从阿里学姐那得知终面我的老大居然是RocketMQ的开山鼻祖之一，身边卧虎藏龙的优秀仔太多了，得好好学习。\n\n现在负责公司的广告投放系统，希望把它做大做强！！！\n\n自己写文章也在不断给自己扫盲，回顾知识点细节，其实还算是个好事情。\n\n### 现状 \n\n11.12号创建的git，现在star已经3.6k了，也在一个月内上了五次Trending，刚满月的他，以后承蒙大家多多关照了，希望以后能成为大家**面试突击扫盲还有学习新知识点**的地方，我们一起养肥他。\n\n### 我写了哪些系列？ \n\n《吊打面试官》系列：\n\n- 我之所以会选择面试题材，是因为这次跳槽我几乎面了所有杭州叫得上名字的公司了，效果都挺不错的，其实我的技术一般性，但是我骚嘛，所以我表达会好很多，面试官的感觉都不错，那我就在想为啥不把自己知道的面试点，用自己的话语表达出来呢？\n\n  于是就有了这个系列，但是我这个人**为了博眼球就取了这个名字**，所以后面很多人就喷我，诺现在文章的前言我都加了下面这句话，希望大家下次喷我换个支点喷我。\n\n> 所有文章的名字只是我的噱头，我们应该有一颗谦逊的心，所以希望大家怀着空杯心态好好学，一起进步。\n\n《程序人生》系列:\n\n- 这个系列主要是分享自己和身边小伙伴的个人经历，经验等等。\n\n  因为我身边的励志的例子太多太多了，我就很想出这样的一个专题去写出来给大家看，比如我专科的亦师亦友的朋友，这两天拿了阿里技术专家的offer，我专科的昊哥做字节的Leader，还有渣本的腾讯吴，渣本的Google杰等等等….\n\n  这个专题就当是鸡汤吧大家，能影响一个人是一个人吧，还是那句话我发现读者很多还是学生，或者是刚出社会的盆友，能让大家少走点弯路也是好的，而且很多多年经验的学长也说还是有些许收获的。\n\n  还是那句话，很多人就喷我这样都是少数啊什么什么的，但是在我身边就是很多。\n\n  **对于学生，我们说的每句话可能都是他们对社会的认知，大家喷的时候私聊我就好了，别破了别人的梦，自己不努力，也别拉别人下水。**\n\n《吐血整理》系列：\n\n- 写这个的系列的初衷就是想把大家常用的工具，书单等整理出来，把好的东西安利给大家，也希望从大家那等到一些好东西，后续还会写大家希望我整理的东西的。\n\n  **一样的还是我整理个书单也有人喷，还是那句话，不爱看不看就好了，私聊我喷，总有需要的人。**\n\n《大厂面试》系列：\n\n- 筹备中，形式应该先写一部分身边小伙伴大厂的面试经历和面试题讲解，后续只能靠投稿了。\n\n《有生之年》系列：\n\n- 突然想到的一个系列，只是突然想到这个名字哈哈。\n\n### 回馈 \n\n每个月恰饭的钱不多，但是也是大家赏脸的结果，我就拿一部分出来回馈大家，我喜欢书籍，所以我也决定了每个月都会送一些书给大家，书可能也不会太贵，但是是我的一份心意。\n\n### 2020期许 \n\n没啥期许，希望明年这个时候我还没放弃写作，家里一切ok，最好能找个女仔哈哈。\n\n做个俗人，贪财好色。\n\n### 总结 \n\n过去的一年，总的来说是美好的一年，我也知道新的一年是更加美好的一年，大家是不是发现我没你们想象的那么风光，以为我的工资肯定过的很潇洒，相反我也偶尔要借钱生活，不过明年肯定不会了，毕竟家里的好起来了。\n\n你看，我这不是就帮家里换了那个村里唯一的大头电视，买了家里的第一个冰箱，这不就好起来了嘛。\n', '8', '85', '2019-12-19');
INSERT INTO `articles` VALUES ('13', 'chenin', '后端', 'python', '面试是一个很奇怪的过程，都是拧螺丝的。但是问的都是如何造火箭，一个敢问，一个敢答。\n\n面试不可怕，可怕的是你get不到面试官的点。\n\n更可怕的是，你觉得你知道答案，但不是面试官想要的。\n\n最可怕的是，面试官也不知道这题的答案是什么。\n\n# 送分题?送命题?\n\n前段时间有个小伙伴在一个群里分享了一道亲身经历的面试题，这题乍一看好像张口就能答，但是仔细一想，面试官是想要这样的回答吗?具体可以看截图。\n\n> 无畏年少青春，迎风潇洒前行\n>\n> 点赞再看，养成习惯\n>\n> 本文 **GitHub** [github.com/JavaFamily](https://github.com/AobingJava/JavaFamily) 已收录，有一线大厂面试点思维导图，也整理了很多我的文档，欢迎Star和完善，大家面试可以参照考点复习，希望我们一起有点东西。\n\n## 前言\n\n人生是一个漫长的过程，我们怀有太多的期望，就难免会遭遇失望与挫折。\n\n把理想束之高阁，回过头来却发现我们像是一条鱼，一直以为自己有翅膀便是飞鸟，却终于知道自己飞不了。\n\n**生活如水，时而浑浊，时而清澈**，我们在社会这个大缸中挣扎——“我常常觉得生活亏待了我，别人为什么总比自己幸福和快乐呢？”。\n\n面对挫折，我们抱怨生活欺骗了我们，我们以为自己的人生已经没有希望。\n\n我们经常把自己比喻为迷失的天鹅，却忘记了自己要怎样去飞翔。\n\n这期是我自己2019的小总结，2019感恩遇见，2019感谢遇见。\n\n写这篇文章的时候本来是没什么的思路的，但是我划着2019年自己的朋友圈，突然就知道了怎么写了，我把自己的盆友圈，按照时间线写出来那不就是我过去一年发生的大事了不是嘛？\n\n昂创作鬼才，就是我，我就是你们的丙丙。\n\n**Tip**：文章中的不好情绪希望不要影响到您，这个文章估计得不到收获，但是可以图个乐呵，阅读会比较顺畅。\n\n## 正文\n\n### 一年技术变化 \n\n这一年技术的广度变化很大，接触了很多不同的技术栈，跟之前实习公司的技术栈截然不同，深度也在慢慢深入，特别是进入蘑菇之后，公司全是自研的，让我看到了优良中间件的特性，基于RocketMQ和Kafka有点研发的消息中间件可还行。\n\n从阿里学姐那得知终面我的老大居然是RocketMQ的开山鼻祖之一，身边卧虎藏龙的优秀仔太多了，得好好学习。\n\n现在负责公司的广告投放系统，希望把它做大做强！！！\n\n自己写文章也在不断给自己扫盲，回顾知识点细节，其实还算是个好事情。\n\n### 现状 \n\n11.12号创建的git，现在star已经3.6k了，也在一个月内上了五次Trending，刚满月的他，以后承蒙大家多多关照了，希望以后能成为大家**面试突击扫盲还有学习新知识点**的地方，我们一起养肥他。\n\n### 我写了哪些系列？ \n\n《吊打面试官》系列：\n\n- 我之所以会选择面试题材，是因为这次跳槽我几乎面了所有杭州叫得上名字的公司了，效果都挺不错的，其实我的技术一般性，但是我骚嘛，所以我表达会好很多，面试官的感觉都不错，那我就在想为啥不把自己知道的面试点，用自己的话语表达出来呢？\n\n  于是就有了这个系列，但是我这个人**为了博眼球就取了这个名字**，所以后面很多人就喷我，诺现在文章的前言我都加了下面这句话，希望大家下次喷我换个支点喷我。\n\n> 所有文章的名字只是我的噱头，我们应该有一颗谦逊的心，所以希望大家怀着空杯心态好好学，一起进步。\n\n《程序人生》系列:\n\n- 这个系列主要是分享自己和身边小伙伴的个人经历，经验等等。\n\n  因为我身边的励志的例子太多太多了，我就很想出这样的一个专题去写出来给大家看，比如我专科的亦师亦友的朋友，这两天拿了阿里技术专家的offer，我专科的昊哥做字节的Leader，还有渣本的腾讯吴，渣本的Google杰等等等….\n\n  这个专题就当是鸡汤吧大家，能影响一个人是一个人吧，还是那句话我发现读者很多还是学生，或者是刚出社会的盆友，能让大家少走点弯路也是好的，而且很多多年经验的学长也说还是有些许收获的。\n\n  还是那句话，很多人就喷我这样都是少数啊什么什么的，但是在我身边就是很多。\n\n  **对于学生，我们说的每句话可能都是他们对社会的认知，大家喷的时候私聊我就好了，别破了别人的梦，自己不努力，也别拉别人下水。**\n\n《吐血整理》系列：\n\n- 写这个的系列的初衷就是想把大家常用的工具，书单等整理出来，把好的东西安利给大家，也希望从大家那等到一些好东西，后续还会写大家希望我整理的东西的。\n\n  **一样的还是我整理个书单也有人喷，还是那句话，不爱看不看就好了，私聊我喷，总有需要的人。**\n\n《大厂面试》系列：\n\n- 筹备中，形式应该先写一部分身边小伙伴大厂的面试经历和面试题讲解，后续只能靠投稿了。\n\n《有生之年》系列：\n\n- 突然想到的一个系列，只是突然想到这个名字哈哈。\n\n### 回馈 \n\n每个月恰饭的钱不多，但是也是大家赏脸的结果，我就拿一部分出来回馈大家，我喜欢书籍，所以我也决定了每个月都会送一些书给大家，书可能也不会太贵，但是是我的一份心意。\n\n### 2020期许 \n\n没啥期许，希望明年这个时候我还没放弃写作，家里一切ok，最好能找个女仔哈哈。\n\n做个俗人，贪财好色。\n\n### 总结 \n\n过去的一年，总的来说是美好的一年，我也知道新的一年是更加美好的一年，大家是不是发现我没你们想象的那么风光，以为我的工资肯定过的很潇洒，相反我也偶尔要借钱生活，不过明年肯定不会了，毕竟家里的好起来了。\n\n你看，我这不是就帮家里换了那个村里唯一的大头电视，买了家里的第一个冰箱，这不就好起来了嘛。\n', '6', '65', '2019-12-19');
INSERT INTO `articles` VALUES ('14', 'chenin', '阅读', '掘金年度征文 | 2019 与我的技术之路', '掘友们，大家好呀，我是掘金酱。\n\n长大之后，时间总是过得飞快，转眼之间，今年已经只剩下16天了。小时候总感觉遥不可及、只在科幻小说里面出现的2020年，已经开始进入蓄力期了。\n\n**想和你一起，聊一聊过去的2019年。**\n\n回头盘点一下你的2019年，年初豪言壮志立下的flag，你完成了多少呢；**2019对你来说，是怎样的一年，发生了哪些新的变化？**\n\n是写了 **XX** 行代码；还是学习了 **XX** 个新技术？ 是完成了 **XX** 个项目；还是踩过了 **XX** 个坑？ 是摆平开发难关，薪资翻了 **N** 倍；还是突破技术瓶颈，跳到了新的环境？\n\n那么，在即将到来的2020，**新的一年，你会对自己有哪些期盼，又会定下哪些目标呢？** 你的愿望是：\n\n- 输出一系列的技术文章；\n- 做一个开源项目；\n- 学习多项新技术，打破技术天花板；\n- 找到心目中的 TA；\n- 精进能力，升职加薪变成人生赢家。\n\n与掘金酱一起**总结过去 + 期待未来**，我想为你提供这样一个机会，让一直急匆匆赶路的你可以停下来，回顾一下这一年在技术道路上的成长与收获，也希望别人的分享，也可以对你有所帮助。\n\n## 征文要求\n\n本次征文活动主题**不限**，对于文章类型以及活动参与方式，我们有以下几点小要求。\n\n1. 文章须为**原创文章**，并使用**掘金专栏**发出（掘金 Web 主页点击写文章按钮）；\n\n2. 征文主题与\n\n   技术\n\n   相关，可以是你对某一技术的学习总结，经验分享，也可以是你参与项目的研发过程。需要你注意的是，本次活动不接受下面几种文章。\n\n   - 资源聚合类文章，例如 Awesome-List；\n   - 入门教程文章，例如「如何搭建 Hexo 博客」、环境搭建等内容；\n   - 翻译类文章；\n   - 与技术无关的文章；\n   - 有失中立性、公正性的内容，比如由公司或者公司的代理机构（如公关公司）所撰写，单纯希望宣传自己的商业产品或者公司的内容；\n   - 内容与活动主题不符、非原创内容。有洗稿、营销软文、广告、抄袭嫌疑的文章一经发现，取消参赛资格，并会影响到之后活动的参加资格。\n\n3. 字数要求：**600 字以上**。\n\n4. 获奖作品，著作权归作者所有，掘金拥有使用权；\n\n5. **活动时间**：\n\n- 12 月 16 日 - 1 月 15 日\n- 1 月 16日 - 1 月 20 日 评选与发奖\n\n注：掘金对本次技术征文活动享有最终解释权。\n\n> 所有符合征文活动要求的参与文章，都将获得「 掘金首页热门推荐」，更有机会获得掘金官方微博、微信公众号等渠道推荐，让更多用户可以看到你的文章。\n\n## 参考范文\n\n- @LienJack：[一位前端 2018 绝地求生记 | 掘金年度征文](https://juejin.im/post/5c36fe50518825253b5e94f4)\n- @Castie1：[iOS 开发者如何突破那被限制的视野 | 掘金年度征文](https://juejin.im/post/5c37022d51882523ea6de697)\n- @郭孝星：[我的2018年度总结 | 掘金年度征文](https://juejin.im/post/5c110ff36fb9a049a62c714a)\n- @老姚：[2018年收获5条认知，条条振聋发聩 | 掘金年度征文](https://juejin.im/post/5c34abc56fb9a049d519ace9)\n- @Seymoe：[24K 纯非科班前端的总结与展望 | 掘金年度征文](https://juejin.im/post/5c358c4a51882524a541f217)\n\n## 参与方式\n\n征文活动面向所有掘金用户，参与方式如下：\n\n参与活动用户请以「`文章标题 | 掘金年度征文` 」作为写作内容标题。发布文章时，请选择「`阅读`」分类、「`程序员`」的标签，文末需附上本次征文活动的链接。\n\n格式为：\n\n1. 使用 **掘金 Markdown 编辑器** 的同学直接复制以下内容到文章后\n\n```\n [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec )\n复制代码\n```\n\n1. 使用 **掘金富文本编辑器** 的同学直接复制以下内容到文章后\n\n   [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec)\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('15', 'chenin', '阅读', ' 2019 与我的技术之路', '掘友们，大家好呀，我是掘金酱。\n\n长大之后，时间总是过得飞快，转眼之间，今年已经只剩下16天了。小时候总感觉遥不可及、只在科幻小说里面出现的2020年，已经开始进入蓄力期了。\n\n**想和你一起，聊一聊过去的2019年。**\n\n回头盘点一下你的2019年，年初豪言壮志立下的flag，你完成了多少呢；**2019对你来说，是怎样的一年，发生了哪些新的变化？**\n\n是写了 **XX** 行代码；还是学习了 **XX** 个新技术？ 是完成了 **XX** 个项目；还是踩过了 **XX** 个坑？ 是摆平开发难关，薪资翻了 **N** 倍；还是突破技术瓶颈，跳到了新的环境？\n\n那么，在即将到来的2020，**新的一年，你会对自己有哪些期盼，又会定下哪些目标呢？** 你的愿望是：\n\n- 输出一系列的技术文章；\n- 做一个开源项目；\n- 学习多项新技术，打破技术天花板；\n- 找到心目中的 TA；\n- 精进能力，升职加薪变成人生赢家。\n\n与掘金酱一起**总结过去 + 期待未来**，我想为你提供这样一个机会，让一直急匆匆赶路的你可以停下来，回顾一下这一年在技术道路上的成长与收获，也希望别人的分享，也可以对你有所帮助。\n\n## 征文要求\n\n本次征文活动主题**不限**，对于文章类型以及活动参与方式，我们有以下几点小要求。\n\n1. 文章须为**原创文章**，并使用**掘金专栏**发出（掘金 Web 主页点击写文章按钮）；\n\n2. 征文主题与\n\n   技术\n\n   相关，可以是你对某一技术的学习总结，经验分享，也可以是你参与项目的研发过程。需要你注意的是，本次活动不接受下面几种文章。\n\n   - 资源聚合类文章，例如 Awesome-List；\n   - 入门教程文章，例如「如何搭建 Hexo 博客」、环境搭建等内容；\n   - 翻译类文章；\n   - 与技术无关的文章；\n   - 有失中立性、公正性的内容，比如由公司或者公司的代理机构（如公关公司）所撰写，单纯希望宣传自己的商业产品或者公司的内容；\n   - 内容与活动主题不符、非原创内容。有洗稿、营销软文、广告、抄袭嫌疑的文章一经发现，取消参赛资格，并会影响到之后活动的参加资格。\n\n3. 字数要求：**600 字以上**。\n\n4. 获奖作品，著作权归作者所有，掘金拥有使用权；\n\n5. **活动时间**：\n\n- 12 月 16 日 - 1 月 15 日\n- 1 月 16日 - 1 月 20 日 评选与发奖\n\n注：掘金对本次技术征文活动享有最终解释权。\n\n> 所有符合征文活动要求的参与文章，都将获得「 掘金首页热门推荐」，更有机会获得掘金官方微博、微信公众号等渠道推荐，让更多用户可以看到你的文章。\n\n## 参考范文\n\n- @LienJack：[一位前端 2018 绝地求生记 | 掘金年度征文](https://juejin.im/post/5c36fe50518825253b5e94f4)\n- @Castie1：[iOS 开发者如何突破那被限制的视野 | 掘金年度征文](https://juejin.im/post/5c37022d51882523ea6de697)\n- @郭孝星：[我的2018年度总结 | 掘金年度征文](https://juejin.im/post/5c110ff36fb9a049a62c714a)\n- @老姚：[2018年收获5条认知，条条振聋发聩 | 掘金年度征文](https://juejin.im/post/5c34abc56fb9a049d519ace9)\n- @Seymoe：[24K 纯非科班前端的总结与展望 | 掘金年度征文](https://juejin.im/post/5c358c4a51882524a541f217)\n\n## 参与方式\n\n征文活动面向所有掘金用户，参与方式如下：\n\n参与活动用户请以「`文章标题 | 掘金年度征文` 」作为写作内容标题。发布文章时，请选择「`阅读`」分类、「`程序员`」的标签，文末需附上本次征文活动的链接。\n\n格式为：\n\n1. 使用 **掘金 Markdown 编辑器** 的同学直接复制以下内容到文章后\n\n```\n [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec )\n复制代码\n```\n\n1. 使用 **掘金富文本编辑器** 的同学直接复制以下内容到文章后\n\n   [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec)\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('16', 'chenin', '阅读', '技术之路', '掘友们，大家好呀，我是掘金酱。\n\n长大之后，时间总是过得飞快，转眼之间，今年已经只剩下16天了。小时候总感觉遥不可及、只在科幻小说里面出现的2020年，已经开始进入蓄力期了。\n\n**想和你一起，聊一聊过去的2019年。**\n\n回头盘点一下你的2019年，年初豪言壮志立下的flag，你完成了多少呢；**2019对你来说，是怎样的一年，发生了哪些新的变化？**\n\n是写了 **XX** 行代码；还是学习了 **XX** 个新技术？ 是完成了 **XX** 个项目；还是踩过了 **XX** 个坑？ 是摆平开发难关，薪资翻了 **N** 倍；还是突破技术瓶颈，跳到了新的环境？\n\n那么，在即将到来的2020，**新的一年，你会对自己有哪些期盼，又会定下哪些目标呢？** 你的愿望是：\n\n- 输出一系列的技术文章；\n- 做一个开源项目；\n- 学习多项新技术，打破技术天花板；\n- 找到心目中的 TA；\n- 精进能力，升职加薪变成人生赢家。\n\n与掘金酱一起**总结过去 + 期待未来**，我想为你提供这样一个机会，让一直急匆匆赶路的你可以停下来，回顾一下这一年在技术道路上的成长与收获，也希望别人的分享，也可以对你有所帮助。\n\n## 征文要求\n\n本次征文活动主题**不限**，对于文章类型以及活动参与方式，我们有以下几点小要求。\n\n1. 文章须为**原创文章**，并使用**掘金专栏**发出（掘金 Web 主页点击写文章按钮）；\n\n2. 征文主题与\n\n   技术\n\n   相关，可以是你对某一技术的学习总结，经验分享，也可以是你参与项目的研发过程。需要你注意的是，本次活动不接受下面几种文章。\n\n   - 资源聚合类文章，例如 Awesome-List；\n   - 入门教程文章，例如「如何搭建 Hexo 博客」、环境搭建等内容；\n   - 翻译类文章；\n   - 与技术无关的文章；\n   - 有失中立性、公正性的内容，比如由公司或者公司的代理机构（如公关公司）所撰写，单纯希望宣传自己的商业产品或者公司的内容；\n   - 内容与活动主题不符、非原创内容。有洗稿、营销软文、广告、抄袭嫌疑的文章一经发现，取消参赛资格，并会影响到之后活动的参加资格。\n\n3. 字数要求：**600 字以上**。\n\n4. 获奖作品，著作权归作者所有，掘金拥有使用权；\n\n5. **活动时间**：\n\n- 12 月 16 日 - 1 月 15 日\n- 1 月 16日 - 1 月 20 日 评选与发奖\n\n注：掘金对本次技术征文活动享有最终解释权。\n\n> 所有符合征文活动要求的参与文章，都将获得「 掘金首页热门推荐」，更有机会获得掘金官方微博、微信公众号等渠道推荐，让更多用户可以看到你的文章。\n\n## 参考范文\n\n- @LienJack：[一位前端 2018 绝地求生记 | 掘金年度征文](https://juejin.im/post/5c36fe50518825253b5e94f4)\n- @Castie1：[iOS 开发者如何突破那被限制的视野 | 掘金年度征文](https://juejin.im/post/5c37022d51882523ea6de697)\n- @郭孝星：[我的2018年度总结 | 掘金年度征文](https://juejin.im/post/5c110ff36fb9a049a62c714a)\n- @老姚：[2018年收获5条认知，条条振聋发聩 | 掘金年度征文](https://juejin.im/post/5c34abc56fb9a049d519ace9)\n- @Seymoe：[24K 纯非科班前端的总结与展望 | 掘金年度征文](https://juejin.im/post/5c358c4a51882524a541f217)\n\n## 参与方式\n\n征文活动面向所有掘金用户，参与方式如下：\n\n参与活动用户请以「`文章标题 | 掘金年度征文` 」作为写作内容标题。发布文章时，请选择「`阅读`」分类、「`程序员`」的标签，文末需附上本次征文活动的链接。\n\n格式为：\n\n1. 使用 **掘金 Markdown 编辑器** 的同学直接复制以下内容到文章后\n\n```\n [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec )\n复制代码\n```\n\n1. 使用 **掘金富文本编辑器** 的同学直接复制以下内容到文章后\n\n   [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec)\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('17', 'chenin', '阅读', '2019', '掘友们，大家好呀，我是掘金酱。\n\n长大之后，时间总是过得飞快，转眼之间，今年已经只剩下16天了。小时候总感觉遥不可及、只在科幻小说里面出现的2020年，已经开始进入蓄力期了。\n\n**想和你一起，聊一聊过去的2019年。**\n\n回头盘点一下你的2019年，年初豪言壮志立下的flag，你完成了多少呢；**2019对你来说，是怎样的一年，发生了哪些新的变化？**\n\n是写了 **XX** 行代码；还是学习了 **XX** 个新技术？ 是完成了 **XX** 个项目；还是踩过了 **XX** 个坑？ 是摆平开发难关，薪资翻了 **N** 倍；还是突破技术瓶颈，跳到了新的环境？\n\n那么，在即将到来的2020，**新的一年，你会对自己有哪些期盼，又会定下哪些目标呢？** 你的愿望是：\n\n- 输出一系列的技术文章；\n- 做一个开源项目；\n- 学习多项新技术，打破技术天花板；\n- 找到心目中的 TA；\n- 精进能力，升职加薪变成人生赢家。\n\n与掘金酱一起**总结过去 + 期待未来**，我想为你提供这样一个机会，让一直急匆匆赶路的你可以停下来，回顾一下这一年在技术道路上的成长与收获，也希望别人的分享，也可以对你有所帮助。\n\n## 征文要求\n\n本次征文活动主题**不限**，对于文章类型以及活动参与方式，我们有以下几点小要求。\n\n1. 文章须为**原创文章**，并使用**掘金专栏**发出（掘金 Web 主页点击写文章按钮）；\n\n2. 征文主题与\n\n   技术\n\n   相关，可以是你对某一技术的学习总结，经验分享，也可以是你参与项目的研发过程。需要你注意的是，本次活动不接受下面几种文章。\n\n   - 资源聚合类文章，例如 Awesome-List；\n   - 入门教程文章，例如「如何搭建 Hexo 博客」、环境搭建等内容；\n   - 翻译类文章；\n   - 与技术无关的文章；\n   - 有失中立性、公正性的内容，比如由公司或者公司的代理机构（如公关公司）所撰写，单纯希望宣传自己的商业产品或者公司的内容；\n   - 内容与活动主题不符、非原创内容。有洗稿、营销软文、广告、抄袭嫌疑的文章一经发现，取消参赛资格，并会影响到之后活动的参加资格。\n\n3. 字数要求：**600 字以上**。\n\n4. 获奖作品，著作权归作者所有，掘金拥有使用权；\n\n5. **活动时间**：\n\n- 12 月 16 日 - 1 月 15 日\n- 1 月 16日 - 1 月 20 日 评选与发奖\n\n注：掘金对本次技术征文活动享有最终解释权。\n\n> 所有符合征文活动要求的参与文章，都将获得「 掘金首页热门推荐」，更有机会获得掘金官方微博、微信公众号等渠道推荐，让更多用户可以看到你的文章。\n\n## 参考范文\n\n- @LienJack：[一位前端 2018 绝地求生记 | 掘金年度征文](https://juejin.im/post/5c36fe50518825253b5e94f4)\n- @Castie1：[iOS 开发者如何突破那被限制的视野 | 掘金年度征文](https://juejin.im/post/5c37022d51882523ea6de697)\n- @郭孝星：[我的2018年度总结 | 掘金年度征文](https://juejin.im/post/5c110ff36fb9a049a62c714a)\n- @老姚：[2018年收获5条认知，条条振聋发聩 | 掘金年度征文](https://juejin.im/post/5c34abc56fb9a049d519ace9)\n- @Seymoe：[24K 纯非科班前端的总结与展望 | 掘金年度征文](https://juejin.im/post/5c358c4a51882524a541f217)\n\n## 参与方式\n\n征文活动面向所有掘金用户，参与方式如下：\n\n参与活动用户请以「`文章标题 | 掘金年度征文` 」作为写作内容标题。发布文章时，请选择「`阅读`」分类、「`程序员`」的标签，文末需附上本次征文活动的链接。\n\n格式为：\n\n1. 使用 **掘金 Markdown 编辑器** 的同学直接复制以下内容到文章后\n\n```\n [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec )\n复制代码\n```\n\n1. 使用 **掘金富文本编辑器** 的同学直接复制以下内容到文章后\n\n   [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec)\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('18', 'chenin', '阅读', '123456', '掘友们，大家好呀，我是掘金酱。\n\n长大之后，时间总是过得飞快，转眼之间，今年已经只剩下16天了。小时候总感觉遥不可及、只在科幻小说里面出现的2020年，已经开始进入蓄力期了。\n\n**想和你一起，聊一聊过去的2019年。**\n\n回头盘点一下你的2019年，年初豪言壮志立下的flag，你完成了多少呢；**2019对你来说，是怎样的一年，发生了哪些新的变化？**\n\n是写了 **XX** 行代码；还是学习了 **XX** 个新技术？ 是完成了 **XX** 个项目；还是踩过了 **XX** 个坑？ 是摆平开发难关，薪资翻了 **N** 倍；还是突破技术瓶颈，跳到了新的环境？\n\n那么，在即将到来的2020，**新的一年，你会对自己有哪些期盼，又会定下哪些目标呢？** 你的愿望是：\n\n- 输出一系列的技术文章；\n- 做一个开源项目；\n- 学习多项新技术，打破技术天花板；\n- 找到心目中的 TA；\n- 精进能力，升职加薪变成人生赢家。\n\n与掘金酱一起**总结过去 + 期待未来**，我想为你提供这样一个机会，让一直急匆匆赶路的你可以停下来，回顾一下这一年在技术道路上的成长与收获，也希望别人的分享，也可以对你有所帮助。\n\n## 征文要求\n\n本次征文活动主题**不限**，对于文章类型以及活动参与方式，我们有以下几点小要求。\n\n1. 文章须为**原创文章**，并使用**掘金专栏**发出（掘金 Web 主页点击写文章按钮）；\n\n2. 征文主题与\n\n   技术\n\n   相关，可以是你对某一技术的学习总结，经验分享，也可以是你参与项目的研发过程。需要你注意的是，本次活动不接受下面几种文章。\n\n   - 资源聚合类文章，例如 Awesome-List；\n   - 入门教程文章，例如「如何搭建 Hexo 博客」、环境搭建等内容；\n   - 翻译类文章；\n   - 与技术无关的文章；\n   - 有失中立性、公正性的内容，比如由公司或者公司的代理机构（如公关公司）所撰写，单纯希望宣传自己的商业产品或者公司的内容；\n   - 内容与活动主题不符、非原创内容。有洗稿、营销软文、广告、抄袭嫌疑的文章一经发现，取消参赛资格，并会影响到之后活动的参加资格。\n\n3. 字数要求：**600 字以上**。\n\n4. 获奖作品，著作权归作者所有，掘金拥有使用权；\n\n5. **活动时间**：\n\n- 12 月 16 日 - 1 月 15 日\n- 1 月 16日 - 1 月 20 日 评选与发奖\n\n注：掘金对本次技术征文活动享有最终解释权。\n\n> 所有符合征文活动要求的参与文章，都将获得「 掘金首页热门推荐」，更有机会获得掘金官方微博、微信公众号等渠道推荐，让更多用户可以看到你的文章。\n\n## 参考范文\n\n- @LienJack：[一位前端 2018 绝地求生记 | 掘金年度征文](https://juejin.im/post/5c36fe50518825253b5e94f4)\n- @Castie1：[iOS 开发者如何突破那被限制的视野 | 掘金年度征文](https://juejin.im/post/5c37022d51882523ea6de697)\n- @郭孝星：[我的2018年度总结 | 掘金年度征文](https://juejin.im/post/5c110ff36fb9a049a62c714a)\n- @老姚：[2018年收获5条认知，条条振聋发聩 | 掘金年度征文](https://juejin.im/post/5c34abc56fb9a049d519ace9)\n- @Seymoe：[24K 纯非科班前端的总结与展望 | 掘金年度征文](https://juejin.im/post/5c358c4a51882524a541f217)\n\n## 参与方式\n\n征文活动面向所有掘金用户，参与方式如下：\n\n参与活动用户请以「`文章标题 | 掘金年度征文` 」作为写作内容标题。发布文章时，请选择「`阅读`」分类、「`程序员`」的标签，文末需附上本次征文活动的链接。\n\n格式为：\n\n1. 使用 **掘金 Markdown 编辑器** 的同学直接复制以下内容到文章后\n\n```\n [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec )\n复制代码\n```\n\n1. 使用 **掘金富文本编辑器** 的同学直接复制以下内容到文章后\n\n   [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec)\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('19', 'chenin', '阅读', '5456', '掘友们，大家好呀，我是掘金酱。\n\n长大之后，时间总是过得飞快，转眼之间，今年已经只剩下16天了。小时候总感觉遥不可及、只在科幻小说里面出现的2020年，已经开始进入蓄力期了。\n\n**想和你一起，聊一聊过去的2019年。**\n\n回头盘点一下你的2019年，年初豪言壮志立下的flag，你完成了多少呢；**2019对你来说，是怎样的一年，发生了哪些新的变化？**\n\n是写了 **XX** 行代码；还是学习了 **XX** 个新技术？ 是完成了 **XX** 个项目；还是踩过了 **XX** 个坑？ 是摆平开发难关，薪资翻了 **N** 倍；还是突破技术瓶颈，跳到了新的环境？\n\n那么，在即将到来的2020，**新的一年，你会对自己有哪些期盼，又会定下哪些目标呢？** 你的愿望是：\n\n- 输出一系列的技术文章；\n- 做一个开源项目；\n- 学习多项新技术，打破技术天花板；\n- 找到心目中的 TA；\n- 精进能力，升职加薪变成人生赢家。\n\n与掘金酱一起**总结过去 + 期待未来**，我想为你提供这样一个机会，让一直急匆匆赶路的你可以停下来，回顾一下这一年在技术道路上的成长与收获，也希望别人的分享，也可以对你有所帮助。\n\n## 征文要求\n\n本次征文活动主题**不限**，对于文章类型以及活动参与方式，我们有以下几点小要求。\n\n1. 文章须为**原创文章**，并使用**掘金专栏**发出（掘金 Web 主页点击写文章按钮）；\n\n2. 征文主题与\n\n   技术\n\n   相关，可以是你对某一技术的学习总结，经验分享，也可以是你参与项目的研发过程。需要你注意的是，本次活动不接受下面几种文章。\n\n   - 资源聚合类文章，例如 Awesome-List；\n   - 入门教程文章，例如「如何搭建 Hexo 博客」、环境搭建等内容；\n   - 翻译类文章；\n   - 与技术无关的文章；\n   - 有失中立性、公正性的内容，比如由公司或者公司的代理机构（如公关公司）所撰写，单纯希望宣传自己的商业产品或者公司的内容；\n   - 内容与活动主题不符、非原创内容。有洗稿、营销软文、广告、抄袭嫌疑的文章一经发现，取消参赛资格，并会影响到之后活动的参加资格。\n\n3. 字数要求：**600 字以上**。\n\n4. 获奖作品，著作权归作者所有，掘金拥有使用权；\n\n5. **活动时间**：\n\n- 12 月 16 日 - 1 月 15 日\n- 1 月 16日 - 1 月 20 日 评选与发奖\n\n注：掘金对本次技术征文活动享有最终解释权。\n\n> 所有符合征文活动要求的参与文章，都将获得「 掘金首页热门推荐」，更有机会获得掘金官方微博、微信公众号等渠道推荐，让更多用户可以看到你的文章。\n\n## 参考范文\n\n- @LienJack：[一位前端 2018 绝地求生记 | 掘金年度征文](https://juejin.im/post/5c36fe50518825253b5e94f4)\n- @Castie1：[iOS 开发者如何突破那被限制的视野 | 掘金年度征文](https://juejin.im/post/5c37022d51882523ea6de697)\n- @郭孝星：[我的2018年度总结 | 掘金年度征文](https://juejin.im/post/5c110ff36fb9a049a62c714a)\n- @老姚：[2018年收获5条认知，条条振聋发聩 | 掘金年度征文](https://juejin.im/post/5c34abc56fb9a049d519ace9)\n- @Seymoe：[24K 纯非科班前端的总结与展望 | 掘金年度征文](https://juejin.im/post/5c358c4a51882524a541f217)\n\n## 参与方式\n\n征文活动面向所有掘金用户，参与方式如下：\n\n参与活动用户请以「`文章标题 | 掘金年度征文` 」作为写作内容标题。发布文章时，请选择「`阅读`」分类、「`程序员`」的标签，文末需附上本次征文活动的链接。\n\n格式为：\n\n1. 使用 **掘金 Markdown 编辑器** 的同学直接复制以下内容到文章后\n\n```\n [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec )\n复制代码\n```\n\n1. 使用 **掘金富文本编辑器** 的同学直接复制以下内容到文章后\n\n   [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec)\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('20', 'chenin', '代码人生', '技术之路', '掘友们，大家好呀，我是掘金酱。\n\n长大之后，时间总是过得飞快，转眼之间，今年已经只剩下16天了。小时候总感觉遥不可及、只在科幻小说里面出现的2020年，已经开始进入蓄力期了。\n\n**想和你一起，聊一聊过去的2019年。**\n\n回头盘点一下你的2019年，年初豪言壮志立下的flag，你完成了多少呢；**2019对你来说，是怎样的一年，发生了哪些新的变化？**\n\n是写了 **XX** 行代码；还是学习了 **XX** 个新技术？ 是完成了 **XX** 个项目；还是踩过了 **XX** 个坑？ 是摆平开发难关，薪资翻了 **N** 倍；还是突破技术瓶颈，跳到了新的环境？\n\n那么，在即将到来的2020，**新的一年，你会对自己有哪些期盼，又会定下哪些目标呢？** 你的愿望是：\n\n- 输出一系列的技术文章；\n- 做一个开源项目；\n- 学习多项新技术，打破技术天花板；\n- 找到心目中的 TA；\n- 精进能力，升职加薪变成人生赢家。\n\n与掘金酱一起**总结过去 + 期待未来**，我想为你提供这样一个机会，让一直急匆匆赶路的你可以停下来，回顾一下这一年在技术道路上的成长与收获，也希望别人的分享，也可以对你有所帮助。\n\n## 征文要求\n\n本次征文活动主题**不限**，对于文章类型以及活动参与方式，我们有以下几点小要求。\n\n1. 文章须为**原创文章**，并使用**掘金专栏**发出（掘金 Web 主页点击写文章按钮）；\n\n2. 征文主题与\n\n   技术\n\n   相关，可以是你对某一技术的学习总结，经验分享，也可以是你参与项目的研发过程。需要你注意的是，本次活动不接受下面几种文章。\n\n   - 资源聚合类文章，例如 Awesome-List；\n   - 入门教程文章，例如「如何搭建 Hexo 博客」、环境搭建等内容；\n   - 翻译类文章；\n   - 与技术无关的文章；\n   - 有失中立性、公正性的内容，比如由公司或者公司的代理机构（如公关公司）所撰写，单纯希望宣传自己的商业产品或者公司的内容；\n   - 内容与活动主题不符、非原创内容。有洗稿、营销软文、广告、抄袭嫌疑的文章一经发现，取消参赛资格，并会影响到之后活动的参加资格。\n\n3. 字数要求：**600 字以上**。\n\n4. 获奖作品，著作权归作者所有，掘金拥有使用权；\n\n5. **活动时间**：\n\n- 12 月 16 日 - 1 月 15 日\n- 1 月 16日 - 1 月 20 日 评选与发奖\n\n注：掘金对本次技术征文活动享有最终解释权。\n\n> 所有符合征文活动要求的参与文章，都将获得「 掘金首页热门推荐」，更有机会获得掘金官方微博、微信公众号等渠道推荐，让更多用户可以看到你的文章。\n\n## 参考范文\n\n- @LienJack：[一位前端 2018 绝地求生记 | 掘金年度征文](https://juejin.im/post/5c36fe50518825253b5e94f4)\n- @Castie1：[iOS 开发者如何突破那被限制的视野 | 掘金年度征文](https://juejin.im/post/5c37022d51882523ea6de697)\n- @郭孝星：[我的2018年度总结 | 掘金年度征文](https://juejin.im/post/5c110ff36fb9a049a62c714a)\n- @老姚：[2018年收获5条认知，条条振聋发聩 | 掘金年度征文](https://juejin.im/post/5c34abc56fb9a049d519ace9)\n- @Seymoe：[24K 纯非科班前端的总结与展望 | 掘金年度征文](https://juejin.im/post/5c358c4a51882524a541f217)\n\n## 参与方式\n\n征文活动面向所有掘金用户，参与方式如下：\n\n参与活动用户请以「`文章标题 | 掘金年度征文` 」作为写作内容标题。发布文章时，请选择「`阅读`」分类、「`程序员`」的标签，文末需附上本次征文活动的链接。\n\n格式为：\n\n1. 使用 **掘金 Markdown 编辑器** 的同学直接复制以下内容到文章后\n\n```\n [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec )\n复制代码\n```\n\n1. 使用 **掘金富文本编辑器** 的同学直接复制以下内容到文章后\n\n   [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec)\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('21', 'chenin', '代码人生', '代码人生', '掘友们，大家好呀，我是掘金酱。\n\n长大之后，时间总是过得飞快，转眼之间，今年已经只剩下16天了。小时候总感觉遥不可及、只在科幻小说里面出现的2020年，已经开始进入蓄力期了。\n\n**想和你一起，聊一聊过去的2019年。**\n\n回头盘点一下你的2019年，年初豪言壮志立下的flag，你完成了多少呢；**2019对你来说，是怎样的一年，发生了哪些新的变化？**\n\n是写了 **XX** 行代码；还是学习了 **XX** 个新技术？ 是完成了 **XX** 个项目；还是踩过了 **XX** 个坑？ 是摆平开发难关，薪资翻了 **N** 倍；还是突破技术瓶颈，跳到了新的环境？\n\n那么，在即将到来的2020，**新的一年，你会对自己有哪些期盼，又会定下哪些目标呢？** 你的愿望是：\n\n- 输出一系列的技术文章；\n- 做一个开源项目；\n- 学习多项新技术，打破技术天花板；\n- 找到心目中的 TA；\n- 精进能力，升职加薪变成人生赢家。\n\n与掘金酱一起**总结过去 + 期待未来**，我想为你提供这样一个机会，让一直急匆匆赶路的你可以停下来，回顾一下这一年在技术道路上的成长与收获，也希望别人的分享，也可以对你有所帮助。\n\n## 征文要求\n\n本次征文活动主题**不限**，对于文章类型以及活动参与方式，我们有以下几点小要求。\n\n1. 文章须为**原创文章**，并使用**掘金专栏**发出（掘金 Web 主页点击写文章按钮）；\n\n2. 征文主题与\n\n   技术\n\n   相关，可以是你对某一技术的学习总结，经验分享，也可以是你参与项目的研发过程。需要你注意的是，本次活动不接受下面几种文章。\n\n   - 资源聚合类文章，例如 Awesome-List；\n   - 入门教程文章，例如「如何搭建 Hexo 博客」、环境搭建等内容；\n   - 翻译类文章；\n   - 与技术无关的文章；\n   - 有失中立性、公正性的内容，比如由公司或者公司的代理机构（如公关公司）所撰写，单纯希望宣传自己的商业产品或者公司的内容；\n   - 内容与活动主题不符、非原创内容。有洗稿、营销软文、广告、抄袭嫌疑的文章一经发现，取消参赛资格，并会影响到之后活动的参加资格。\n\n3. 字数要求：**600 字以上**。\n\n4. 获奖作品，著作权归作者所有，掘金拥有使用权；\n\n5. **活动时间**：\n\n- 12 月 16 日 - 1 月 15 日\n- 1 月 16日 - 1 月 20 日 评选与发奖\n\n注：掘金对本次技术征文活动享有最终解释权。\n\n> 所有符合征文活动要求的参与文章，都将获得「 掘金首页热门推荐」，更有机会获得掘金官方微博、微信公众号等渠道推荐，让更多用户可以看到你的文章。\n\n## 参考范文\n\n- @LienJack：[一位前端 2018 绝地求生记 | 掘金年度征文](https://juejin.im/post/5c36fe50518825253b5e94f4)\n- @Castie1：[iOS 开发者如何突破那被限制的视野 | 掘金年度征文](https://juejin.im/post/5c37022d51882523ea6de697)\n- @郭孝星：[我的2018年度总结 | 掘金年度征文](https://juejin.im/post/5c110ff36fb9a049a62c714a)\n- @老姚：[2018年收获5条认知，条条振聋发聩 | 掘金年度征文](https://juejin.im/post/5c34abc56fb9a049d519ace9)\n- @Seymoe：[24K 纯非科班前端的总结与展望 | 掘金年度征文](https://juejin.im/post/5c358c4a51882524a541f217)\n\n## 参与方式\n\n征文活动面向所有掘金用户，参与方式如下：\n\n参与活动用户请以「`文章标题 | 掘金年度征文` 」作为写作内容标题。发布文章时，请选择「`阅读`」分类、「`程序员`」的标签，文末需附上本次征文活动的链接。\n\n格式为：\n\n1. 使用 **掘金 Markdown 编辑器** 的同学直接复制以下内容到文章后\n\n```\n [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec )\n复制代码\n```\n\n1. 使用 **掘金富文本编辑器** 的同学直接复制以下内容到文章后\n\n   [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec)\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('22', 'chenin', '代码人生', '代码人生2', '掘友们，大家好呀，我是掘金酱。\n\n长大之后，时间总是过得飞快，转眼之间，今年已经只剩下16天了。小时候总感觉遥不可及、只在科幻小说里面出现的2020年，已经开始进入蓄力期了。\n\n**想和你一起，聊一聊过去的2019年。**\n\n回头盘点一下你的2019年，年初豪言壮志立下的flag，你完成了多少呢；**2019对你来说，是怎样的一年，发生了哪些新的变化？**\n\n是写了 **XX** 行代码；还是学习了 **XX** 个新技术？ 是完成了 **XX** 个项目；还是踩过了 **XX** 个坑？ 是摆平开发难关，薪资翻了 **N** 倍；还是突破技术瓶颈，跳到了新的环境？\n\n那么，在即将到来的2020，**新的一年，你会对自己有哪些期盼，又会定下哪些目标呢？** 你的愿望是：\n\n- 输出一系列的技术文章；\n- 做一个开源项目；\n- 学习多项新技术，打破技术天花板；\n- 找到心目中的 TA；\n- 精进能力，升职加薪变成人生赢家。\n\n与掘金酱一起**总结过去 + 期待未来**，我想为你提供这样一个机会，让一直急匆匆赶路的你可以停下来，回顾一下这一年在技术道路上的成长与收获，也希望别人的分享，也可以对你有所帮助。\n\n## 征文要求\n\n本次征文活动主题**不限**，对于文章类型以及活动参与方式，我们有以下几点小要求。\n\n1. 文章须为**原创文章**，并使用**掘金专栏**发出（掘金 Web 主页点击写文章按钮）；\n\n2. 征文主题与\n\n   技术\n\n   相关，可以是你对某一技术的学习总结，经验分享，也可以是你参与项目的研发过程。需要你注意的是，本次活动不接受下面几种文章。\n\n   - 资源聚合类文章，例如 Awesome-List；\n   - 入门教程文章，例如「如何搭建 Hexo 博客」、环境搭建等内容；\n   - 翻译类文章；\n   - 与技术无关的文章；\n   - 有失中立性、公正性的内容，比如由公司或者公司的代理机构（如公关公司）所撰写，单纯希望宣传自己的商业产品或者公司的内容；\n   - 内容与活动主题不符、非原创内容。有洗稿、营销软文、广告、抄袭嫌疑的文章一经发现，取消参赛资格，并会影响到之后活动的参加资格。\n\n3. 字数要求：**600 字以上**。\n\n4. 获奖作品，著作权归作者所有，掘金拥有使用权；\n\n5. **活动时间**：\n\n- 12 月 16 日 - 1 月 15 日\n- 1 月 16日 - 1 月 20 日 评选与发奖\n\n注：掘金对本次技术征文活动享有最终解释权。\n\n> 所有符合征文活动要求的参与文章，都将获得「 掘金首页热门推荐」，更有机会获得掘金官方微博、微信公众号等渠道推荐，让更多用户可以看到你的文章。\n\n## 参考范文\n\n- @LienJack：[一位前端 2018 绝地求生记 | 掘金年度征文](https://juejin.im/post/5c36fe50518825253b5e94f4)\n- @Castie1：[iOS 开发者如何突破那被限制的视野 | 掘金年度征文](https://juejin.im/post/5c37022d51882523ea6de697)\n- @郭孝星：[我的2018年度总结 | 掘金年度征文](https://juejin.im/post/5c110ff36fb9a049a62c714a)\n- @老姚：[2018年收获5条认知，条条振聋发聩 | 掘金年度征文](https://juejin.im/post/5c34abc56fb9a049d519ace9)\n- @Seymoe：[24K 纯非科班前端的总结与展望 | 掘金年度征文](https://juejin.im/post/5c358c4a51882524a541f217)\n\n## 参与方式\n\n征文活动面向所有掘金用户，参与方式如下：\n\n参与活动用户请以「`文章标题 | 掘金年度征文` 」作为写作内容标题。发布文章时，请选择「`阅读`」分类、「`程序员`」的标签，文末需附上本次征文活动的链接。\n\n格式为：\n\n1. 使用 **掘金 Markdown 编辑器** 的同学直接复制以下内容到文章后\n\n```\n [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec )\n复制代码\n```\n\n1. 使用 **掘金富文本编辑器** 的同学直接复制以下内容到文章后\n\n   [掘金年度征文 | 2019 与我的技术之路 征文活动正在进行中......](https://juejin.im/post/5def04e06fb9a01631780bec)\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('23', 'chenin', '代码人生', '菜鸡程序员是如何写代码的？', '每个程序员都要历经从菜鸡到大牛过程蜕变胡过程。当初大家起点都差不多，工作多年后，有些人依然停留在菜鸡，有些人却已成为大牛，所有的事情，都是一点一滴习惯养成。让我们看看菜鸡程序员是如何写代码的？有可能找到你当初的影子，甚至是现在的影子。\n\n**一、命名不规范**\n\n命名很随意，当时写代码特别High，什么奇奇怪怪的命名都有的：xiaonaigou,xxxx,j1,jl,llst.完全意识不到全名规范的价值和意义。\n\n\n\n![file](https://user-gold-cdn.xitu.io/2019/12/17/16f144215c9cd009?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n**二、日志不规范**\n\n日志？ 那是什么鬼东西，能吃么？\n\n曾经有一个从文思海辉出来的小伙伴，三年后端工程师经验，出了问题不知道怎么解决。只好重启。找我来协助，问他，怎么错了？  不知道。  日志呢？   没有。\n\n\n\n![file](https://user-gold-cdn.xitu.io/2019/12/17/16f1442197e9c825?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n晕，那怎么解决问题，神仙也搞不定啊。\n\n后来才知道，他们解决问题都是本地改代码然后直接部署，重新访问看错误消失没，没有消失就继续在本地改源码。\n\n**三、拒绝写接口和假数据**\n\n**一个菜鸡不可怕，可怕的是菜鸡遇到菜鸡。**曾经有一个项目中的两个菜鸡，一个前端一个后端，他们很欢快的调接口，根本不写文档 ，两个人效率特别高。直到有一天，发现项目可能做不完了，需要另外两个前端菜鸡协助一下。**新来的两个菜鸡要获取后端的数据，不知道接口的Url地址，不知道Get还是Post，不知道发送的参数和返回值。就这样写！我压根没想到可以这么写代码，两个菜鸡很开心！拍手称快：通了，通了，通了！**\n\n\n\n![file](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"300\" height=\"300\"></svg>)\n\n\n\n我说你们通什么呢？他们说接口终于通了！原来他们两个参考之间的页面，硬生生的一次一次不停的尝试，就这样把接口猜出来了！这就是编程的乐趣吗？还有不写假数据。曾经有一个马姓小哥，对赵姓小哥信誓旦旦的说：3天，给我3天时间 ，我把真数据给你。于是赵姓小哥信以为真。就这样，3天又3天，3天又3天，3天又3天，3天又3天，3天又3天。**整整一个半月，赵姓小哥都没有拿到全部的数据！**\n\n**四、不写单元测试**\n\n确切来说，是不按TDD的方式开发。在现在IDE这么强大的情况下，先写单元测试的习惯，不仅仅是代码的严谨性，也是效率的代名词啊。可是很多菜鸡理解不了单元测试的价值，没关系，等到代码重构，需求变更的时候，就哭都哭不出来了！好的单元测试，你的逻辑必然会清楚。第一次启动我的单元测试时，往往是这样\n\n\n\n![file](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"460\" height=\"218\"></svg>)\n\n\n\n**五、先集成，再测试，再放弃。**\n\n很多时候，**菜鸡在引入第三方的库，框架，接口或者是服务的时候，最喜欢的事情就是直接和自己原有的代码集成在一起**。结果 是什么呢？突然间不能用了，跑不起来了，不知道问题出在哪了，根本分不清倒底是第三方的问题还是自己的问题。\n\n\n\n![file](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"300\" height=\"300\"></svg>)\n\n\n\n**好的方法是什么？先跑通官方提供的Demo，再想办法一点一点加上自己的业务。**\n\n**六、理不清楚逻辑，边做边猜**\n\n前端在这里的问题特别多，做支付，不清楚支付的流程，分不清楚定义，总以为前端就是接口处理好数据展示好拉倒。很多菜鸡都会有这种习惯，这样不好，先把逻辑处理好，弄清楚流程，再去动手才好。\n\n\n\n![file](https://user-gold-cdn.xitu.io/2019/12/17/16f14422e0de0270?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n**七、不做方案**\n\n不做方案代表什么含义呢？就是完全凭直觉行走啊。\n\n\n\n![file](https://user-gold-cdn.xitu.io/2019/12/17/16f144232bfd07e6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n跟闭上眼逛窑子一样。写代码的好习惯应该是先在脑袋里把所有的需求细节过一遍，实现细节拿出来。上个月就有一个张姓小菜鸡，做一个匿名评论的功能。基本上没有什么经验，脑子也不好使，给出的方式是什么你们猜得到么？**用户刷新一次就往用户表里插入一条数据，密码默认昵称随机**。不多说了都是泪，我见过太多让人目瞪狗呆的方案了，看着满屏的代码，你怎么帮他调错调优，最好的方式就是全部重写。做方案的好处太多了。\n\n**8、不关注性能**\n\n不关注性能也是新人很容易犯的错。什么是性能呢。对后端来说就是TPS和响应时间，对前端来说就是响应时间。很多新人程序员的习惯就是把东西做出来，然后再优化。最后就是东西做出来了，优化留给别人了。对性能的关注也是晋升中级程序员最关键的技能点。**在写代码的时候，有经验的工程师已经知道了这个方法这个函数这个功能点的性能怎么样，瓶颈在哪里。**\n\n\n\n![file](https://user-gold-cdn.xitu.io/2019/12/17/16f14423975f74cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n**9、害怕重构**\n\n**“程序员最大的勇气就是看自己三个月之前写的代码。”**\n\n\n\n![file](https://user-gold-cdn.xitu.io/2019/12/17/16f1442418a67a54?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n其实重构并不应该是在几个月之后重构，最好的方式是实时重构。写一天代码，70%的时间都放到重构上都不过份。而新人呢，磕磕跘跘的完成一个功能，就跟多米诺骨牌做成的大黄蜂一样，你敢动一下他的代码试试？他会跟你拼命。你让他自己动一行代码试试？不重构在某种程度上也意味着你的代码实现无法重塑。当你再看到自己几个月没碰过的代码，往往是这样：\n\n\n\n![file](https://user-gold-cdn.xitu.io/2019/12/17/16f144246a7c62a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n**10、做出来就好，不考虑优雅的方案**\n\n**有个词叫做最佳实践，其实编码规范和最佳实践，是编程功底的重要体现。**优雅方案可以认为是最佳实践的升级版，它和上面说到的不断的重构是相辅相成的。不好的方案是什么呢？硬编码居多，没有可扩展性，用很丑陋的方式完成了功能。比如轮子是正方形的，也认为车子能开就行：\n\n\n\n![file](https://user-gold-cdn.xitu.io/2019/12/17/16f14424943c82b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n上次他们去做了一个关于试听课的方案，一个人能试听多少节课，正常的逻辑应该是在用户的表里加一个字段来表示。需求是写着邀请几个人，可以试听多少节课，所以他们判断试听多少节课就直接在通过邀请人的表里查询去做。完全没考虑到以后如果我变换了试听课的判断条件怎么办？实际上这是应该拆解成两部分，一个是试听课的产生条件，这是一个独立的模块，加一个是试听课的确认。像这种例子太多了，也和不做方案，不考虑扩展性有关系。就是接下来要说的。\n\n**11、不考虑未来需求的变化**\n\n工程师的水准，其实可以分成以下几个阶段：\n\n1、面向功能编程\n 2、面向性能编程\n 3、面向未来编程\n\n工程师拿到需求的第一件事，应该聚集在以下几个问题：\n\n第一 、哪些需求是我之前完成过的\n 第二 、哪些需求是有可能变化的\n 第三 、有几种方案，分别支持什么样的需求变化\n\n当一个新续期来时，往往都要推到重新来：\n\n\n\n![file](https://user-gold-cdn.xitu.io/2019/12/17/16f14424c3cbe832?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n但是差一点的程序员就考虑不到那么远，一个是对业务不熟悉，判断不出来哪些需求可能会产生变化，一个是对可选的方案掌握的不多，根本就没有什么可选的余地，还有就是没有这种思维习惯，分不清楚哪些是现在要完成的，哪些是未来可能会支持或者是变动的。\n\n**12、遇到问题的时候不会试错**\n\n这也是新手常见的问题。很多时候新人会遇到问题，解决不了，去找一个有经验的工程师，这个有经验的工程师呢，大概也未曾遇到这种情况，但是他解决问题的思路清楚啊。一会儿试试这个，一会儿删删那段代码，很快就跑通了。解决问题是一个很见功底的技术点，而且是有很多方法论的，之前总结过一些，简单列举过来：\n\n1.寻找正确的代码\n 2.理清楚正确的执行顺序\n 3.重现错误\n 4.最小化错误产生的场景\n 5.修改代码到一个已知的错误类型等等等。\n\n解决问题就是一个分析推理的过程，而在这里呢，背后的功底就是你知道很多哪些是肯定不会错的小公理，然后再挨个去定位可能产生错误的环节，分解流程是最基础的工作。高级开发调试问题，往往如下：\n\n\n\n![file](https://user-gold-cdn.xitu.io/2019/12/17/16f144250a607d08?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n**13、不会写伪代码**\n\n伪代码是什么呢？就是自然语言啊。其实编程只有三种逻辑控制块，顺序，循环，判断。所以你只要用自然语言来描述出来，先做什么，再做什么，什么时候循环，什么时候判断，代码写出来的问题就不大。这是一个先写伪代码再写细节的过程。你不要上来就开始平铺写代码。\n\n**平铺代码是最菜的方式，好的代码是有结构的，有不同的抽像层级。**\n\n第一步，干嘛。\n 第二步，干嘛。\n 第三步，干嘛。\n 先把这个列清楚，这是伪代码的第一级。\n 然后变成注释，这是第二级。\n 删掉注释变成函数名，这是第三级。\n\n所以说，**好的程序员写代码是不需要注释的，不是说让你把注释删掉，而是让你完成这三步升华的过程。**写的好的代码，命名规范，你看到的真的是一首诗， 是一种编程语言，是在用语言来描述一件功能的完成，这种编程艺术的工业感很爽快，你看那些不爽的代码，简直了。', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('24', 'chenin', '代码人生', '我是技术总监，我出来求职，竟然找不到工作！', '就在昨天下午，一个去年我来深圳认识的朋友肖总，之前交流过一些技术问题。问我最近有没有坑，肖总最近在找工作，相当不顺利，到处碰壁。\n\n**1、大厂出来后，没有一天不焦虑**\n\n肖总是做后端出身。之前在oppo呆过3年，后来去平安呆过2年，再后来出来去创业公司做了个小管理，由于后来技术总监跑路了，公司找不到合适的人，让他上去顶位了，title也变成了肖总。**早几年，公司发展还不错，那时就打算等公司上市，卖掉期权，就可以实现财富自由了**。但是一切并没有那么顺利，从大厂出来后，他说他没有一天不焦虑的，公司的产品主要是秀场直播，盈利模式主要是广告+主播分成。\n\n在直播产品中，算第4、第5梯队。虽然日活不多。但是有土豪老板用他们产品，肖总说：每次土豪充钱都是10w，8w的，土豪的世界，我们不懂。14年，A轮融资后，就没有融资过，不是不想融，数据不好看，加上BAT投资了一些头部公司，一些资本不看好后来的直播公司了。公司这几年营收养活团队还是没有问题的。但是今年遭到资本寒冬和短视频的冲击，还有头部秀场直播公司（映客，花椒，奇秀）不断在扩大和抱团。\n\n肖总他们公司势单力薄，每月服务器带宽费用，第三方SDK使用费。市场上大部分用户开始转向短视频领域，如抖音、快手。他们也做一些尝试，后来老板觉得没有收益。就放弃这个战略，转而不断推广他们直播产品，花了不少的钱，目的是为了拉新用户，但收效甚微。尽管土豪用户都是专人去电话联系和服务的，但是土豪用户，也有视觉疲劳。不可能一辈子在这个平台充值的。所以资金压力就来了。新用户增量不多，老用户流失，肖总表示更加焦虑了，公司已经欠薪2个月了，下面员工人心惶惶，走的走了，业务线七零八落。**老板天天在外面找人投资融钱，迟迟没有好消息带来。感觉不到年底，就要黄的节奏，开始去外面看看新机会。**\n\n**2、等来不是财富自由信号，却是公司快凉的钟声**\n\n肖总目前工作8年半，在这家创业公司做了1年小管理，后面2年半在这个创业公司任技术总监。管理Android、iOS、后台、H5、测试团队，也有50多号人。同时有些期权，本来等靠它财富自由，现在到32岁多了，又要出去找工作。肖总之前的履历还可以，自己面试了一些大厂的资深后台开发。但是他自己说，**在技术上，早已经被创业公司琐碎事情磨的差不多了**。更多技术都是过去一些旧框架，甚至都生疏了。虽然平时面试别人，但是都是从职业规划、职业发展，还有候选人性格，沟通能力去看，技术这块都是各组leader去把关了。**一些深入的细节，一问就懵逼。毕竟不天天写代码，没有那么多时间去研究技术**。最后，我建议肖总，就是别去面试这些岗位了，打击自信心。可以多打开自己视野，转而看一些项目管理岗位和产品类的岗位，这块对于他还有较多优势。\n\n**3、当上管理，技术也不能丢太多**\n\n看到肖总的经历，我不由得想到自己，此前不少创业团队让我去跟他们一起干，包括一些期权，管理岗位什么的哇。我只说暂时还只想好好搞搞技术，至少还要持续深入几年。有人说管理岗位多好哇，指挥别人干活，协调资源+开会就行了。看起来是挺不错的，不过我还是没去。**所以无论怎样，技术还是不能丢，如果持续在技术这条路行走的话。**\n\n**4、没有所谓稳定的工作，除了让自己升值**\n\n要做管理，争取去中大厂去做管理，安全系数更高么？这些公司不用担心哪天资金链断缺么？大厂不也有清理一些35岁不干活的老白兔么，这个哪个公司都会有，为啥呢，**换个角度，你是老板，你会让那些没有给公司带来任何收益的员工一直在这养老么？毕竟你不是开福利院，也不是开养老院**。所以，**去任何公司都要找好自己的定位，团队的定位。**一个人的努力虽然不可能瞬时弥补世代积累的财富差异，但至少，你付出多少努力就能给自己换取多少选择。努力所带给我们更多的是选择身边交往圈子的权利，是选择一种生活方式的权利。我们的努力诚然是为了物质财富，但另一方面也是为了让自己过上更好的生活。**你是什么人便吸引什么人，你所选择的，同时也在选择着你，彼此塑造，互相成全。**\n\n**5、身价看品牌和平台**\n\n找工作，要看长远利益。文中提到过，**一个人的身价看两点，第一看当下：你现在的真实身价等于人才市场你所心仪的所有雇主给你身价的中位值；第二看未来，好平台会让你身价在同期增长最快**。看现在，如果只有一家公司愿意开出如此的高薪，你要问自己：「当下的我是否值这个价？高价格的背后隐藏了什么？」这并非不自信，看到过很多不理智的企业行为，比如短时间内大量招人，招人时完全不顾成本等。站在公司的角度来看，**这些短期繁荣之后紧接着都是巨大的危机**。站在求职者角度，因为企业不理智带来自己的痛苦会更多，因为这种虚高不可持续。一个人心态一旦拔高了，再让他回到真实水平会很难。这样的例子太多，我就不一一列举了。看未来，你从这家公司离开时的身价是非常重要的。什么是好平台？就是在简历上你的名字前面有这家公司名字的话，你会很值钱、很抢手。**所以，很多时候你的身价水平不取决于个人努力，而取决于平台品牌与实力，所以你个人的选择最关键**。\n\n**6、这个世界，每个人都在博机会**\n\n那有人说，我在这些有品牌的公司干了多年技术，最终上不去管理岗位，还不是要去创业公司博一搏。是的，**没错，这个世界人人都在博机会，很多人抱着博一搏心态很正常**。那就是在去之前，各方面了解信息和背景。比如个人看法，过B轮了么？A轮和B轮的时间间隔多长，为什么要看这个时间，快速发展的公司这个时间都会很短，因为市场好，资本看好，所以很快进B轮。B轮到C轮，更是需要市场规模和用户，还有多种盈利模式。熬到了D轮的公司。已经是商业化较成熟的了。有一套能持续造血的系统。如果你背景不差，那去的团队，团队成员都是什么样的？你肯定要了解的。\n\n有人说，别人挖你来，是解决问题，不是让你看这看那，我想说的是，除非给你一个无法拒绝的价格，如你当前年薪50w，人家给150w，**给的多，说明对你能力和认可度更高，钱是市场衡量价值最好的东西**。否则，你肯定是关注我说的这些点的。如果你有选择权的话。还有一些产品上观念是否认同？不认同，后期很容易出问题。因为理念不一致，很难共生。在大公司里，这个叫价值观。最后，就是创始人之前有无失败的创业经历？我们知道，在国内首次创业成功的几率很小很小，我们都是普通人，可能没有这么幸运遇到。\n\n**那么老板过去失败的经历，一定对这次创业更小心和谨慎的，过去犯过的错，不会再犯第二次**。那么相对来说，成功几率就会大些。公司背后的输血和造血模式怎样的？如是否BAT和一些著名资本领投的？BAT看重的公司，在一些流量上可能会有深度合作。自己造血又是怎么造的？别人投资只是给你们锦上添花，用完了还要自己造血。**如果有我说的这类公司，你甚至可以降薪或者平薪去，后续带给你的收益和跳槽时那点涨幅，会更大的。**\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('25', 'chenin', '人工智能', '爬虫实战-手把手教你爬豆瓣电影', '> 点赞再看，养成好习惯\n>\n> \n>\n> Python版本3.8.0，开发工具：Pycharm\n\n\n\n#### 写在前面的话\n\n目前为止，你应该已经了解爬虫的三个基本小节：\n\n- [爬虫的原理和流程](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483880&idx=1&sn=7b3c4461cd3d2e9e26db8eb3918bff74&chksm=ec7f9a1cdb08130af14247f4be2ead36590fc96233f24028333ca8da74c5e40990979f70f43e&token=109866799&lang=zh_CN#rd)\n- [爬虫的两种实现方式](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483885&idx=1&sn=96416d5a3799864c6e1ff19c6e2c4bb9&chksm=ec7f9a19db08130f5a80c61acc196d34728ac27ec05bc558ed3ffc4e6274f5bad251d358c8a0&token=109866799&lang=zh_CN#rd)\n- [通过 BeautifulSoup 解析网页源码](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483891&idx=1&sn=a5fabdd931073088bf95d89ed0de7cb2&chksm=ec7f9a07db08131196a351d63e3170aea9889ca761ae22ed53e86dab21244eb7ef32383acec3&token=109866799&lang=zh_CN#rd)\n\n如果上面三小节还有问题，可以`点回去再复习一下`。作为基础内容并不是要求大家一定都掌握，特别是第三小节，网页解析用法特别多，一般人很难都记住。\n\n\n我在写这篇的时候也会时不时的翻回去看一看之前的文章，可能有的方法并不是最简单的方法，但是只要`达成目的`就ok，这里你们`自由发挥`。\n\n“小一哥，为什么你这里用的是 find 方法解析，我用正则表达式可以吗？”\n“当然可以啊，或许你的正则表达式实现起来更简单”\n\n\n那么，作为我们爬虫的第一个小项目，我会尽可能的`讲清楚每一步代码`，就算没讲到，也`会有注释`，不用担心跟不上看不懂。\n\n\n另外，虽然说是第一篇爬虫文章，但我还是会对爬虫的结果进行数据分析。对于项目而言比较简单，目的是让大家`了解整个分析的过程`。\n\n\n记住一点：爬虫永远不是我们的终点，最多算是我们数据分析之路的`踏板`。\n\n```\n源码获取方式在文末\n```\n\n\n\n\n\n#### 正文\n\n**明确需求**\n我们今天要爬的数据是`豆瓣电影Top250`，是的，只有250条数据，你没猜错。\n输入网址  `https://movie.douban.com/top250` 我们可以看到网页长这样：\n\n\n\n![img](https://user-gold-cdn.xitu.io/2019/12/16/16f0f0e95f8fd6fd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1179\" height=\"622\"></svg>)\n\n\n\n`250条数据`清清楚楚，没有问题。\n\n可以看到，这个页面其实已经包含了影片的`主要内容`：影片名、排序、编剧、主演、年份、类型、评论人数、评分，基本上都在这个页面中。\n但我点开`详细影片`之后，发现了这个：\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1104\" height=\"550\"></svg>)\n\n\n似乎这个页面数据更全一些，我们爬数据要的是什么，肯定是数据越多越好啊。相比这个详细内容，更是多了每个星级的影评占比，那我们肯定选择它了啊\n\n\n**好，那理一下我们的思路**\n\n\n\n\n\n- 首先，进入豆瓣电影Top250，一共10页，每页25个影片。\n\n- 然后，针对每一页的25个影片，进入其详细内容页面\n\n- 最后，解析每个影片的详细内容，保存内容到数据库中\n\n  \n  **写一下伪代码**\n\n```Python\n# 遍历10页data_movies # 保存所有影片数据集for per_page in pages:        # 爬取10页的每一页数据     movies = craw_page_info(per_page)    # 遍历每一页的25个影片    for movie in movies:        # 爬取每个影片的详细内容        data_per_movie = craw_detail_info(movie)        # 保存每个影片信息到数据集中        data_movies.append(data_per_movie)# 保存结果到数据库中data_movies_to_mysql复制代码\n```\n\n稍微解释一下：`两层循环`，第一层是遍历`10页网页`，因为其中每个网页分别有25个影片，所以，第二层循环又依次遍历`25个影片`获取详细信息，最后保存结果到数据库中！\n**是不是，很，简，单！**\n\n> 但是，实操起来你可能会遇到各种各样的问题，做好心理准备！\n\n\n\n#### 开始实操\n\n**首先，确定我们要输出的影片字段**\n`主要数据`包括：影片排序、影片名称、影片导演、影片编剧、影片主演、影片又名、影片链接\n`关键数据`包括：影片类型、制片国家、影片语言、上映日期、影片片长\n`核心数据`包括：影片评分、评论人数、5/4/3/2/1各星级对应的评论占比\n\n`字段如下`：\n\n```markdown\nmovie_rank：影片排序movie_name：影片名称movie_director：影片导演movie_writer：影片编剧movie_starring：影片主演movie_type：影片类型movie_country：影片制片国家movie_language：影片语言movie_release_date：影片上映日期movie_run_time：影片片长movie_second_name：影片又名movie_imdb_href：影片IMDb 链接movie_rating：影片总评分movie_comments_user：影片评论人数movie_five_star_ratio：影片5星占比movie_four_star_ratio：影片4星占比movie_three_star_ratio：影片3星占比movie_two_star_ratio：影片2星占比movie_one_star_ratio：影片1星占比movie_note：影片备注信息，一般为空复制代码\n```\n\n\n**然后，开始主流程**\n确认一下主要参数，起始页码（默认为0），每页影片25个，共10页，\n`参数如下`：\n\n```\nstart_page：起始页码page_size：每一页大小pages：总页码复制代码\n```\n\n\n**定义类对象**\n\n> 这里我们将每个影片封装成一个对象，传入我们的主要参数，设置爬虫头部，并建立和数据库的相关连接\n\n`类定义对象如下`：\n\n```Python\nclass DouBanMovie:    def __init__(self, url, start_page, pages, page_size):        \"\"\"        初始化        @param url: 爬取主网址        @param start_page: 起始页码        @param pages: 总页码（截止页码）        @param page_size: 每页的大小        \"\"\"        self.url = url        self.start_page = start_page        self.pages = pages        self.page_size = page_size        self.data_info = []        self.pymysql_engine, self.pymysql_session = connection_to_mysql()        self.headers = {            \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\'        }复制代码\n```\n\n“小一哥，你这里的数据库连接用的是什么啊，我怎么看不太懂？”\n“我封装了一下，数据库的连接这里选用了 SQLAlchemy。\"\n\n不要着急，以后会专门写一篇 SQLAlchemy 关于数据库的相关操作\n\n```Python\n#  创建基类,Base = declarative_base()def connection_to_mysql():    \"\"\"    连接数据库    @return:    \"\"\"    engine = create_engine(\'mysql+pymysql://username:passwd@localhost:3306/db_name?charset=utf8\')    Session = sessionmaker(bind=engine)    db_session = Session()    # 创建数据表    Base.metadata.create_all(engine)    return engine, db_session复制代码\n```\n\n\n**确定主框架：**\n\n```Python\n# 如果当前页码小于0，异常退出if self.start_page < 0:    return \"\"# 如果起始页面大于总页码数，退出if self.start_page > self.pages:    return \"\"# 若当前页其实页码小于总页数，继续爬取数据while self.start_page < pages:    # 拼接当前页的网址    # 主爬虫代码    # 下一页    self.start_page = self.start_page + 1复制代码\n```\n\n`拼接当前页的网址`这里解释一下，当我们去访问第一页的时候发现网址如下\n\n```Python\nhttps://movie.douban.com/top250复制代码\n```\n\n去访问下一页的时候发现网址变化如下\n\n```Python\nhttps://movie.douban.com/top250?start=25&filter=复制代码\n```\n\n而再下一页的网址变化如下：\n\n```Python\nhttps://movie.douban.com/top250?start=50&filter=复制代码\n```\n\n可以发现，新的网址只是`变化了后面的 start 参数`，于是我们拼接出每一页的网址：\n\n```Python\nstart_number = self.start_page * self.page_sizenew_url = self.url + \'?start=\' + str(start_number) + \'&filter=\'复制代码\n```\n\n\n\n**爬取第一个页面**\n确定好主框架之后，我们需要去爬取`第一个网页`，也就是包含`25个影片的页面`。\n这时候，我们前三节提到的爬虫实现方式直接拿过来：\n\n```Python\nself.headers = {    \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\',}# 爬取当前页码的数据response = requests.get(url=new_url, headers=self.headers)复制代码\n```\n\n成功获取到页面数据之后，我们需要`对页面解析`，拿到每一个影片`跳转详细页面的超链接`\n\n> 通过谷歌浏览器 F12 开发者工具可查看网页源码\n\n可以看到每个影片的详细信息在一个`li 标签`中，而每个 li 标签中都有一个`class=\'pic\' 的 div`，在 div 里面存在这样一个 `a 标签` 中\n\n而这个 a 标签的 href 正是我们要需要的 `详细页面信息的超链接`\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1104\"></svg>)\n\n\n\n\n确定了超链接位置所在，打开我们上一节的 BeautifulSoup 详解，定位、解析\n\n```Python\nsoup = BeautifulSoup(response.text, \'html.parser\')# 定位到每一个电影的 div （pic 标记的 div）soup_div_list = soup.find_all(class_=\"pic\")# 遍历获取每一个 div 的电影详情链接for soup_div in soup_div_list:    # 定位到每一个电影的 a 标签    soup_a = soup_div.find_all(\'a\')[0]    movie_href = soup_a.get(\'href\')    print(movie_href)复制代码\n```\n\n拿到当前页面的25 个影片的详细内容的超链接\n\n```\n我们离成功又进了一步！\n```\n\n\n**爬取详细页面**\n同样，一行代码拿下页面数据\n\n```Python\n\'\'\'爬取页面，获得详细数据\'\'\'response = requests.get(url=movie_detail_href, headers=self.headers)复制代码\n```\n\n创建一个有序字典，保存当前影片数据\n\n```Python\n# 生成一个有序字典，保存影片结果movie_info = OrderedDict()复制代码\n```\n\n我们再来看一下这个页面的的源码是什么样的，首先是影片排序和影片名称，我们可以从上个页面传递过来。但是，既然它这里有，我直接解析行不行？\n\n必须行啊！\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1227\"></svg>)\n\n\n\n这个更简单，影片排名直接定位一个 `class=\'top250-no\' 的 span 标签`，影片名称定位一个 `property=\'v:itemreviewed\' 的 span 标签`，获取标签内容即可\n\n```Python\n# 解析电影排名和名称movie_info[\'movie_rank\'] = soup.find_all(\'span\', class_=\'top250-no\')[0].stringmovie_info[\'movie_name\'] = soup.find_all(\'span\', property=\'v:itemreviewed\')[0].string复制代码\n```\n\n\n\n**接下来是影片主要数据**：\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1235\" height=\"1280\"></svg>)\n\n\n\n这个时候我们需要先定位到 `id=\'info\' 的 div`中，然后可以看到`整个 div 的数据`就是我们需要的主要数据。\n\n```Python\n# 定位到影片数据的 divsoup_div = soup.find(id=\'info\')复制代码\n```\n\n“不对啊，小一哥，我发现编剧有时候是一个，有时候是多个。多个的时候存在在多个 span 标签中，这个怎么办啊？”\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"698\" height=\"318\"></svg>)\n\n\n\n“这个简单，我写一个小函数，统一处理一下。“\n\n```Python\ndef get_mul_tag_info(self, soup_span):    \"\"\"    获取多个标签的结果合并在一个结果中返回，并用 / 分割    \"\"\"    info = \'\'    for second_span in soup_span:        # 区分 href 和标签内容        info = (\'\' if (info == \'\') else \'/\').join((info, second_span.string))    return info复制代码\n```\n\n“对了，你记得把最外层的 span 标签给我就行。像这种：”\n\n```Python\n# 解析电影发布信息movie_info[\'movie_director\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[0].find_all(\'a\'))movie_info[\'movie_writer\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[3].find_all(\'a\'))movie_info[\'movie_starring\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[6].find_all(\'a\'))movie_info[\'movie_type\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:genre\'))movie_info[\'movie_country\'] = soup_div.find(text=\'制片国家/地区:\').next_element.lstrip().rstrip()movie_info[\'movie_language\'] = soup_div.find(text=\'语言:\').next_element.lstrip().rstrip()movie_info[\'movie_release_date\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:initialReleaseDate\'))movie_info[\'movie_run_time\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:runtime\'))movie_info[\'movie_imdb_href\'] = soup_div.find(\'a\', target=\'_blank\')[\'href\']复制代码\n```\n\n“小一哥，又出问题了，有的影片没有`又名`标签，这个怎么处理呢？”\n“这个我们做个异常检测，没有的手动赋空值就行了。”\n\n```Python\nmovie_second_name = \'\'try:    movie_second_name = soup_div.find(text=\'又名:\').next_element.lstrip().rstrip()except AttributeError:    print(\'{0} 没有又名\'.format(movie_info[\'movie_name\']))    movie_info[\'movie_second_name\'] = movie_second_name复制代码\n```\n\n**最后还剩下评分数据**\n评分数据不但有总评分，还有每个星级的评分。\n\n“小一哥，你说我们取哪个数据啊？”\n“小孩才做选择，我当然是全部都要！”\n\n\n\n![img](https://user-gold-cdn.xitu.io/2019/12/16/16f0f12c7178cc95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n\n\n可以看到，总评分和总评论人数分别有一个`唯一的 property`，分别是`property=\'v:average\' 的 strong 标签`和 `property=\'v:votes\' 的 span 标签`\n\nok，接下来直接拿数据：\n\n```Python\n# 获取总评分和总评价人数movie_info[\'movie_rating\'] = soup.find_all(\'strong\', property=\'v:average\')[0].stringmovie_info[\'movie_comments_user\'] = soup.find_all(\'span\', property=\'v:votes\')[0].string复制代码\n```\n\n\n\n最后就剩下`每个星级的评分占比`，可以看到 `5星/4星/3星/2星/1星` 分别对应 `力荐/推荐/还行/较差/很差`，可以看到他们都存在在一个`class=\'ratings-on-weight\' 的 div`中\n\n所以，先定位 div ：\n\n```Python\n# 定位到影片星级评分占比的 divsoup_div = soup.find(\'div\', class_=\"ratings-on-weight\")复制代码\n```\n\n然后获取每个星级评分占比数据：\n\n```Python\n# 获取每个星级的评分movie_info[\'movie_five_star_ratio\'] = soup_div.find_all(\'div\')[0].find(class_=\'rating_per\').stringmovie_info[\'movie_four_star_ratio\'] = soup_div.find_all(\'div\')[2].find(class_=\'rating_per\').stringmovie_info[\'movie_three_star_ratio\'] = soup_div.find_all(\'div\')[4].find(class_=\'rating_per\').stringmovie_info[\'movie_two_star_ratio\'] = soup_div.find_all(\'div\')[6].find(class_=\'rating_per\').stringmovie_info[\'movie_one_star_ratio\'] = soup_div.find_all(\'div\')[8].find(class_=\'rating_per\').string复制代码\n```\n\n打印一下看一下我们`当前的影片`数据：\n\n> 对 movie_starring 字段只输出部分显示\n\n```Python\nOrderedDict(    [        (\'movie_rank\', \'No.1\'),         (\'movie_name\', \'肖申克的救赎 The Shawshank Redemption\'),         (\'movie_director\', \'弗兰克·德拉邦特\'),         (\'movie_writer\', \'弗兰克·德拉邦特/斯蒂芬·金\'),         (\'movie_starring\', \'蒂姆·罗宾斯/摩根·弗里曼/鲍勃·冈顿/威廉姆·赛德勒/),         (\'movie_type\', \'剧情/犯罪\'),         (\'movie_country\', \'美国\'),         (\'movie_language\', \'英语\'),         (\'movie_release_date\', \'1994-09-10(多伦多电影节)/1994-10-14(美国)\'),         (\'movie_run_time\', \'142分钟\'),         (\'movie_imdb_href\', \'https://www.imdb.com/title/tt0111161\'),         (\'movie_rating\', \'9.7\'),         (\'movie_comments_user\', \'1720706\'),         (\'movie_five_star_ratio\', \'84.8%\'),         (\'movie_four_star_ratio\', \'13.6%\'),         (\'movie_three_star_ratio\', \'1.4%\'),         (\'movie_two_star_ratio\', \'0.1%\'),         (\'movie_one_star_ratio\', \'0.1%\'),         (\'movie_note\', \'\')    ])复制代码\n```\n\n搞定，成功拿到了想要的数据，最后一步：`保存数据库`\n\n```python\n# 保存当前影片信息self.data_info.append(movie_info)# 获取数据并保存成 DataFramedf_data = pd.DataFrame(self.data_info)# 导入数据到 mysql 中df_data.to_sql(\'t_douban_movie_top_250\', self.pymysql_engine, index=False, if_exists=\'append\')复制代码\n```\n\n看一眼我们的数据库，该有的数据都存进去了\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"507\"></svg>)\n\n\n\n`到这里，爬虫就算是结束了`。\n\n\n\n\n\n#### 总结一下：\n\n**准备工作：**\n\n- 首先我们定义了一个影片对象，传入了网址的参数信息，设置了爬虫头部，并建立了数据库连接\n- 我们通过下一页分析出每个影片页的超链接，发现只是改变了参数\n- 建立了主流程，并写出了主流程的伪代码\n\n\n\n**开始爬虫：**\n\n- 爬取`第一页`的网页内容\n- 解析`第一页`的内容，获取每页中25个影片的详细超链接\n- 爬取`详细影片`的网页内容\n- 解析`第二页`的内容，保存到每个影片对象中\n- `保存数据`到数据库中\n\n\n\n**思考：**\n以上就是我们今天爬虫实战的主要内容，相对来说比较简单。\n第一个项目，旨在让大家了解`爬虫流程`，同时，也可以思考一下以下几点：\n\n- 影片详细页面的短评论数据\n- 影片详细页面的获奖情况数据\n- 影片详细页面的讨论区数据\n\n以上数据的获取是否可以用`今天的获取方法`？如果不行，那应该通过什么方式获取这些数据？\n\n\n\n#### 写在后面的话\n\n今天的实战项目就结束了，需要源代码的同学可以在`公众号后台`回复 `豆瓣电影` 获取，如果觉得小一哥讲的还不错的话，不妨`点个赞`？\n\n开篇已经提到，我们的目的不是爬数据。所以，我会利用这些数据做一个简单数据分析，目的很简单：了解数据分析的流程。下期见。\n\n\n\n**碎碎念一下**\n\n> 我发现写技术文比写软文难了不止一个档次，虽然软文没啥技术含量，但是大家爱看啊。\n>\n> \n>\n> 技术性文章苦涩难懂，不过像我讲这么详细的，你确定不点个再看支持一下？\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('26', 'chenin', '人工智能', '人工智能', '> 点赞再看，养成好习惯\n>\n> \n>\n> Python版本3.8.0，开发工具：Pycharm\n\n\n\n#### 写在前面的话\n\n目前为止，你应该已经了解爬虫的三个基本小节：\n\n- [爬虫的原理和流程](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483880&idx=1&sn=7b3c4461cd3d2e9e26db8eb3918bff74&chksm=ec7f9a1cdb08130af14247f4be2ead36590fc96233f24028333ca8da74c5e40990979f70f43e&token=109866799&lang=zh_CN#rd)\n- [爬虫的两种实现方式](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483885&idx=1&sn=96416d5a3799864c6e1ff19c6e2c4bb9&chksm=ec7f9a19db08130f5a80c61acc196d34728ac27ec05bc558ed3ffc4e6274f5bad251d358c8a0&token=109866799&lang=zh_CN#rd)\n- [通过 BeautifulSoup 解析网页源码](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483891&idx=1&sn=a5fabdd931073088bf95d89ed0de7cb2&chksm=ec7f9a07db08131196a351d63e3170aea9889ca761ae22ed53e86dab21244eb7ef32383acec3&token=109866799&lang=zh_CN#rd)\n\n如果上面三小节还有问题，可以`点回去再复习一下`。作为基础内容并不是要求大家一定都掌握，特别是第三小节，网页解析用法特别多，一般人很难都记住。\n\n\n我在写这篇的时候也会时不时的翻回去看一看之前的文章，可能有的方法并不是最简单的方法，但是只要`达成目的`就ok，这里你们`自由发挥`。\n\n“小一哥，为什么你这里用的是 find 方法解析，我用正则表达式可以吗？”\n“当然可以啊，或许你的正则表达式实现起来更简单”\n\n\n那么，作为我们爬虫的第一个小项目，我会尽可能的`讲清楚每一步代码`，就算没讲到，也`会有注释`，不用担心跟不上看不懂。\n\n\n另外，虽然说是第一篇爬虫文章，但我还是会对爬虫的结果进行数据分析。对于项目而言比较简单，目的是让大家`了解整个分析的过程`。\n\n\n记住一点：爬虫永远不是我们的终点，最多算是我们数据分析之路的`踏板`。\n\n```\n源码获取方式在文末\n```\n\n\n\n\n\n#### 正文\n\n**明确需求**\n我们今天要爬的数据是`豆瓣电影Top250`，是的，只有250条数据，你没猜错。\n输入网址  `https://movie.douban.com/top250` 我们可以看到网页长这样：\n\n\n\n![img](https://user-gold-cdn.xitu.io/2019/12/16/16f0f0e95f8fd6fd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1179\" height=\"622\"></svg>)\n\n\n\n`250条数据`清清楚楚，没有问题。\n\n可以看到，这个页面其实已经包含了影片的`主要内容`：影片名、排序、编剧、主演、年份、类型、评论人数、评分，基本上都在这个页面中。\n但我点开`详细影片`之后，发现了这个：\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1104\" height=\"550\"></svg>)\n\n\n似乎这个页面数据更全一些，我们爬数据要的是什么，肯定是数据越多越好啊。相比这个详细内容，更是多了每个星级的影评占比，那我们肯定选择它了啊\n\n\n**好，那理一下我们的思路**\n\n\n\n\n\n- 首先，进入豆瓣电影Top250，一共10页，每页25个影片。\n\n- 然后，针对每一页的25个影片，进入其详细内容页面\n\n- 最后，解析每个影片的详细内容，保存内容到数据库中\n\n  \n  **写一下伪代码**\n\n```Python\n# 遍历10页data_movies # 保存所有影片数据集for per_page in pages:        # 爬取10页的每一页数据     movies = craw_page_info(per_page)    # 遍历每一页的25个影片    for movie in movies:        # 爬取每个影片的详细内容        data_per_movie = craw_detail_info(movie)        # 保存每个影片信息到数据集中        data_movies.append(data_per_movie)# 保存结果到数据库中data_movies_to_mysql复制代码\n```\n\n稍微解释一下：`两层循环`，第一层是遍历`10页网页`，因为其中每个网页分别有25个影片，所以，第二层循环又依次遍历`25个影片`获取详细信息，最后保存结果到数据库中！\n**是不是，很，简，单！**\n\n> 但是，实操起来你可能会遇到各种各样的问题，做好心理准备！\n\n\n\n#### 开始实操\n\n**首先，确定我们要输出的影片字段**\n`主要数据`包括：影片排序、影片名称、影片导演、影片编剧、影片主演、影片又名、影片链接\n`关键数据`包括：影片类型、制片国家、影片语言、上映日期、影片片长\n`核心数据`包括：影片评分、评论人数、5/4/3/2/1各星级对应的评论占比\n\n`字段如下`：\n\n```markdown\nmovie_rank：影片排序movie_name：影片名称movie_director：影片导演movie_writer：影片编剧movie_starring：影片主演movie_type：影片类型movie_country：影片制片国家movie_language：影片语言movie_release_date：影片上映日期movie_run_time：影片片长movie_second_name：影片又名movie_imdb_href：影片IMDb 链接movie_rating：影片总评分movie_comments_user：影片评论人数movie_five_star_ratio：影片5星占比movie_four_star_ratio：影片4星占比movie_three_star_ratio：影片3星占比movie_two_star_ratio：影片2星占比movie_one_star_ratio：影片1星占比movie_note：影片备注信息，一般为空复制代码\n```\n\n\n**然后，开始主流程**\n确认一下主要参数，起始页码（默认为0），每页影片25个，共10页，\n`参数如下`：\n\n```\nstart_page：起始页码page_size：每一页大小pages：总页码复制代码\n```\n\n\n**定义类对象**\n\n> 这里我们将每个影片封装成一个对象，传入我们的主要参数，设置爬虫头部，并建立和数据库的相关连接\n\n`类定义对象如下`：\n\n```Python\nclass DouBanMovie:    def __init__(self, url, start_page, pages, page_size):        \"\"\"        初始化        @param url: 爬取主网址        @param start_page: 起始页码        @param pages: 总页码（截止页码）        @param page_size: 每页的大小        \"\"\"        self.url = url        self.start_page = start_page        self.pages = pages        self.page_size = page_size        self.data_info = []        self.pymysql_engine, self.pymysql_session = connection_to_mysql()        self.headers = {            \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\'        }复制代码\n```\n\n“小一哥，你这里的数据库连接用的是什么啊，我怎么看不太懂？”\n“我封装了一下，数据库的连接这里选用了 SQLAlchemy。\"\n\n不要着急，以后会专门写一篇 SQLAlchemy 关于数据库的相关操作\n\n```Python\n#  创建基类,Base = declarative_base()def connection_to_mysql():    \"\"\"    连接数据库    @return:    \"\"\"    engine = create_engine(\'mysql+pymysql://username:passwd@localhost:3306/db_name?charset=utf8\')    Session = sessionmaker(bind=engine)    db_session = Session()    # 创建数据表    Base.metadata.create_all(engine)    return engine, db_session复制代码\n```\n\n\n**确定主框架：**\n\n```Python\n# 如果当前页码小于0，异常退出if self.start_page < 0:    return \"\"# 如果起始页面大于总页码数，退出if self.start_page > self.pages:    return \"\"# 若当前页其实页码小于总页数，继续爬取数据while self.start_page < pages:    # 拼接当前页的网址    # 主爬虫代码    # 下一页    self.start_page = self.start_page + 1复制代码\n```\n\n`拼接当前页的网址`这里解释一下，当我们去访问第一页的时候发现网址如下\n\n```Python\nhttps://movie.douban.com/top250复制代码\n```\n\n去访问下一页的时候发现网址变化如下\n\n```Python\nhttps://movie.douban.com/top250?start=25&filter=复制代码\n```\n\n而再下一页的网址变化如下：\n\n```Python\nhttps://movie.douban.com/top250?start=50&filter=复制代码\n```\n\n可以发现，新的网址只是`变化了后面的 start 参数`，于是我们拼接出每一页的网址：\n\n```Python\nstart_number = self.start_page * self.page_sizenew_url = self.url + \'?start=\' + str(start_number) + \'&filter=\'复制代码\n```\n\n\n\n**爬取第一个页面**\n确定好主框架之后，我们需要去爬取`第一个网页`，也就是包含`25个影片的页面`。\n这时候，我们前三节提到的爬虫实现方式直接拿过来：\n\n```Python\nself.headers = {    \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\',}# 爬取当前页码的数据response = requests.get(url=new_url, headers=self.headers)复制代码\n```\n\n成功获取到页面数据之后，我们需要`对页面解析`，拿到每一个影片`跳转详细页面的超链接`\n\n> 通过谷歌浏览器 F12 开发者工具可查看网页源码\n\n可以看到每个影片的详细信息在一个`li 标签`中，而每个 li 标签中都有一个`class=\'pic\' 的 div`，在 div 里面存在这样一个 `a 标签` 中\n\n而这个 a 标签的 href 正是我们要需要的 `详细页面信息的超链接`\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1104\"></svg>)\n\n\n\n\n确定了超链接位置所在，打开我们上一节的 BeautifulSoup 详解，定位、解析\n\n```Python\nsoup = BeautifulSoup(response.text, \'html.parser\')# 定位到每一个电影的 div （pic 标记的 div）soup_div_list = soup.find_all(class_=\"pic\")# 遍历获取每一个 div 的电影详情链接for soup_div in soup_div_list:    # 定位到每一个电影的 a 标签    soup_a = soup_div.find_all(\'a\')[0]    movie_href = soup_a.get(\'href\')    print(movie_href)复制代码\n```\n\n拿到当前页面的25 个影片的详细内容的超链接\n\n```\n我们离成功又进了一步！\n```\n\n\n**爬取详细页面**\n同样，一行代码拿下页面数据\n\n```Python\n\'\'\'爬取页面，获得详细数据\'\'\'response = requests.get(url=movie_detail_href, headers=self.headers)复制代码\n```\n\n创建一个有序字典，保存当前影片数据\n\n```Python\n# 生成一个有序字典，保存影片结果movie_info = OrderedDict()复制代码\n```\n\n我们再来看一下这个页面的的源码是什么样的，首先是影片排序和影片名称，我们可以从上个页面传递过来。但是，既然它这里有，我直接解析行不行？\n\n必须行啊！\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1227\"></svg>)\n\n\n\n这个更简单，影片排名直接定位一个 `class=\'top250-no\' 的 span 标签`，影片名称定位一个 `property=\'v:itemreviewed\' 的 span 标签`，获取标签内容即可\n\n```Python\n# 解析电影排名和名称movie_info[\'movie_rank\'] = soup.find_all(\'span\', class_=\'top250-no\')[0].stringmovie_info[\'movie_name\'] = soup.find_all(\'span\', property=\'v:itemreviewed\')[0].string复制代码\n```\n\n\n\n**接下来是影片主要数据**：\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1235\" height=\"1280\"></svg>)\n\n\n\n这个时候我们需要先定位到 `id=\'info\' 的 div`中，然后可以看到`整个 div 的数据`就是我们需要的主要数据。\n\n```Python\n# 定位到影片数据的 divsoup_div = soup.find(id=\'info\')复制代码\n```\n\n“不对啊，小一哥，我发现编剧有时候是一个，有时候是多个。多个的时候存在在多个 span 标签中，这个怎么办啊？”\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"698\" height=\"318\"></svg>)\n\n\n\n“这个简单，我写一个小函数，统一处理一下。“\n\n```Python\ndef get_mul_tag_info(self, soup_span):    \"\"\"    获取多个标签的结果合并在一个结果中返回，并用 / 分割    \"\"\"    info = \'\'    for second_span in soup_span:        # 区分 href 和标签内容        info = (\'\' if (info == \'\') else \'/\').join((info, second_span.string))    return info复制代码\n```\n\n“对了，你记得把最外层的 span 标签给我就行。像这种：”\n\n```Python\n# 解析电影发布信息movie_info[\'movie_director\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[0].find_all(\'a\'))movie_info[\'movie_writer\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[3].find_all(\'a\'))movie_info[\'movie_starring\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[6].find_all(\'a\'))movie_info[\'movie_type\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:genre\'))movie_info[\'movie_country\'] = soup_div.find(text=\'制片国家/地区:\').next_element.lstrip().rstrip()movie_info[\'movie_language\'] = soup_div.find(text=\'语言:\').next_element.lstrip().rstrip()movie_info[\'movie_release_date\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:initialReleaseDate\'))movie_info[\'movie_run_time\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:runtime\'))movie_info[\'movie_imdb_href\'] = soup_div.find(\'a\', target=\'_blank\')[\'href\']复制代码\n```\n\n“小一哥，又出问题了，有的影片没有`又名`标签，这个怎么处理呢？”\n“这个我们做个异常检测，没有的手动赋空值就行了。”\n\n```Python\nmovie_second_name = \'\'try:    movie_second_name = soup_div.find(text=\'又名:\').next_element.lstrip().rstrip()except AttributeError:    print(\'{0} 没有又名\'.format(movie_info[\'movie_name\']))    movie_info[\'movie_second_name\'] = movie_second_name复制代码\n```\n\n**最后还剩下评分数据**\n评分数据不但有总评分，还有每个星级的评分。\n\n“小一哥，你说我们取哪个数据啊？”\n“小孩才做选择，我当然是全部都要！”\n\n\n\n![img](https://user-gold-cdn.xitu.io/2019/12/16/16f0f12c7178cc95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n\n\n可以看到，总评分和总评论人数分别有一个`唯一的 property`，分别是`property=\'v:average\' 的 strong 标签`和 `property=\'v:votes\' 的 span 标签`\n\nok，接下来直接拿数据：\n\n```Python\n# 获取总评分和总评价人数movie_info[\'movie_rating\'] = soup.find_all(\'strong\', property=\'v:average\')[0].stringmovie_info[\'movie_comments_user\'] = soup.find_all(\'span\', property=\'v:votes\')[0].string复制代码\n```\n\n\n\n最后就剩下`每个星级的评分占比`，可以看到 `5星/4星/3星/2星/1星` 分别对应 `力荐/推荐/还行/较差/很差`，可以看到他们都存在在一个`class=\'ratings-on-weight\' 的 div`中\n\n所以，先定位 div ：\n\n```Python\n# 定位到影片星级评分占比的 divsoup_div = soup.find(\'div\', class_=\"ratings-on-weight\")复制代码\n```\n\n然后获取每个星级评分占比数据：\n\n```Python\n# 获取每个星级的评分movie_info[\'movie_five_star_ratio\'] = soup_div.find_all(\'div\')[0].find(class_=\'rating_per\').stringmovie_info[\'movie_four_star_ratio\'] = soup_div.find_all(\'div\')[2].find(class_=\'rating_per\').stringmovie_info[\'movie_three_star_ratio\'] = soup_div.find_all(\'div\')[4].find(class_=\'rating_per\').stringmovie_info[\'movie_two_star_ratio\'] = soup_div.find_all(\'div\')[6].find(class_=\'rating_per\').stringmovie_info[\'movie_one_star_ratio\'] = soup_div.find_all(\'div\')[8].find(class_=\'rating_per\').string复制代码\n```\n\n打印一下看一下我们`当前的影片`数据：\n\n> 对 movie_starring 字段只输出部分显示\n\n```Python\nOrderedDict(    [        (\'movie_rank\', \'No.1\'),         (\'movie_name\', \'肖申克的救赎 The Shawshank Redemption\'),         (\'movie_director\', \'弗兰克·德拉邦特\'),         (\'movie_writer\', \'弗兰克·德拉邦特/斯蒂芬·金\'),         (\'movie_starring\', \'蒂姆·罗宾斯/摩根·弗里曼/鲍勃·冈顿/威廉姆·赛德勒/),         (\'movie_type\', \'剧情/犯罪\'),         (\'movie_country\', \'美国\'),         (\'movie_language\', \'英语\'),         (\'movie_release_date\', \'1994-09-10(多伦多电影节)/1994-10-14(美国)\'),         (\'movie_run_time\', \'142分钟\'),         (\'movie_imdb_href\', \'https://www.imdb.com/title/tt0111161\'),         (\'movie_rating\', \'9.7\'),         (\'movie_comments_user\', \'1720706\'),         (\'movie_five_star_ratio\', \'84.8%\'),         (\'movie_four_star_ratio\', \'13.6%\'),         (\'movie_three_star_ratio\', \'1.4%\'),         (\'movie_two_star_ratio\', \'0.1%\'),         (\'movie_one_star_ratio\', \'0.1%\'),         (\'movie_note\', \'\')    ])复制代码\n```\n\n搞定，成功拿到了想要的数据，最后一步：`保存数据库`\n\n```python\n# 保存当前影片信息self.data_info.append(movie_info)# 获取数据并保存成 DataFramedf_data = pd.DataFrame(self.data_info)# 导入数据到 mysql 中df_data.to_sql(\'t_douban_movie_top_250\', self.pymysql_engine, index=False, if_exists=\'append\')复制代码\n```\n\n看一眼我们的数据库，该有的数据都存进去了\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"507\"></svg>)\n\n\n\n`到这里，爬虫就算是结束了`。\n\n\n\n\n\n#### 总结一下：\n\n**准备工作：**\n\n- 首先我们定义了一个影片对象，传入了网址的参数信息，设置了爬虫头部，并建立了数据库连接\n- 我们通过下一页分析出每个影片页的超链接，发现只是改变了参数\n- 建立了主流程，并写出了主流程的伪代码\n\n\n\n**开始爬虫：**\n\n- 爬取`第一页`的网页内容\n- 解析`第一页`的内容，获取每页中25个影片的详细超链接\n- 爬取`详细影片`的网页内容\n- 解析`第二页`的内容，保存到每个影片对象中\n- `保存数据`到数据库中\n\n\n\n**思考：**\n以上就是我们今天爬虫实战的主要内容，相对来说比较简单。\n第一个项目，旨在让大家了解`爬虫流程`，同时，也可以思考一下以下几点：\n\n- 影片详细页面的短评论数据\n- 影片详细页面的获奖情况数据\n- 影片详细页面的讨论区数据\n\n以上数据的获取是否可以用`今天的获取方法`？如果不行，那应该通过什么方式获取这些数据？\n\n\n\n#### 写在后面的话\n\n今天的实战项目就结束了，需要源代码的同学可以在`公众号后台`回复 `豆瓣电影` 获取，如果觉得小一哥讲的还不错的话，不妨`点个赞`？\n\n开篇已经提到，我们的目的不是爬数据。所以，我会利用这些数据做一个简单数据分析，目的很简单：了解数据分析的流程。下期见。\n\n\n\n**碎碎念一下**\n\n> 我发现写技术文比写软文难了不止一个档次，虽然软文没啥技术含量，但是大家爱看啊。\n>\n> \n>\n> 技术性文章苦涩难懂，不过像我讲这么详细的，你确定不点个再看支持一下？\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('27', 'chenin', '人工智能', 'python学习之路', '> 点赞再看，养成好习惯\n>\n> \n>\n> Python版本3.8.0，开发工具：Pycharm\n\n\n\n#### 写在前面的话\n\n目前为止，你应该已经了解爬虫的三个基本小节：\n\n- [爬虫的原理和流程](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483880&idx=1&sn=7b3c4461cd3d2e9e26db8eb3918bff74&chksm=ec7f9a1cdb08130af14247f4be2ead36590fc96233f24028333ca8da74c5e40990979f70f43e&token=109866799&lang=zh_CN#rd)\n- [爬虫的两种实现方式](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483885&idx=1&sn=96416d5a3799864c6e1ff19c6e2c4bb9&chksm=ec7f9a19db08130f5a80c61acc196d34728ac27ec05bc558ed3ffc4e6274f5bad251d358c8a0&token=109866799&lang=zh_CN#rd)\n- [通过 BeautifulSoup 解析网页源码](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483891&idx=1&sn=a5fabdd931073088bf95d89ed0de7cb2&chksm=ec7f9a07db08131196a351d63e3170aea9889ca761ae22ed53e86dab21244eb7ef32383acec3&token=109866799&lang=zh_CN#rd)\n\n如果上面三小节还有问题，可以`点回去再复习一下`。作为基础内容并不是要求大家一定都掌握，特别是第三小节，网页解析用法特别多，一般人很难都记住。\n\n\n我在写这篇的时候也会时不时的翻回去看一看之前的文章，可能有的方法并不是最简单的方法，但是只要`达成目的`就ok，这里你们`自由发挥`。\n\n“小一哥，为什么你这里用的是 find 方法解析，我用正则表达式可以吗？”\n“当然可以啊，或许你的正则表达式实现起来更简单”\n\n\n那么，作为我们爬虫的第一个小项目，我会尽可能的`讲清楚每一步代码`，就算没讲到，也`会有注释`，不用担心跟不上看不懂。\n\n\n另外，虽然说是第一篇爬虫文章，但我还是会对爬虫的结果进行数据分析。对于项目而言比较简单，目的是让大家`了解整个分析的过程`。\n\n\n记住一点：爬虫永远不是我们的终点，最多算是我们数据分析之路的`踏板`。\n\n```\n源码获取方式在文末\n```\n\n\n\n\n\n#### 正文\n\n**明确需求**\n我们今天要爬的数据是`豆瓣电影Top250`，是的，只有250条数据，你没猜错。\n输入网址  `https://movie.douban.com/top250` 我们可以看到网页长这样：\n\n\n\n![img](https://user-gold-cdn.xitu.io/2019/12/16/16f0f0e95f8fd6fd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1179\" height=\"622\"></svg>)\n\n\n\n`250条数据`清清楚楚，没有问题。\n\n可以看到，这个页面其实已经包含了影片的`主要内容`：影片名、排序、编剧、主演、年份、类型、评论人数、评分，基本上都在这个页面中。\n但我点开`详细影片`之后，发现了这个：\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1104\" height=\"550\"></svg>)\n\n\n似乎这个页面数据更全一些，我们爬数据要的是什么，肯定是数据越多越好啊。相比这个详细内容，更是多了每个星级的影评占比，那我们肯定选择它了啊\n\n\n**好，那理一下我们的思路**\n\n\n\n\n\n- 首先，进入豆瓣电影Top250，一共10页，每页25个影片。\n\n- 然后，针对每一页的25个影片，进入其详细内容页面\n\n- 最后，解析每个影片的详细内容，保存内容到数据库中\n\n  \n  **写一下伪代码**\n\n```Python\n# 遍历10页data_movies # 保存所有影片数据集for per_page in pages:        # 爬取10页的每一页数据     movies = craw_page_info(per_page)    # 遍历每一页的25个影片    for movie in movies:        # 爬取每个影片的详细内容        data_per_movie = craw_detail_info(movie)        # 保存每个影片信息到数据集中        data_movies.append(data_per_movie)# 保存结果到数据库中data_movies_to_mysql复制代码\n```\n\n稍微解释一下：`两层循环`，第一层是遍历`10页网页`，因为其中每个网页分别有25个影片，所以，第二层循环又依次遍历`25个影片`获取详细信息，最后保存结果到数据库中！\n**是不是，很，简，单！**\n\n> 但是，实操起来你可能会遇到各种各样的问题，做好心理准备！\n\n\n\n#### 开始实操\n\n**首先，确定我们要输出的影片字段**\n`主要数据`包括：影片排序、影片名称、影片导演、影片编剧、影片主演、影片又名、影片链接\n`关键数据`包括：影片类型、制片国家、影片语言、上映日期、影片片长\n`核心数据`包括：影片评分、评论人数、5/4/3/2/1各星级对应的评论占比\n\n`字段如下`：\n\n```markdown\nmovie_rank：影片排序movie_name：影片名称movie_director：影片导演movie_writer：影片编剧movie_starring：影片主演movie_type：影片类型movie_country：影片制片国家movie_language：影片语言movie_release_date：影片上映日期movie_run_time：影片片长movie_second_name：影片又名movie_imdb_href：影片IMDb 链接movie_rating：影片总评分movie_comments_user：影片评论人数movie_five_star_ratio：影片5星占比movie_four_star_ratio：影片4星占比movie_three_star_ratio：影片3星占比movie_two_star_ratio：影片2星占比movie_one_star_ratio：影片1星占比movie_note：影片备注信息，一般为空复制代码\n```\n\n\n**然后，开始主流程**\n确认一下主要参数，起始页码（默认为0），每页影片25个，共10页，\n`参数如下`：\n\n```\nstart_page：起始页码page_size：每一页大小pages：总页码复制代码\n```\n\n\n**定义类对象**\n\n> 这里我们将每个影片封装成一个对象，传入我们的主要参数，设置爬虫头部，并建立和数据库的相关连接\n\n`类定义对象如下`：\n\n```Python\nclass DouBanMovie:    def __init__(self, url, start_page, pages, page_size):        \"\"\"        初始化        @param url: 爬取主网址        @param start_page: 起始页码        @param pages: 总页码（截止页码）        @param page_size: 每页的大小        \"\"\"        self.url = url        self.start_page = start_page        self.pages = pages        self.page_size = page_size        self.data_info = []        self.pymysql_engine, self.pymysql_session = connection_to_mysql()        self.headers = {            \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\'        }复制代码\n```\n\n“小一哥，你这里的数据库连接用的是什么啊，我怎么看不太懂？”\n“我封装了一下，数据库的连接这里选用了 SQLAlchemy。\"\n\n不要着急，以后会专门写一篇 SQLAlchemy 关于数据库的相关操作\n\n```Python\n#  创建基类,Base = declarative_base()def connection_to_mysql():    \"\"\"    连接数据库    @return:    \"\"\"    engine = create_engine(\'mysql+pymysql://username:passwd@localhost:3306/db_name?charset=utf8\')    Session = sessionmaker(bind=engine)    db_session = Session()    # 创建数据表    Base.metadata.create_all(engine)    return engine, db_session复制代码\n```\n\n\n**确定主框架：**\n\n```Python\n# 如果当前页码小于0，异常退出if self.start_page < 0:    return \"\"# 如果起始页面大于总页码数，退出if self.start_page > self.pages:    return \"\"# 若当前页其实页码小于总页数，继续爬取数据while self.start_page < pages:    # 拼接当前页的网址    # 主爬虫代码    # 下一页    self.start_page = self.start_page + 1复制代码\n```\n\n`拼接当前页的网址`这里解释一下，当我们去访问第一页的时候发现网址如下\n\n```Python\nhttps://movie.douban.com/top250复制代码\n```\n\n去访问下一页的时候发现网址变化如下\n\n```Python\nhttps://movie.douban.com/top250?start=25&filter=复制代码\n```\n\n而再下一页的网址变化如下：\n\n```Python\nhttps://movie.douban.com/top250?start=50&filter=复制代码\n```\n\n可以发现，新的网址只是`变化了后面的 start 参数`，于是我们拼接出每一页的网址：\n\n```Python\nstart_number = self.start_page * self.page_sizenew_url = self.url + \'?start=\' + str(start_number) + \'&filter=\'复制代码\n```\n\n\n\n**爬取第一个页面**\n确定好主框架之后，我们需要去爬取`第一个网页`，也就是包含`25个影片的页面`。\n这时候，我们前三节提到的爬虫实现方式直接拿过来：\n\n```Python\nself.headers = {    \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\',}# 爬取当前页码的数据response = requests.get(url=new_url, headers=self.headers)复制代码\n```\n\n成功获取到页面数据之后，我们需要`对页面解析`，拿到每一个影片`跳转详细页面的超链接`\n\n> 通过谷歌浏览器 F12 开发者工具可查看网页源码\n\n可以看到每个影片的详细信息在一个`li 标签`中，而每个 li 标签中都有一个`class=\'pic\' 的 div`，在 div 里面存在这样一个 `a 标签` 中\n\n而这个 a 标签的 href 正是我们要需要的 `详细页面信息的超链接`\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1104\"></svg>)\n\n\n\n\n确定了超链接位置所在，打开我们上一节的 BeautifulSoup 详解，定位、解析\n\n```Python\nsoup = BeautifulSoup(response.text, \'html.parser\')# 定位到每一个电影的 div （pic 标记的 div）soup_div_list = soup.find_all(class_=\"pic\")# 遍历获取每一个 div 的电影详情链接for soup_div in soup_div_list:    # 定位到每一个电影的 a 标签    soup_a = soup_div.find_all(\'a\')[0]    movie_href = soup_a.get(\'href\')    print(movie_href)复制代码\n```\n\n拿到当前页面的25 个影片的详细内容的超链接\n\n```\n我们离成功又进了一步！\n```\n\n\n**爬取详细页面**\n同样，一行代码拿下页面数据\n\n```Python\n\'\'\'爬取页面，获得详细数据\'\'\'response = requests.get(url=movie_detail_href, headers=self.headers)复制代码\n```\n\n创建一个有序字典，保存当前影片数据\n\n```Python\n# 生成一个有序字典，保存影片结果movie_info = OrderedDict()复制代码\n```\n\n我们再来看一下这个页面的的源码是什么样的，首先是影片排序和影片名称，我们可以从上个页面传递过来。但是，既然它这里有，我直接解析行不行？\n\n必须行啊！\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1227\"></svg>)\n\n\n\n这个更简单，影片排名直接定位一个 `class=\'top250-no\' 的 span 标签`，影片名称定位一个 `property=\'v:itemreviewed\' 的 span 标签`，获取标签内容即可\n\n```Python\n# 解析电影排名和名称movie_info[\'movie_rank\'] = soup.find_all(\'span\', class_=\'top250-no\')[0].stringmovie_info[\'movie_name\'] = soup.find_all(\'span\', property=\'v:itemreviewed\')[0].string复制代码\n```\n\n\n\n**接下来是影片主要数据**：\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1235\" height=\"1280\"></svg>)\n\n\n\n这个时候我们需要先定位到 `id=\'info\' 的 div`中，然后可以看到`整个 div 的数据`就是我们需要的主要数据。\n\n```Python\n# 定位到影片数据的 divsoup_div = soup.find(id=\'info\')复制代码\n```\n\n“不对啊，小一哥，我发现编剧有时候是一个，有时候是多个。多个的时候存在在多个 span 标签中，这个怎么办啊？”\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"698\" height=\"318\"></svg>)\n\n\n\n“这个简单，我写一个小函数，统一处理一下。“\n\n```Python\ndef get_mul_tag_info(self, soup_span):    \"\"\"    获取多个标签的结果合并在一个结果中返回，并用 / 分割    \"\"\"    info = \'\'    for second_span in soup_span:        # 区分 href 和标签内容        info = (\'\' if (info == \'\') else \'/\').join((info, second_span.string))    return info复制代码\n```\n\n“对了，你记得把最外层的 span 标签给我就行。像这种：”\n\n```Python\n# 解析电影发布信息movie_info[\'movie_director\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[0].find_all(\'a\'))movie_info[\'movie_writer\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[3].find_all(\'a\'))movie_info[\'movie_starring\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[6].find_all(\'a\'))movie_info[\'movie_type\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:genre\'))movie_info[\'movie_country\'] = soup_div.find(text=\'制片国家/地区:\').next_element.lstrip().rstrip()movie_info[\'movie_language\'] = soup_div.find(text=\'语言:\').next_element.lstrip().rstrip()movie_info[\'movie_release_date\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:initialReleaseDate\'))movie_info[\'movie_run_time\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:runtime\'))movie_info[\'movie_imdb_href\'] = soup_div.find(\'a\', target=\'_blank\')[\'href\']复制代码\n```\n\n“小一哥，又出问题了，有的影片没有`又名`标签，这个怎么处理呢？”\n“这个我们做个异常检测，没有的手动赋空值就行了。”\n\n```Python\nmovie_second_name = \'\'try:    movie_second_name = soup_div.find(text=\'又名:\').next_element.lstrip().rstrip()except AttributeError:    print(\'{0} 没有又名\'.format(movie_info[\'movie_name\']))    movie_info[\'movie_second_name\'] = movie_second_name复制代码\n```\n\n**最后还剩下评分数据**\n评分数据不但有总评分，还有每个星级的评分。\n\n“小一哥，你说我们取哪个数据啊？”\n“小孩才做选择，我当然是全部都要！”\n\n\n\n![img](https://user-gold-cdn.xitu.io/2019/12/16/16f0f12c7178cc95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n\n\n可以看到，总评分和总评论人数分别有一个`唯一的 property`，分别是`property=\'v:average\' 的 strong 标签`和 `property=\'v:votes\' 的 span 标签`\n\nok，接下来直接拿数据：\n\n```Python\n# 获取总评分和总评价人数movie_info[\'movie_rating\'] = soup.find_all(\'strong\', property=\'v:average\')[0].stringmovie_info[\'movie_comments_user\'] = soup.find_all(\'span\', property=\'v:votes\')[0].string复制代码\n```\n\n\n\n最后就剩下`每个星级的评分占比`，可以看到 `5星/4星/3星/2星/1星` 分别对应 `力荐/推荐/还行/较差/很差`，可以看到他们都存在在一个`class=\'ratings-on-weight\' 的 div`中\n\n所以，先定位 div ：\n\n```Python\n# 定位到影片星级评分占比的 divsoup_div = soup.find(\'div\', class_=\"ratings-on-weight\")复制代码\n```\n\n然后获取每个星级评分占比数据：\n\n```Python\n# 获取每个星级的评分movie_info[\'movie_five_star_ratio\'] = soup_div.find_all(\'div\')[0].find(class_=\'rating_per\').stringmovie_info[\'movie_four_star_ratio\'] = soup_div.find_all(\'div\')[2].find(class_=\'rating_per\').stringmovie_info[\'movie_three_star_ratio\'] = soup_div.find_all(\'div\')[4].find(class_=\'rating_per\').stringmovie_info[\'movie_two_star_ratio\'] = soup_div.find_all(\'div\')[6].find(class_=\'rating_per\').stringmovie_info[\'movie_one_star_ratio\'] = soup_div.find_all(\'div\')[8].find(class_=\'rating_per\').string复制代码\n```\n\n打印一下看一下我们`当前的影片`数据：\n\n> 对 movie_starring 字段只输出部分显示\n\n```Python\nOrderedDict(    [        (\'movie_rank\', \'No.1\'),         (\'movie_name\', \'肖申克的救赎 The Shawshank Redemption\'),         (\'movie_director\', \'弗兰克·德拉邦特\'),         (\'movie_writer\', \'弗兰克·德拉邦特/斯蒂芬·金\'),         (\'movie_starring\', \'蒂姆·罗宾斯/摩根·弗里曼/鲍勃·冈顿/威廉姆·赛德勒/),         (\'movie_type\', \'剧情/犯罪\'),         (\'movie_country\', \'美国\'),         (\'movie_language\', \'英语\'),         (\'movie_release_date\', \'1994-09-10(多伦多电影节)/1994-10-14(美国)\'),         (\'movie_run_time\', \'142分钟\'),         (\'movie_imdb_href\', \'https://www.imdb.com/title/tt0111161\'),         (\'movie_rating\', \'9.7\'),         (\'movie_comments_user\', \'1720706\'),         (\'movie_five_star_ratio\', \'84.8%\'),         (\'movie_four_star_ratio\', \'13.6%\'),         (\'movie_three_star_ratio\', \'1.4%\'),         (\'movie_two_star_ratio\', \'0.1%\'),         (\'movie_one_star_ratio\', \'0.1%\'),         (\'movie_note\', \'\')    ])复制代码\n```\n\n搞定，成功拿到了想要的数据，最后一步：`保存数据库`\n\n```python\n# 保存当前影片信息self.data_info.append(movie_info)# 获取数据并保存成 DataFramedf_data = pd.DataFrame(self.data_info)# 导入数据到 mysql 中df_data.to_sql(\'t_douban_movie_top_250\', self.pymysql_engine, index=False, if_exists=\'append\')复制代码\n```\n\n看一眼我们的数据库，该有的数据都存进去了\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"507\"></svg>)\n\n\n\n`到这里，爬虫就算是结束了`。\n\n\n\n\n\n#### 总结一下：\n\n**准备工作：**\n\n- 首先我们定义了一个影片对象，传入了网址的参数信息，设置了爬虫头部，并建立了数据库连接\n- 我们通过下一页分析出每个影片页的超链接，发现只是改变了参数\n- 建立了主流程，并写出了主流程的伪代码\n\n\n\n**开始爬虫：**\n\n- 爬取`第一页`的网页内容\n- 解析`第一页`的内容，获取每页中25个影片的详细超链接\n- 爬取`详细影片`的网页内容\n- 解析`第二页`的内容，保存到每个影片对象中\n- `保存数据`到数据库中\n\n\n\n**思考：**\n以上就是我们今天爬虫实战的主要内容，相对来说比较简单。\n第一个项目，旨在让大家了解`爬虫流程`，同时，也可以思考一下以下几点：\n\n- 影片详细页面的短评论数据\n- 影片详细页面的获奖情况数据\n- 影片详细页面的讨论区数据\n\n以上数据的获取是否可以用`今天的获取方法`？如果不行，那应该通过什么方式获取这些数据？\n\n\n\n#### 写在后面的话\n\n今天的实战项目就结束了，需要源代码的同学可以在`公众号后台`回复 `豆瓣电影` 获取，如果觉得小一哥讲的还不错的话，不妨`点个赞`？\n\n开篇已经提到，我们的目的不是爬数据。所以，我会利用这些数据做一个简单数据分析，目的很简单：了解数据分析的流程。下期见。\n\n\n\n**碎碎念一下**\n\n> 我发现写技术文比写软文难了不止一个档次，虽然软文没啥技术含量，但是大家爱看啊。\n>\n> \n>\n> 技术性文章苦涩难懂，不过像我讲这么详细的，你确定不点个再看支持一下？\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('28', 'chenin', '人工智能', '数据挖掘', '> 点赞再看，养成好习惯\n>\n> \n>\n> Python版本3.8.0，开发工具：Pycharm\n\n\n\n#### 写在前面的话\n\n目前为止，你应该已经了解爬虫的三个基本小节：\n\n- [爬虫的原理和流程](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483880&idx=1&sn=7b3c4461cd3d2e9e26db8eb3918bff74&chksm=ec7f9a1cdb08130af14247f4be2ead36590fc96233f24028333ca8da74c5e40990979f70f43e&token=109866799&lang=zh_CN#rd)\n- [爬虫的两种实现方式](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483885&idx=1&sn=96416d5a3799864c6e1ff19c6e2c4bb9&chksm=ec7f9a19db08130f5a80c61acc196d34728ac27ec05bc558ed3ffc4e6274f5bad251d358c8a0&token=109866799&lang=zh_CN#rd)\n- [通过 BeautifulSoup 解析网页源码](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483891&idx=1&sn=a5fabdd931073088bf95d89ed0de7cb2&chksm=ec7f9a07db08131196a351d63e3170aea9889ca761ae22ed53e86dab21244eb7ef32383acec3&token=109866799&lang=zh_CN#rd)\n\n如果上面三小节还有问题，可以`点回去再复习一下`。作为基础内容并不是要求大家一定都掌握，特别是第三小节，网页解析用法特别多，一般人很难都记住。\n\n\n我在写这篇的时候也会时不时的翻回去看一看之前的文章，可能有的方法并不是最简单的方法，但是只要`达成目的`就ok，这里你们`自由发挥`。\n\n“小一哥，为什么你这里用的是 find 方法解析，我用正则表达式可以吗？”\n“当然可以啊，或许你的正则表达式实现起来更简单”\n\n\n那么，作为我们爬虫的第一个小项目，我会尽可能的`讲清楚每一步代码`，就算没讲到，也`会有注释`，不用担心跟不上看不懂。\n\n\n另外，虽然说是第一篇爬虫文章，但我还是会对爬虫的结果进行数据分析。对于项目而言比较简单，目的是让大家`了解整个分析的过程`。\n\n\n记住一点：爬虫永远不是我们的终点，最多算是我们数据分析之路的`踏板`。\n\n```\n源码获取方式在文末\n```\n\n\n\n\n\n#### 正文\n\n**明确需求**\n我们今天要爬的数据是`豆瓣电影Top250`，是的，只有250条数据，你没猜错。\n输入网址  `https://movie.douban.com/top250` 我们可以看到网页长这样：\n\n\n\n![img](https://user-gold-cdn.xitu.io/2019/12/16/16f0f0e95f8fd6fd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1179\" height=\"622\"></svg>)\n\n\n\n`250条数据`清清楚楚，没有问题。\n\n可以看到，这个页面其实已经包含了影片的`主要内容`：影片名、排序、编剧、主演、年份、类型、评论人数、评分，基本上都在这个页面中。\n但我点开`详细影片`之后，发现了这个：\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1104\" height=\"550\"></svg>)\n\n\n似乎这个页面数据更全一些，我们爬数据要的是什么，肯定是数据越多越好啊。相比这个详细内容，更是多了每个星级的影评占比，那我们肯定选择它了啊\n\n\n**好，那理一下我们的思路**\n\n\n\n\n\n- 首先，进入豆瓣电影Top250，一共10页，每页25个影片。\n\n- 然后，针对每一页的25个影片，进入其详细内容页面\n\n- 最后，解析每个影片的详细内容，保存内容到数据库中\n\n  \n  **写一下伪代码**\n\n```Python\n# 遍历10页data_movies # 保存所有影片数据集for per_page in pages:        # 爬取10页的每一页数据     movies = craw_page_info(per_page)    # 遍历每一页的25个影片    for movie in movies:        # 爬取每个影片的详细内容        data_per_movie = craw_detail_info(movie)        # 保存每个影片信息到数据集中        data_movies.append(data_per_movie)# 保存结果到数据库中data_movies_to_mysql复制代码\n```\n\n稍微解释一下：`两层循环`，第一层是遍历`10页网页`，因为其中每个网页分别有25个影片，所以，第二层循环又依次遍历`25个影片`获取详细信息，最后保存结果到数据库中！\n**是不是，很，简，单！**\n\n> 但是，实操起来你可能会遇到各种各样的问题，做好心理准备！\n\n\n\n#### 开始实操\n\n**首先，确定我们要输出的影片字段**\n`主要数据`包括：影片排序、影片名称、影片导演、影片编剧、影片主演、影片又名、影片链接\n`关键数据`包括：影片类型、制片国家、影片语言、上映日期、影片片长\n`核心数据`包括：影片评分、评论人数、5/4/3/2/1各星级对应的评论占比\n\n`字段如下`：\n\n```markdown\nmovie_rank：影片排序movie_name：影片名称movie_director：影片导演movie_writer：影片编剧movie_starring：影片主演movie_type：影片类型movie_country：影片制片国家movie_language：影片语言movie_release_date：影片上映日期movie_run_time：影片片长movie_second_name：影片又名movie_imdb_href：影片IMDb 链接movie_rating：影片总评分movie_comments_user：影片评论人数movie_five_star_ratio：影片5星占比movie_four_star_ratio：影片4星占比movie_three_star_ratio：影片3星占比movie_two_star_ratio：影片2星占比movie_one_star_ratio：影片1星占比movie_note：影片备注信息，一般为空复制代码\n```\n\n\n**然后，开始主流程**\n确认一下主要参数，起始页码（默认为0），每页影片25个，共10页，\n`参数如下`：\n\n```\nstart_page：起始页码page_size：每一页大小pages：总页码复制代码\n```\n\n\n**定义类对象**\n\n> 这里我们将每个影片封装成一个对象，传入我们的主要参数，设置爬虫头部，并建立和数据库的相关连接\n\n`类定义对象如下`：\n\n```Python\nclass DouBanMovie:    def __init__(self, url, start_page, pages, page_size):        \"\"\"        初始化        @param url: 爬取主网址        @param start_page: 起始页码        @param pages: 总页码（截止页码）        @param page_size: 每页的大小        \"\"\"        self.url = url        self.start_page = start_page        self.pages = pages        self.page_size = page_size        self.data_info = []        self.pymysql_engine, self.pymysql_session = connection_to_mysql()        self.headers = {            \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\'        }复制代码\n```\n\n“小一哥，你这里的数据库连接用的是什么啊，我怎么看不太懂？”\n“我封装了一下，数据库的连接这里选用了 SQLAlchemy。\"\n\n不要着急，以后会专门写一篇 SQLAlchemy 关于数据库的相关操作\n\n```Python\n#  创建基类,Base = declarative_base()def connection_to_mysql():    \"\"\"    连接数据库    @return:    \"\"\"    engine = create_engine(\'mysql+pymysql://username:passwd@localhost:3306/db_name?charset=utf8\')    Session = sessionmaker(bind=engine)    db_session = Session()    # 创建数据表    Base.metadata.create_all(engine)    return engine, db_session复制代码\n```\n\n\n**确定主框架：**\n\n```Python\n# 如果当前页码小于0，异常退出if self.start_page < 0:    return \"\"# 如果起始页面大于总页码数，退出if self.start_page > self.pages:    return \"\"# 若当前页其实页码小于总页数，继续爬取数据while self.start_page < pages:    # 拼接当前页的网址    # 主爬虫代码    # 下一页    self.start_page = self.start_page + 1复制代码\n```\n\n`拼接当前页的网址`这里解释一下，当我们去访问第一页的时候发现网址如下\n\n```Python\nhttps://movie.douban.com/top250复制代码\n```\n\n去访问下一页的时候发现网址变化如下\n\n```Python\nhttps://movie.douban.com/top250?start=25&filter=复制代码\n```\n\n而再下一页的网址变化如下：\n\n```Python\nhttps://movie.douban.com/top250?start=50&filter=复制代码\n```\n\n可以发现，新的网址只是`变化了后面的 start 参数`，于是我们拼接出每一页的网址：\n\n```Python\nstart_number = self.start_page * self.page_sizenew_url = self.url + \'?start=\' + str(start_number) + \'&filter=\'复制代码\n```\n\n\n\n**爬取第一个页面**\n确定好主框架之后，我们需要去爬取`第一个网页`，也就是包含`25个影片的页面`。\n这时候，我们前三节提到的爬虫实现方式直接拿过来：\n\n```Python\nself.headers = {    \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\',}# 爬取当前页码的数据response = requests.get(url=new_url, headers=self.headers)复制代码\n```\n\n成功获取到页面数据之后，我们需要`对页面解析`，拿到每一个影片`跳转详细页面的超链接`\n\n> 通过谷歌浏览器 F12 开发者工具可查看网页源码\n\n可以看到每个影片的详细信息在一个`li 标签`中，而每个 li 标签中都有一个`class=\'pic\' 的 div`，在 div 里面存在这样一个 `a 标签` 中\n\n而这个 a 标签的 href 正是我们要需要的 `详细页面信息的超链接`\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1104\"></svg>)\n\n\n\n\n确定了超链接位置所在，打开我们上一节的 BeautifulSoup 详解，定位、解析\n\n```Python\nsoup = BeautifulSoup(response.text, \'html.parser\')# 定位到每一个电影的 div （pic 标记的 div）soup_div_list = soup.find_all(class_=\"pic\")# 遍历获取每一个 div 的电影详情链接for soup_div in soup_div_list:    # 定位到每一个电影的 a 标签    soup_a = soup_div.find_all(\'a\')[0]    movie_href = soup_a.get(\'href\')    print(movie_href)复制代码\n```\n\n拿到当前页面的25 个影片的详细内容的超链接\n\n```\n我们离成功又进了一步！\n```\n\n\n**爬取详细页面**\n同样，一行代码拿下页面数据\n\n```Python\n\'\'\'爬取页面，获得详细数据\'\'\'response = requests.get(url=movie_detail_href, headers=self.headers)复制代码\n```\n\n创建一个有序字典，保存当前影片数据\n\n```Python\n# 生成一个有序字典，保存影片结果movie_info = OrderedDict()复制代码\n```\n\n我们再来看一下这个页面的的源码是什么样的，首先是影片排序和影片名称，我们可以从上个页面传递过来。但是，既然它这里有，我直接解析行不行？\n\n必须行啊！\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1227\"></svg>)\n\n\n\n这个更简单，影片排名直接定位一个 `class=\'top250-no\' 的 span 标签`，影片名称定位一个 `property=\'v:itemreviewed\' 的 span 标签`，获取标签内容即可\n\n```Python\n# 解析电影排名和名称movie_info[\'movie_rank\'] = soup.find_all(\'span\', class_=\'top250-no\')[0].stringmovie_info[\'movie_name\'] = soup.find_all(\'span\', property=\'v:itemreviewed\')[0].string复制代码\n```\n\n\n\n**接下来是影片主要数据**：\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1235\" height=\"1280\"></svg>)\n\n\n\n这个时候我们需要先定位到 `id=\'info\' 的 div`中，然后可以看到`整个 div 的数据`就是我们需要的主要数据。\n\n```Python\n# 定位到影片数据的 divsoup_div = soup.find(id=\'info\')复制代码\n```\n\n“不对啊，小一哥，我发现编剧有时候是一个，有时候是多个。多个的时候存在在多个 span 标签中，这个怎么办啊？”\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"698\" height=\"318\"></svg>)\n\n\n\n“这个简单，我写一个小函数，统一处理一下。“\n\n```Python\ndef get_mul_tag_info(self, soup_span):    \"\"\"    获取多个标签的结果合并在一个结果中返回，并用 / 分割    \"\"\"    info = \'\'    for second_span in soup_span:        # 区分 href 和标签内容        info = (\'\' if (info == \'\') else \'/\').join((info, second_span.string))    return info复制代码\n```\n\n“对了，你记得把最外层的 span 标签给我就行。像这种：”\n\n```Python\n# 解析电影发布信息movie_info[\'movie_director\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[0].find_all(\'a\'))movie_info[\'movie_writer\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[3].find_all(\'a\'))movie_info[\'movie_starring\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[6].find_all(\'a\'))movie_info[\'movie_type\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:genre\'))movie_info[\'movie_country\'] = soup_div.find(text=\'制片国家/地区:\').next_element.lstrip().rstrip()movie_info[\'movie_language\'] = soup_div.find(text=\'语言:\').next_element.lstrip().rstrip()movie_info[\'movie_release_date\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:initialReleaseDate\'))movie_info[\'movie_run_time\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:runtime\'))movie_info[\'movie_imdb_href\'] = soup_div.find(\'a\', target=\'_blank\')[\'href\']复制代码\n```\n\n“小一哥，又出问题了，有的影片没有`又名`标签，这个怎么处理呢？”\n“这个我们做个异常检测，没有的手动赋空值就行了。”\n\n```Python\nmovie_second_name = \'\'try:    movie_second_name = soup_div.find(text=\'又名:\').next_element.lstrip().rstrip()except AttributeError:    print(\'{0} 没有又名\'.format(movie_info[\'movie_name\']))    movie_info[\'movie_second_name\'] = movie_second_name复制代码\n```\n\n**最后还剩下评分数据**\n评分数据不但有总评分，还有每个星级的评分。\n\n“小一哥，你说我们取哪个数据啊？”\n“小孩才做选择，我当然是全部都要！”\n\n\n\n![img](https://user-gold-cdn.xitu.io/2019/12/16/16f0f12c7178cc95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n\n\n可以看到，总评分和总评论人数分别有一个`唯一的 property`，分别是`property=\'v:average\' 的 strong 标签`和 `property=\'v:votes\' 的 span 标签`\n\nok，接下来直接拿数据：\n\n```Python\n# 获取总评分和总评价人数movie_info[\'movie_rating\'] = soup.find_all(\'strong\', property=\'v:average\')[0].stringmovie_info[\'movie_comments_user\'] = soup.find_all(\'span\', property=\'v:votes\')[0].string复制代码\n```\n\n\n\n最后就剩下`每个星级的评分占比`，可以看到 `5星/4星/3星/2星/1星` 分别对应 `力荐/推荐/还行/较差/很差`，可以看到他们都存在在一个`class=\'ratings-on-weight\' 的 div`中\n\n所以，先定位 div ：\n\n```Python\n# 定位到影片星级评分占比的 divsoup_div = soup.find(\'div\', class_=\"ratings-on-weight\")复制代码\n```\n\n然后获取每个星级评分占比数据：\n\n```Python\n# 获取每个星级的评分movie_info[\'movie_five_star_ratio\'] = soup_div.find_all(\'div\')[0].find(class_=\'rating_per\').stringmovie_info[\'movie_four_star_ratio\'] = soup_div.find_all(\'div\')[2].find(class_=\'rating_per\').stringmovie_info[\'movie_three_star_ratio\'] = soup_div.find_all(\'div\')[4].find(class_=\'rating_per\').stringmovie_info[\'movie_two_star_ratio\'] = soup_div.find_all(\'div\')[6].find(class_=\'rating_per\').stringmovie_info[\'movie_one_star_ratio\'] = soup_div.find_all(\'div\')[8].find(class_=\'rating_per\').string复制代码\n```\n\n打印一下看一下我们`当前的影片`数据：\n\n> 对 movie_starring 字段只输出部分显示\n\n```Python\nOrderedDict(    [        (\'movie_rank\', \'No.1\'),         (\'movie_name\', \'肖申克的救赎 The Shawshank Redemption\'),         (\'movie_director\', \'弗兰克·德拉邦特\'),         (\'movie_writer\', \'弗兰克·德拉邦特/斯蒂芬·金\'),         (\'movie_starring\', \'蒂姆·罗宾斯/摩根·弗里曼/鲍勃·冈顿/威廉姆·赛德勒/),         (\'movie_type\', \'剧情/犯罪\'),         (\'movie_country\', \'美国\'),         (\'movie_language\', \'英语\'),         (\'movie_release_date\', \'1994-09-10(多伦多电影节)/1994-10-14(美国)\'),         (\'movie_run_time\', \'142分钟\'),         (\'movie_imdb_href\', \'https://www.imdb.com/title/tt0111161\'),         (\'movie_rating\', \'9.7\'),         (\'movie_comments_user\', \'1720706\'),         (\'movie_five_star_ratio\', \'84.8%\'),         (\'movie_four_star_ratio\', \'13.6%\'),         (\'movie_three_star_ratio\', \'1.4%\'),         (\'movie_two_star_ratio\', \'0.1%\'),         (\'movie_one_star_ratio\', \'0.1%\'),         (\'movie_note\', \'\')    ])复制代码\n```\n\n搞定，成功拿到了想要的数据，最后一步：`保存数据库`\n\n```python\n# 保存当前影片信息self.data_info.append(movie_info)# 获取数据并保存成 DataFramedf_data = pd.DataFrame(self.data_info)# 导入数据到 mysql 中df_data.to_sql(\'t_douban_movie_top_250\', self.pymysql_engine, index=False, if_exists=\'append\')复制代码\n```\n\n看一眼我们的数据库，该有的数据都存进去了\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"507\"></svg>)\n\n\n\n`到这里，爬虫就算是结束了`。\n\n\n\n\n\n#### 总结一下：\n\n**准备工作：**\n\n- 首先我们定义了一个影片对象，传入了网址的参数信息，设置了爬虫头部，并建立了数据库连接\n- 我们通过下一页分析出每个影片页的超链接，发现只是改变了参数\n- 建立了主流程，并写出了主流程的伪代码\n\n\n\n**开始爬虫：**\n\n- 爬取`第一页`的网页内容\n- 解析`第一页`的内容，获取每页中25个影片的详细超链接\n- 爬取`详细影片`的网页内容\n- 解析`第二页`的内容，保存到每个影片对象中\n- `保存数据`到数据库中\n\n\n\n**思考：**\n以上就是我们今天爬虫实战的主要内容，相对来说比较简单。\n第一个项目，旨在让大家了解`爬虫流程`，同时，也可以思考一下以下几点：\n\n- 影片详细页面的短评论数据\n- 影片详细页面的获奖情况数据\n- 影片详细页面的讨论区数据\n\n以上数据的获取是否可以用`今天的获取方法`？如果不行，那应该通过什么方式获取这些数据？\n\n\n\n#### 写在后面的话\n\n今天的实战项目就结束了，需要源代码的同学可以在`公众号后台`回复 `豆瓣电影` 获取，如果觉得小一哥讲的还不错的话，不妨`点个赞`？\n\n开篇已经提到，我们的目的不是爬数据。所以，我会利用这些数据做一个简单数据分析，目的很简单：了解数据分析的流程。下期见。\n\n\n\n**碎碎念一下**\n\n> 我发现写技术文比写软文难了不止一个档次，虽然软文没啥技术含量，但是大家爱看啊。\n>\n> \n>\n> 技术性文章苦涩难懂，不过像我讲这么详细的，你确定不点个再看支持一下？\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('29', 'chenin', '人工智能', '爬虫技术', '> 点赞再看，养成好习惯\n>\n> \n>\n> Python版本3.8.0，开发工具：Pycharm\n\n\n\n#### 写在前面的话\n\n目前为止，你应该已经了解爬虫的三个基本小节：\n\n- [爬虫的原理和流程](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483880&idx=1&sn=7b3c4461cd3d2e9e26db8eb3918bff74&chksm=ec7f9a1cdb08130af14247f4be2ead36590fc96233f24028333ca8da74c5e40990979f70f43e&token=109866799&lang=zh_CN#rd)\n- [爬虫的两种实现方式](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483885&idx=1&sn=96416d5a3799864c6e1ff19c6e2c4bb9&chksm=ec7f9a19db08130f5a80c61acc196d34728ac27ec05bc558ed3ffc4e6274f5bad251d358c8a0&token=109866799&lang=zh_CN#rd)\n- [通过 BeautifulSoup 解析网页源码](https://mp.weixin.qq.com/s?__biz=MzI5MjYwNTU5NQ==&mid=2247483891&idx=1&sn=a5fabdd931073088bf95d89ed0de7cb2&chksm=ec7f9a07db08131196a351d63e3170aea9889ca761ae22ed53e86dab21244eb7ef32383acec3&token=109866799&lang=zh_CN#rd)\n\n如果上面三小节还有问题，可以`点回去再复习一下`。作为基础内容并不是要求大家一定都掌握，特别是第三小节，网页解析用法特别多，一般人很难都记住。\n\n\n我在写这篇的时候也会时不时的翻回去看一看之前的文章，可能有的方法并不是最简单的方法，但是只要`达成目的`就ok，这里你们`自由发挥`。\n\n“小一哥，为什么你这里用的是 find 方法解析，我用正则表达式可以吗？”\n“当然可以啊，或许你的正则表达式实现起来更简单”\n\n\n那么，作为我们爬虫的第一个小项目，我会尽可能的`讲清楚每一步代码`，就算没讲到，也`会有注释`，不用担心跟不上看不懂。\n\n\n另外，虽然说是第一篇爬虫文章，但我还是会对爬虫的结果进行数据分析。对于项目而言比较简单，目的是让大家`了解整个分析的过程`。\n\n\n记住一点：爬虫永远不是我们的终点，最多算是我们数据分析之路的`踏板`。\n\n```\n源码获取方式在文末\n```\n\n\n\n\n\n#### 正文\n\n**明确需求**\n我们今天要爬的数据是`豆瓣电影Top250`，是的，只有250条数据，你没猜错。\n输入网址  `https://movie.douban.com/top250` 我们可以看到网页长这样：\n\n\n\n![img](https://user-gold-cdn.xitu.io/2019/12/16/16f0f0e95f8fd6fd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1179\" height=\"622\"></svg>)\n\n\n\n`250条数据`清清楚楚，没有问题。\n\n可以看到，这个页面其实已经包含了影片的`主要内容`：影片名、排序、编剧、主演、年份、类型、评论人数、评分，基本上都在这个页面中。\n但我点开`详细影片`之后，发现了这个：\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1104\" height=\"550\"></svg>)\n\n\n似乎这个页面数据更全一些，我们爬数据要的是什么，肯定是数据越多越好啊。相比这个详细内容，更是多了每个星级的影评占比，那我们肯定选择它了啊\n\n\n**好，那理一下我们的思路**\n\n\n\n\n\n- 首先，进入豆瓣电影Top250，一共10页，每页25个影片。\n\n- 然后，针对每一页的25个影片，进入其详细内容页面\n\n- 最后，解析每个影片的详细内容，保存内容到数据库中\n\n  \n  **写一下伪代码**\n\n```Python\n# 遍历10页data_movies # 保存所有影片数据集for per_page in pages:        # 爬取10页的每一页数据     movies = craw_page_info(per_page)    # 遍历每一页的25个影片    for movie in movies:        # 爬取每个影片的详细内容        data_per_movie = craw_detail_info(movie)        # 保存每个影片信息到数据集中        data_movies.append(data_per_movie)# 保存结果到数据库中data_movies_to_mysql复制代码\n```\n\n稍微解释一下：`两层循环`，第一层是遍历`10页网页`，因为其中每个网页分别有25个影片，所以，第二层循环又依次遍历`25个影片`获取详细信息，最后保存结果到数据库中！\n**是不是，很，简，单！**\n\n> 但是，实操起来你可能会遇到各种各样的问题，做好心理准备！\n\n\n\n#### 开始实操\n\n**首先，确定我们要输出的影片字段**\n`主要数据`包括：影片排序、影片名称、影片导演、影片编剧、影片主演、影片又名、影片链接\n`关键数据`包括：影片类型、制片国家、影片语言、上映日期、影片片长\n`核心数据`包括：影片评分、评论人数、5/4/3/2/1各星级对应的评论占比\n\n`字段如下`：\n\n```markdown\nmovie_rank：影片排序movie_name：影片名称movie_director：影片导演movie_writer：影片编剧movie_starring：影片主演movie_type：影片类型movie_country：影片制片国家movie_language：影片语言movie_release_date：影片上映日期movie_run_time：影片片长movie_second_name：影片又名movie_imdb_href：影片IMDb 链接movie_rating：影片总评分movie_comments_user：影片评论人数movie_five_star_ratio：影片5星占比movie_four_star_ratio：影片4星占比movie_three_star_ratio：影片3星占比movie_two_star_ratio：影片2星占比movie_one_star_ratio：影片1星占比movie_note：影片备注信息，一般为空复制代码\n```\n\n\n**然后，开始主流程**\n确认一下主要参数，起始页码（默认为0），每页影片25个，共10页，\n`参数如下`：\n\n```\nstart_page：起始页码page_size：每一页大小pages：总页码复制代码\n```\n\n\n**定义类对象**\n\n> 这里我们将每个影片封装成一个对象，传入我们的主要参数，设置爬虫头部，并建立和数据库的相关连接\n\n`类定义对象如下`：\n\n```Python\nclass DouBanMovie:    def __init__(self, url, start_page, pages, page_size):        \"\"\"        初始化        @param url: 爬取主网址        @param start_page: 起始页码        @param pages: 总页码（截止页码）        @param page_size: 每页的大小        \"\"\"        self.url = url        self.start_page = start_page        self.pages = pages        self.page_size = page_size        self.data_info = []        self.pymysql_engine, self.pymysql_session = connection_to_mysql()        self.headers = {            \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\'        }复制代码\n```\n\n“小一哥，你这里的数据库连接用的是什么啊，我怎么看不太懂？”\n“我封装了一下，数据库的连接这里选用了 SQLAlchemy。\"\n\n不要着急，以后会专门写一篇 SQLAlchemy 关于数据库的相关操作\n\n```Python\n#  创建基类,Base = declarative_base()def connection_to_mysql():    \"\"\"    连接数据库    @return:    \"\"\"    engine = create_engine(\'mysql+pymysql://username:passwd@localhost:3306/db_name?charset=utf8\')    Session = sessionmaker(bind=engine)    db_session = Session()    # 创建数据表    Base.metadata.create_all(engine)    return engine, db_session复制代码\n```\n\n\n**确定主框架：**\n\n```Python\n# 如果当前页码小于0，异常退出if self.start_page < 0:    return \"\"# 如果起始页面大于总页码数，退出if self.start_page > self.pages:    return \"\"# 若当前页其实页码小于总页数，继续爬取数据while self.start_page < pages:    # 拼接当前页的网址    # 主爬虫代码    # 下一页    self.start_page = self.start_page + 1复制代码\n```\n\n`拼接当前页的网址`这里解释一下，当我们去访问第一页的时候发现网址如下\n\n```Python\nhttps://movie.douban.com/top250复制代码\n```\n\n去访问下一页的时候发现网址变化如下\n\n```Python\nhttps://movie.douban.com/top250?start=25&filter=复制代码\n```\n\n而再下一页的网址变化如下：\n\n```Python\nhttps://movie.douban.com/top250?start=50&filter=复制代码\n```\n\n可以发现，新的网址只是`变化了后面的 start 参数`，于是我们拼接出每一页的网址：\n\n```Python\nstart_number = self.start_page * self.page_sizenew_url = self.url + \'?start=\' + str(start_number) + \'&filter=\'复制代码\n```\n\n\n\n**爬取第一个页面**\n确定好主框架之后，我们需要去爬取`第一个网页`，也就是包含`25个影片的页面`。\n这时候，我们前三节提到的爬虫实现方式直接拿过来：\n\n```Python\nself.headers = {    \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\',}# 爬取当前页码的数据response = requests.get(url=new_url, headers=self.headers)复制代码\n```\n\n成功获取到页面数据之后，我们需要`对页面解析`，拿到每一个影片`跳转详细页面的超链接`\n\n> 通过谷歌浏览器 F12 开发者工具可查看网页源码\n\n可以看到每个影片的详细信息在一个`li 标签`中，而每个 li 标签中都有一个`class=\'pic\' 的 div`，在 div 里面存在这样一个 `a 标签` 中\n\n而这个 a 标签的 href 正是我们要需要的 `详细页面信息的超链接`\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1104\"></svg>)\n\n\n\n\n确定了超链接位置所在，打开我们上一节的 BeautifulSoup 详解，定位、解析\n\n```Python\nsoup = BeautifulSoup(response.text, \'html.parser\')# 定位到每一个电影的 div （pic 标记的 div）soup_div_list = soup.find_all(class_=\"pic\")# 遍历获取每一个 div 的电影详情链接for soup_div in soup_div_list:    # 定位到每一个电影的 a 标签    soup_a = soup_div.find_all(\'a\')[0]    movie_href = soup_a.get(\'href\')    print(movie_href)复制代码\n```\n\n拿到当前页面的25 个影片的详细内容的超链接\n\n```\n我们离成功又进了一步！\n```\n\n\n**爬取详细页面**\n同样，一行代码拿下页面数据\n\n```Python\n\'\'\'爬取页面，获得详细数据\'\'\'response = requests.get(url=movie_detail_href, headers=self.headers)复制代码\n```\n\n创建一个有序字典，保存当前影片数据\n\n```Python\n# 生成一个有序字典，保存影片结果movie_info = OrderedDict()复制代码\n```\n\n我们再来看一下这个页面的的源码是什么样的，首先是影片排序和影片名称，我们可以从上个页面传递过来。但是，既然它这里有，我直接解析行不行？\n\n必须行啊！\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"1227\"></svg>)\n\n\n\n这个更简单，影片排名直接定位一个 `class=\'top250-no\' 的 span 标签`，影片名称定位一个 `property=\'v:itemreviewed\' 的 span 标签`，获取标签内容即可\n\n```Python\n# 解析电影排名和名称movie_info[\'movie_rank\'] = soup.find_all(\'span\', class_=\'top250-no\')[0].stringmovie_info[\'movie_name\'] = soup.find_all(\'span\', property=\'v:itemreviewed\')[0].string复制代码\n```\n\n\n\n**接下来是影片主要数据**：\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1235\" height=\"1280\"></svg>)\n\n\n\n这个时候我们需要先定位到 `id=\'info\' 的 div`中，然后可以看到`整个 div 的数据`就是我们需要的主要数据。\n\n```Python\n# 定位到影片数据的 divsoup_div = soup.find(id=\'info\')复制代码\n```\n\n“不对啊，小一哥，我发现编剧有时候是一个，有时候是多个。多个的时候存在在多个 span 标签中，这个怎么办啊？”\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"698\" height=\"318\"></svg>)\n\n\n\n“这个简单，我写一个小函数，统一处理一下。“\n\n```Python\ndef get_mul_tag_info(self, soup_span):    \"\"\"    获取多个标签的结果合并在一个结果中返回，并用 / 分割    \"\"\"    info = \'\'    for second_span in soup_span:        # 区分 href 和标签内容        info = (\'\' if (info == \'\') else \'/\').join((info, second_span.string))    return info复制代码\n```\n\n“对了，你记得把最外层的 span 标签给我就行。像这种：”\n\n```Python\n# 解析电影发布信息movie_info[\'movie_director\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[0].find_all(\'a\'))movie_info[\'movie_writer\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[3].find_all(\'a\'))movie_info[\'movie_starring\'] = self.get_mul_tag_info(soup_div.find_all(\'span\')[6].find_all(\'a\'))movie_info[\'movie_type\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:genre\'))movie_info[\'movie_country\'] = soup_div.find(text=\'制片国家/地区:\').next_element.lstrip().rstrip()movie_info[\'movie_language\'] = soup_div.find(text=\'语言:\').next_element.lstrip().rstrip()movie_info[\'movie_release_date\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:initialReleaseDate\'))movie_info[\'movie_run_time\'] = self.get_mul_tag_info(soup_div.find_all(\'span\', property=\'v:runtime\'))movie_info[\'movie_imdb_href\'] = soup_div.find(\'a\', target=\'_blank\')[\'href\']复制代码\n```\n\n“小一哥，又出问题了，有的影片没有`又名`标签，这个怎么处理呢？”\n“这个我们做个异常检测，没有的手动赋空值就行了。”\n\n```Python\nmovie_second_name = \'\'try:    movie_second_name = soup_div.find(text=\'又名:\').next_element.lstrip().rstrip()except AttributeError:    print(\'{0} 没有又名\'.format(movie_info[\'movie_name\']))    movie_info[\'movie_second_name\'] = movie_second_name复制代码\n```\n\n**最后还剩下评分数据**\n评分数据不但有总评分，还有每个星级的评分。\n\n“小一哥，你说我们取哪个数据啊？”\n“小孩才做选择，我当然是全部都要！”\n\n\n\n![img](https://user-gold-cdn.xitu.io/2019/12/16/16f0f12c7178cc95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n\n\n\n可以看到，总评分和总评论人数分别有一个`唯一的 property`，分别是`property=\'v:average\' 的 strong 标签`和 `property=\'v:votes\' 的 span 标签`\n\nok，接下来直接拿数据：\n\n```Python\n# 获取总评分和总评价人数movie_info[\'movie_rating\'] = soup.find_all(\'strong\', property=\'v:average\')[0].stringmovie_info[\'movie_comments_user\'] = soup.find_all(\'span\', property=\'v:votes\')[0].string复制代码\n```\n\n\n\n最后就剩下`每个星级的评分占比`，可以看到 `5星/4星/3星/2星/1星` 分别对应 `力荐/推荐/还行/较差/很差`，可以看到他们都存在在一个`class=\'ratings-on-weight\' 的 div`中\n\n所以，先定位 div ：\n\n```Python\n# 定位到影片星级评分占比的 divsoup_div = soup.find(\'div\', class_=\"ratings-on-weight\")复制代码\n```\n\n然后获取每个星级评分占比数据：\n\n```Python\n# 获取每个星级的评分movie_info[\'movie_five_star_ratio\'] = soup_div.find_all(\'div\')[0].find(class_=\'rating_per\').stringmovie_info[\'movie_four_star_ratio\'] = soup_div.find_all(\'div\')[2].find(class_=\'rating_per\').stringmovie_info[\'movie_three_star_ratio\'] = soup_div.find_all(\'div\')[4].find(class_=\'rating_per\').stringmovie_info[\'movie_two_star_ratio\'] = soup_div.find_all(\'div\')[6].find(class_=\'rating_per\').stringmovie_info[\'movie_one_star_ratio\'] = soup_div.find_all(\'div\')[8].find(class_=\'rating_per\').string复制代码\n```\n\n打印一下看一下我们`当前的影片`数据：\n\n> 对 movie_starring 字段只输出部分显示\n\n```Python\nOrderedDict(    [        (\'movie_rank\', \'No.1\'),         (\'movie_name\', \'肖申克的救赎 The Shawshank Redemption\'),         (\'movie_director\', \'弗兰克·德拉邦特\'),         (\'movie_writer\', \'弗兰克·德拉邦特/斯蒂芬·金\'),         (\'movie_starring\', \'蒂姆·罗宾斯/摩根·弗里曼/鲍勃·冈顿/威廉姆·赛德勒/),         (\'movie_type\', \'剧情/犯罪\'),         (\'movie_country\', \'美国\'),         (\'movie_language\', \'英语\'),         (\'movie_release_date\', \'1994-09-10(多伦多电影节)/1994-10-14(美国)\'),         (\'movie_run_time\', \'142分钟\'),         (\'movie_imdb_href\', \'https://www.imdb.com/title/tt0111161\'),         (\'movie_rating\', \'9.7\'),         (\'movie_comments_user\', \'1720706\'),         (\'movie_five_star_ratio\', \'84.8%\'),         (\'movie_four_star_ratio\', \'13.6%\'),         (\'movie_three_star_ratio\', \'1.4%\'),         (\'movie_two_star_ratio\', \'0.1%\'),         (\'movie_one_star_ratio\', \'0.1%\'),         (\'movie_note\', \'\')    ])复制代码\n```\n\n搞定，成功拿到了想要的数据，最后一步：`保存数据库`\n\n```python\n# 保存当前影片信息self.data_info.append(movie_info)# 获取数据并保存成 DataFramedf_data = pd.DataFrame(self.data_info)# 导入数据到 mysql 中df_data.to_sql(\'t_douban_movie_top_250\', self.pymysql_engine, index=False, if_exists=\'append\')复制代码\n```\n\n看一眼我们的数据库，该有的数据都存进去了\n\n\n\n![img](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1280\" height=\"507\"></svg>)\n\n\n\n`到这里，爬虫就算是结束了`。\n\n\n\n\n\n#### 总结一下：\n\n**准备工作：**\n\n- 首先我们定义了一个影片对象，传入了网址的参数信息，设置了爬虫头部，并建立了数据库连接\n- 我们通过下一页分析出每个影片页的超链接，发现只是改变了参数\n- 建立了主流程，并写出了主流程的伪代码\n\n\n\n**开始爬虫：**\n\n- 爬取`第一页`的网页内容\n- 解析`第一页`的内容，获取每页中25个影片的详细超链接\n- 爬取`详细影片`的网页内容\n- 解析`第二页`的内容，保存到每个影片对象中\n- `保存数据`到数据库中\n\n\n\n**思考：**\n以上就是我们今天爬虫实战的主要内容，相对来说比较简单。\n第一个项目，旨在让大家了解`爬虫流程`，同时，也可以思考一下以下几点：\n\n- 影片详细页面的短评论数据\n- 影片详细页面的获奖情况数据\n- 影片详细页面的讨论区数据\n\n以上数据的获取是否可以用`今天的获取方法`？如果不行，那应该通过什么方式获取这些数据？\n\n\n\n#### 写在后面的话\n\n今天的实战项目就结束了，需要源代码的同学可以在`公众号后台`回复 `豆瓣电影` 获取，如果觉得小一哥讲的还不错的话，不妨`点个赞`？\n\n开篇已经提到，我们的目的不是爬数据。所以，我会利用这些数据做一个简单数据分析，目的很简单：了解数据分析的流程。下期见。\n\n\n\n**碎碎念一下**\n\n> 我发现写技术文比写软文难了不止一个档次，虽然软文没啥技术含量，但是大家爱看啊。\n>\n> \n>\n> 技术性文章苦涩难懂，不过像我讲这么详细的，你确定不点个再看支持一下？\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('30', 'chenin', 'iOS', 'iOS 面试题-2019.上', '1. `UIView`和`CALayer`是什么关系\n\n> - `UIView`继承自`UIResponder`类，可以响应事件\n> - `CALayer`直接继承自`NSObject`类，不可以响应事件\n> - `UIView`是`CALayer`的`delegate`(`CALayerDelegate`)\n> - `UIView`主要处理事件，`CALayer`负责绘制\n> - 每个`UIView`内部都有一个`CALayer`在背后提供内容的绘制和显示，并且`UIView`的尺寸样式都由内部的`Layer`所提供。两者都有树状层级结构，`Layer`内部有`SubLayers`，`View`内部有`SubViews`，但是`Layer`比`View`多了个`AnchorPoint`\n\n1. `NSCache`和`NSMutableDictionary`的相同点与区别\n\n> 相同点： `NSCache`和`NSMutableDictionary`功能用法基本是相同的 区别： `NSCache`是线程安全的，`NSMutableDictionary`线程不安全，`Mutable开发的类`一般都是线程不安全的 当内存不足时`NSCache`会自动释放内存(所以从缓存中取数据的时候总要判断是否为空) `NSCache`可以指定缓存的限额，当缓存超出限额自动释放内存 `NSCache`的`Key`只是对对象进行了`Strong`引用，而非拷贝，所以不需要实现`NSCopying`协议\n\n1. `atomic`的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）\n\n> - `atomic`会对属性的`setter/getter`方法进行加锁，这仅仅只能保证在操作`setter/getter`方法是安全的。不能保证其他线程的安全\n> - 例如：线程1调用了某一属性的`setter`方法并进行到了一半，线程2调用其`getter`方法，那么会执行完`setter`操作后，再执行`getter`操作，线程2会获取到线程1`setter`后的完整的值；当几个线程同时调用同一属性的`setter、getter`方法时，会获取到一个完整的值，但获取到的值不可控\n\n1. iOS 中内省的几个方法\n\n> 对象在运行时获取其类型的能力称为内省。内省可以有多种方法实现 OC运行时内省的4个方法：\n\n- 判断对象类型：\n\n```\n-(BOOL) isKindOfClass:            // 判断是否是这个类或者这个类的子类的实例\n-(BOOL) isMemberOfClass:      // 判断是否是这个类的实例\n复制代码\n```\n\n- 判断对象/类是否有这个方法\n\n```\n-(BOOL) respondsToSelector:                      // 判断实例是否有这样方法\n+(BOOL) instancesRespondToSelector:      // 判断类是否有这个方法\n复制代码\n```\n\n1. `objc`在向一个对象发送消息时，发生了什么\n\n> 根据对象的isa指针找到该对象所属的类，去objc的对应的类中找方法 1.首先，在相应操作的对象中的缓存方法列表中找调用的方法，如果找到，转向相应实现并执行 2.如果没找到，在相应操作的对象中的方法列表中找调用的方法，如果找到，转向相应实现执行 3.如果没找到，去父类指针所指向的对象中执行1，2. 4.以此类推，如果一直到根类还没找到，转向拦截调用，走消息转发机制 5.如果没有重写拦截调用的方法，程序报错\n\n1. 你是否接触过OC中的反射机制？简单聊一下概念和使用\n\n- `class`反射\n- 通过类名的字符串形式实例化对象\n\n```\nClass class = NSClassFromString(@\"student\"); \nStudent *stu = [[class alloc] init];\n复制代码\n```\n\n- 将类名变为字符串\n\n```\nClass class = [Student class];\nNSString *className = NSStringFromClass(class);\n复制代码\n```\n\n- `SEL`的反射\n- 通过方法的字符串形式实例化方法\n\n```\nSEL selector = NSSelectorFromString(@\"setName\");\n[stu performSelector:selector withObject:@\"Mike\"];\n复制代码\n```\n\n- 将方法变成字符串 `NSStringFromSelector(@selector(setName:));`\n\n1. 这个写法会出什么问题`@property (nonatomic, copy) NSMutableArray *arr;`\n\n> 添加，删除，修改数组内元素的时候，程序会因为找不到对应的方法而崩溃。原因：是因为`copy`就是复制一个不可变`NSArray`的对象，不能对`NSArray`对象进行添加/修改\n\n1. 如何让自己的类用`copy`修饰符\n\n> 若想令自己所写的对象具有拷贝功能，则需实现`NSCopying`协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现`NSCopying`与`NSMutableCopying`协议。 具体步骤： 1.需声明该类遵从`NSCopying`协议 2.实现`NSCopying`协议的方法，具体区别[戳这里](http://www.jianshu.com/p/f84803356cbb)\n\n- `NSCopying`协议方法为：\n\n```\n- (id)copyWithZone:(NSZone *)zone {\n  MyObject *copy = [[[self class] allocWithZone: zone] init];\n  copy.username = self.username;\n  return copy;\n}\n复制代码\n```\n\n1. 为什么`assign`不能用于修饰对象\n\n> 首先我们需要明确，对象的内存一般被分配到堆上，基本数据类型和oc数据类型的内存一般被分配在栈上 如果用`assign`修饰对象，当对象被释放后，指针的地址还是存在的，也就是说指针并没有被置为`nil`，从而造成了野指针。因为对象是分配在堆上的，堆上的内存由程序员分配释放。而因为指针没有被置为`nil`，如果后续的内存分配中，刚好分配到了这块内存，就会造成崩溃 而`assign`修饰基本数据类型或oc数据类型，因为基本数据类型是分配在栈上的，由系统分配和释放，所以不会造成野指针\n\n1. 请写出以下代码输出\n\n```\n int a[5] = {1, 2, 3, 4, 5};\n int *ptr = (int *)(&a + 1);\n printf(\"%d, %d\", *(a + 1), *(ptr + 1));\n复制代码\n```\n\n> 参考答案：2，随机值 分析： `a`代表有5个元素的数组的首地址，`a[5]`的元素分别是1，2，3，4，5。接下来，`a + 1`表示数据首地址加1，那么就是`a[1]`，也就是对应于值为2，但是，这里是`&a + 1`，因为`a`代表的是整个数组，它的空间大小为`5 * sizeof(int)`，因此`&a + 1`就是`a + 5`。`a`是个常量指针，指向当前数组的首地址，指针+1就是移动`sizeof(int)`个字节 因此，`ptr`是指向`int *`类型的指针，而`ptr`指向的就是`a + 5`，那么`ptr + 1`也相当于`a + 6`，所以最后的`*(ptr + 1)`就是一个随机值了。而`*(ptr – 1)`就相当于`a + 4`，对应的值就是5\n\n1. 一个`view`已经初始化完毕，`view`上面添加了n个`button`（可能使用循环创建），除用`view`的`tag`之外，还可以采用什么办法来找到自己想要的`button`来修改`Button`的值\n\n> 第一种：如果是点击某个按钮后，才会刷新它的值，其它不用修改，那么不用引用任何按钮，直接在回调时，就已经将接收响应的按钮给传过来了，直接通过它修改即可 第二种：点击某个按钮后，所有与之同类型的按钮都要修改值，那么可以通过在创建按钮时将按钮存入到数组中，在需要的时候遍历查找\n\n1. `UIViewController`的`viewDidUnload、viewDidLoad`和`loadView`分别什么时候调用？`UIView`的`drawRect`和`layoutSubviews`分别起什么作用\n\n> 第一个问题： 在控制器被销毁前会调用`viewDidUnload`（`MRC`下才会调用） 在控制器没有任何`view`时，会调用`loadView` 在`view`加载完成时，会调用`viewDidLoad` 第二个问题： 在调用`setNeedsDisplay`后，会调用`drawRect`方法，我们通过在此方法中可以获取到`context`（设置上下文），就可以实现绘图 在调用`setNeedsLayout`后，会调用`layoutSubviews`方法，我们可以通过在此方法去调整UI。当然能引起`layoutSubviews`调用的方式有很多种的，比如添加子视图、滚动`scrollview`、修改视图的`frame`等\n\n1. 自动释放池工作原理\n\n> 自动释放池是`NSAutorelease`类的一个实例，当向一个对象发送`autorelease`消息时，该对象会自动入池，待池销毁时，将会向池中所有对象发送一条`release`消息，释放对象 `[pool release]、[pool drain]`表示的是池本身不会销毁，而是池子中的临时对象都被发送`release`，从而将对象销毁\n\n1. 苹果是如何实现`autoreleasepool`的\n\n> `autoreleasepool`是由`AutoreleasePoolPage`以双向链表的方式实现的，主要通过下列三个函数完成：\n>\n> - 由`objc_autoreleasePoolPush`作为自动释放池作用域的第一个函数\n> - 使用`objc_autorelease`将对象加入自动释放池\n> - 由`objc_autoreleasePoolPop`作为自动释放池作用域的最后一个函数\n\n1. `autorelease`的对象何时被释放\n\n> `RunLoop`在每个事件循环结束后会去自动释放池将所有自动释放对象的引用计数减一，若引用计数变成了0，则会将对象真正销毁掉，回收内存。 在没有手动添加`Autorelease Pool`的情况下，`autorelease`的对象是在每个事件循环结束后，自动释放池才会对所有自动释放的对象的引用计数减一，若引用计数变成了0，则释放对象，回收内存。因此，若想要早一点释放掉`autorelease`对象，那么我们可以在对象外加一个自动释放池。比如，在循环处理数据时，临时变量要快速释放，就应该采用这种方式：\n\n```\n// 通过alloc创建的对象，直接加入@autoreleasepool没有作用，需在创建对象后面显式添加autorelease\n// 通过类方法创建的对象不需要显式添加autorelease，原因是类方法创建的对象系统会自动添加autorelease\nfor (int i = 0; i < 1000000; i++) {\n @autoreleasepool {\n   NSString *str = @\"Abc\";\n   str = [str lowercaseString];\n   str = [str stringByAppendingString:@\"xyz\"];\n   NSLog(@\"%@\", str);\n } // 出了这里，就会去遍历该自动释放池了\n}\n复制代码\n```\n\n1. 简述内存管理基本原则\n\n> OC内存管理遵循`谁创建，谁释放，谁引用，谁管理`的机制，当使用`alloc、copy(mutableCopy)或者retian`一个对象时，你就有义务向它发送一条`release或者autorelease`消息释放该对象，其他方法创建的对象，不需要由你来管理内存，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制（`MRC`） 向一个对象发送一条`autorelease`消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池中每一个对象发送一条`release`消息，以此来释放对象 向一个对象发送`release`消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为0时，系统才会调用`dealloc`方法释放该对象和对象本身所拥有的实例\n\n1. `sizeof`关键字\n\n> `sizeof`是在编译阶段处理，且不能被编译为机器码。`sizeof`的结果等于对象或类型所占的内存字节数。`sizeof`的返回值类型为`size_t` 变量：`int a; sizeof(a)`为4； 指针：`int *p; sizeof(p)`为4； 数组：`int b[10]; sizeof(b)`为数组的大小4*10；`int c[0]; sizeof(c)`等于0 `sizeof(void)`等于1 `sizeof(void *)`等于4\n\n1. 什么是离屏渲染？什么情况下会触发？离屏渲染消耗性能的原因\n\n> 离屏渲染就是在当前屏幕缓冲区以外，新开辟一个缓冲区进行操作 离屏渲染触发的场景有以下：\n>\n> - 圆角（同时设置`layer.masksToBounds = YES、layer.cornerRadius`大于0）\n> - 图层蒙版\n> - 阴影，`layer.shadowXXX`，如果设置了`layer.shadowPath`就不会产生离屏渲染\n> - 遮罩，`layer.mask`\n> - 光栅化，`layer.shouldRasterize = YES`\n\n> 离屏渲染消耗性能的原因 需要创建新的缓冲区，离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（`On-Screen`）切换到离屏（`Off-Screen`）等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕\n\n1. ARC 下，不显式指定任何属性关键字时，默认的关键字都有哪些\n\n> 基本数据类型默认关键字是：`atomic, readwrite, assign` 普通`Objective-C`对象默认关键字是：`atomic, readwrite, strong`\n\n1. OC中的类方法和实例方法有什么本质区别和联系\n\n> 类方法：\n>\n> - 类方法是属于类对象的\n> - 类方法只能通过类对象调用\n> - 类方法中的 self 是类对象\n> - 类方法可以调用其他的类方法\n> - 类方法中不能访问成员变量\n> - 类方法中不能直接调用对象方法\n\n> 实例方法：\n>\n> - 实例方法是属于实例对象的\n> - 实例方法只能通过实例对象调用\n> - 实例方法中的 self 是实例对象\n> - 实例方法中可以访问成员变量\n> - 实例方法中直接调用实例方法\n> - 实例方法中也可以调用类方法（通过类名）\n\n1. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\n\n> - 不能向编译后得到的类中增加实例变量\n> - 能向运行时创建的类中添加实例变量\n> - 因为编译后的类已经注册在`runtime`中，类结构体中的`objc_ivar_list`实例变量的链表和`instance_size`实例变量的内存大小已经确定，同时`runtime`会调用`class_setIvarLayout`或`class_setWeakIvarLayout`来处理`strong weak`引用，所以不能向存在的类中添加实例变量 运行时创建的类是可以添加实例变量，调用`class_addIvar`函数。但是得在调用`objc_allocateClassPair`之后，`objc_registerClassPair`之前，原因同上\n\n1. `runtime`如何通过`selector`找到对应的`IMP`地址（分别考虑实例方法和类方法）`Selector、Method 和 IMP`的有什么区别与联系\n\n> 对于实例方法，每个实例的`isa`指针指向着对应类对象，而每一个类对象中都有一个对象方法列表。对于类方法，每个类对象的`isa`指针都指向着对应的元类对象，而每一个元类对象中都有一个类方法列表。方法列表中记录着方法的名称，方法实现，以及参数类型，其实`selector`本质就是方法名称，通过这个方法名称就可以在方法列表中找到对应的方法实现 `Selector、Method 和 IMP`的关系可以这样描述：在运行期分发消息，方法列表中的每一个实体都是一个方法（`Method`）它的名字叫做选择器（`SEL`）对应着一种方法实现（`IMP`）\n\n1. `objc_msgSend、_objc_msgForward`都是做什么的？OC 中的消息调用流程是怎样的\n\n> - `objc_msgSend`是用来做消息发送的。在`OC`中，对方法的调用都会被转换成内部的消息发送执行\n>\n> - `_objc_msgForward`是`IMP`类型（函数指针）用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发\n>\n> - 在消息调用的过程中，\n>\n>   ```\n>   objc_msgSend\n>   ```\n>\n>   的动作比较清晰：首先在\n>\n>   ```\n>   Class\n>   ```\n>\n>   中的缓存查找\n>\n>   ```\n>   IMP\n>   ```\n>\n>   （没缓存则初始化缓存）如果没找到，则向父类的\n>\n>   ```\n>   Class\n>   ```\n>\n>   查找。如果一直查找到根类仍旧没有实现，则用\n>\n>   ```\n>   _objc_msgForward\n>   ```\n>\n>   函数指针代替\n>\n>   ```\n>   IMP\n>   ```\n>\n>   。最后，执行这个\n>\n>   ```\n>   IMP\n>   ```\n>\n>   。当调用一个\n>\n>   ```\n>   NSObject\n>   ```\n>\n>   对象不存在的方法时，并不会马上抛出异常，而是会经过多层转发，层层调用对象的\n>\n>   ```\n>   -resolveInstanceMethod:、-forwardingTargetForSelector:、-methodSignatureForSelector:、-forwardInvocation:\n>   ```\n>\n>   等方法。其中最后\n>\n>   ```\n>   -forwardInvocation:\n>   ```\n>\n>   是会有一个\n>\n>   ```\n>   NSInvocation\n>   ```\n>\n>   对象，这个\n>\n>   ```\n>   NSInvocation\n>   ```\n>\n>   对象保存了这个方法调用的所有信息，包括\n>\n>   ```\n>   Selector名，参数和返回值类型\n>   ```\n>\n>   ，可以从这个\n>\n>   ```\n>   NSInvocation\n>   ```\n>\n>   对象里拿到调用的所有参数值\n>\n>   ![img](https://user-gold-cdn.xitu.io/2019/12/18/16f180e8604f5b40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n1. `class`方法和`objc_getClass`方法有什么区别\n\n> `object_getClass(obj)`返回的是`obj`中的`isa`指针，即指向类对象的指针；而`[obj class]`则分两种情况：一是当`obj`为实例对象时，`[obj class]`中`class`是实例方法，返回的是`obj`对象中的`isa`指针；二是当`obj`为类对象（包括元类和根类以及根元类）时，调用的是类方法，返回的结果为其本身\n\n1. OC中向一个`nil`对象发送消息将会发生什么\n\n> 在`OC`中向`nil`发送消息是完全有效的，只是在运行时不会有任何作用；向一个`nil`对象发送消息，首先在寻找对象的`isa`指针时就是`0地址`返回了，所以不会出现任何错误，也不会崩溃\n\n1. `_objc_msgForward`函数是做什么的？直接调用它将会发生什么\n\n> ```\n> _objc_msgForward`是一个函数指针（和`IMP`的类型一样）用于消息转发；当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发 `objc_msgSend`在`消息传递`中的作用。在`消息传递`过程中，`objc_msgSend`的动作比较清晰：首先在`Class`中的缓存查找`IMP`（`没有缓存则初始化缓存`）如果没找到，则向`父类的Class`查找。如果一直查找到`根类`仍旧没有实现，则用`_objc_msgForward`函数指针代替`IMP`，最后执行这个`IMP` 一旦调用了`_objc_msgForward`，将跳过查找`IMP`的过程，直接触发`消息转发`，如果调用了`_objc_msgForward`，即使这个对象确实已经实现了这个方法，你也会告诉`objc_msgSend`，我没有在这个对象里找到这个方法的实现，如果用不好会直接导致程序`Crash\n> ```\n\n1. 什么时候会报`unrecognized selector`的异常\n\n- 当调用该对象上某个方法，而该对象上没有实现这个方法的时候。可以通过\n\n  ```\n  消息转发\n  ```\n\n  进行解决，流程见下图\n\n  ![img](https://user-gold-cdn.xitu.io/2019/12/18/16f180e8604f5b40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n- `OC`在向一个对象发送消息时，`runtime`库会根据对象的`isa`指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常`unrecognized selector sent to XXX` **但是在这之前，OC的运行时会给出三次拯救程序崩溃的机会**\n\n- Method resolution（消息动态解析） `OC`运行时会调用`+resolveInstanceMethod:`或者`+resolveClassMethod:`，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则，运行时就会移到下一步，消息转发（`Message Forwarding`）\n\n```\n// 重写 resolveInstanceMethod: 添加对象方法实现\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    // 如果是执行 run 函数，就动态解析，指定新的 IMP\n    if (sel == NSSelectorFromString(@\"run:\")) {\n        // class: 给哪个类添加方法\n        // SEL: 添加哪个方法\n        // IMP: 方法实现 => 函数 => 函数入口 => 函数名\n        // type: 方法类型：void用v来表示，id参数用@来表示，SEL用:来表示\n        class_addMethod(self, sel, (IMP)runMethod, \"v@:@\");\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n\n//新的 run 函数\nvoid runMethod(id self, SEL _cmd, NSNumber *meter) {\n    NSLog(@\"跑了%@\", meter);\n}\n复制代码\n```\n\n- Fast forwarding（消息接受者重定向） 如果目标对象实现了`-forwardingTargetForSelector:`，`Runtime`这时就会调用这个方法，给你把这个消息转发给其他对象的机会。只要这个方法返回的不是`nil`和`self`，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续`Normal Fowarding`。 这里叫`Fast`，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个`NSInvocation`对象，所以相对更快点\n\n```\n// 消息接受者重定向\n- (id)forwardingTargetForSelector:(SEL)aSelector{\n    if (aSelector == @selector(run:)) {\n        return [[Person alloc] init];\n        // 返回 Person 对象，让 Person 对象接收这个消息\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n复制代码\n```\n\n- Normal forwarding（消息重定向） 这一步是`Runtime`最后一次给你挽救的机会。首先它会发送`-methodSignatureForSelector:`消息获得函数的参数和返回值类型。如果`-methodSignatureForSelector:`返回`nil`，`Runtime`则会发出`-doesNotRecognizeSelector:`消息，程序这时也就挂掉了。如果返回了一个函数签名，`Runtime`就会创建一个`NSInvocation`对象并发送`-forwardInvocation:`消息给目标对象\n\n```\n// 获取函数的参数和返回值类型，返回签名\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if ([NSStringFromSelector(aSelector) isEqualToString:@\"run:\"]) {\n        return [NSMethodSignature signatureWithObjCTypes:\"v@:@\"];\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n// 消息重定向\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    // 从 anInvocation 中获取消息\n    SEL sel = anInvocation.selector;\n    if (sel == NSSelectorFromString(@\"run:\")) {\n        // 1. 指定当前类的一个方法作为IMP\n        // anInvocation.selector = @selector(readBook:);\n        // [anInvocation invoke];\n        \n        // 2. 指定其他类来执行这个IMP\n        Person *p = [[Person alloc] init];\n        // 判断 Person 对象方法是否可以响应 sel\n        if([p respondsToSelector:sel]) {\n            // 若可以响应，则将消息转发给其他对象处理\n            [anInvocation invokeWithTarget:p];\n        } else {\n            // 若仍然无法响应，则报错：找不到响应方法\n            [self doesNotRecognizeSelector:sel];\n        }\n    }else{\n        [super forwardInvocation:anInvocation];\n    }\n}\n\n- (void)doesNotRecognizeSelector:(SEL)aSelector {\n    [super doesNotRecognizeSelector:aSelector];\n}\n复制代码\n```\n\n**既然`-forwardingTargetForSelector:`和`-forwardInvocation:`都可以将消息转发给其他对象处理，那么两者的区别在哪？** 区别就在于`-forwardingTargetForSelector:`只能将消息转发给一个对象。而`-forwardInvocation:`可以把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。修改消息的target，selector，参数等。将消息转发给多个对象\n\n1. `iOS layoutSubviews`什么时候会被调用\n\n> - `init`方法不会调用`layoutSubviews`，但是是用`initWithFrame`进行初始化时，当`rect`的值不为`CGRectZero`时，会触发\n> - `addSubview`会触发`layoutSubviews`方法\n> - `setFrame`只有当设置的`frame`的参数的`size`与原来的`size`不同，才会触发其`view`的`layoutSubviews`方法\n> - 滑动`UIScrollView`会调用`scrollview`及`scrollview`上的`view`的`layoutSubviews`方法\n> - 旋转设备只会调用`VC`的`view`的`layoutSubviews`方法\n> - 直接调用`[self setNeedsLayout];`（这个在上面苹果官方文档里有说明） `-layoutSubviews`方法：这个方法默认没有做任何事情，需要子类进行重写 `-setNeedsLayout`方法：标记为需要重新布局，异步调用`layoutIfNeeded`刷新布局，不立即刷新，但`layoutSubviews`一定会被调用 `-layoutIfNeeded`方法：如果有需要刷新的标记，立即调用`layoutSubviews`进行布局（如果没有标记，不会调用`layoutSubviews`） 如果要立即刷新，要先调用`[view setNeedsLayout]`，把标记设为需要布局，然后马上调用`[view layoutIfNeeded]`，实现布局 在视图第一次显示之前，标记总是`需要刷新`的，可以直接调用`[view layoutIfNeeded]`\n\n1. 下面代码会发生什么问题\n\n```\n@property (nonatomic, strong) NSString *str;\n\ndispatch_queue_t queue = dispatch_queue_create(\"parallel\", DISPATCH_QUEUE_CONCURRENT);\nfor (int i = 0; i < 1000000 ; i++) {\n    dispatch_async(queue, ^{\n        self.str = [NSString stringWithFormat:@\"changzifuchaung:%d\",i];\n    });\n}\n复制代码\n```\n\n会`crash`。因为在并行队列`DISPATCH_QUEUE_CONCURRENT`中异步`dispatch_async`对`str`属性进行赋值，就会导致`str`已经被`release`了，还会执行`release`。这就是向已释放内存的对象发送消息而发生`crash` 详细解析：对`str`属性`strong`修饰进行赋值，相当与`MRC`中的\n\n```\n- (void)setStr:(NSString *)str{\n    if (str == _str) return;\n    id pre = _str;\n    [str retain];//1.先保留新值\n    _str = str;//2.再进行赋值\n    [pre release];//3.释放旧值\n}\n复制代码\n```\n\n那么假如`并发队列`里调度的`线程A`执行到`步骤1`，还没到`步骤2`时，`线程B`执行到`步骤3`，那么当`线程A`再执行`步骤3`时，旧值就会被`过度释放`，导致向已释放内存的对象发送消息而崩溃\n\n- 追问：怎么修改这段代码变为不崩溃呢\n\n> 1、使用串行队列 将`set`方法改成在串行队列中执行就行，这样即使异步，但所有`block`操作追加在队列最后依次执行 2、使用`atomic` `atomic`关键字相当于在`setter`方法加锁，这样每次执行`setter`都是线程安全的，但这只是单独针对`setter`方法而言的狭义的线程安全 3、使用`weak`关键字 `weak`的`setter`没有`保留新值`的操作，所以不会引发重复释放。当然这个时候要看具体情况能否使用`weak`，可能值并不是所需要的值 4、使用互斥锁，保证数据访问的唯一性`@synchronized (self) {self.str = [NSString stringWithFormat:@\"changzifuchaung:%d\",i];}` 5、使用`Tagged Pointer` `Tagged Pointer`是苹果在64位系统引入的内存技术。简单来说就是对于`NSString`(内存小于60位的字符串)或`NSNumber`(小于2^31)，64位的指针有8个字节，完全可以直接用这个空间来直接表示值，这样的话其实会将`NSString`和`NSNumber`对象由一个`指针`转换成一个`值类型`，而值类型的`setter和getter`又是原子的，从而线程安全\n\n- 发散：下面代码会`crash`吗\n\n```\n@property (nonatomic, strong) NSString *str;\n\ndispatch_queue_t queue = dispatch_queue_create(\"parallel\", DISPATCH_QUEUE_CONCURRENT);\nfor (int i = 0; i < 1000000 ; i++) {\n    dispatch_async(queue, ^{\n        // 相比上面，仅字符串变短了\n        self.str = [NSString stringWithFormat:@\"%d\",i];\n        NSLog(@\"%d, %s, %p\", i, object_getClassName(self.str), self.str);\n    });\n}\n复制代码\n```\n\n不会`crash`。而且发现`str`这个字符串类型是`NSTaggedPointerString` `Tagged Pointer`是一个能够提升性能、节省内存的有趣的技术 `Tagged Pointer`专门用来存储小的对象，例如`NSNumber`和`NSDate`(后来可以存储小字符串) `Tagged Pointer指针的值`不再是`地址`了，而是`真正的值`。所以，实际上它不再是一个`对象`了，它只是一个披着对象皮的`普通变量`而已 它的内存并不存储在`堆`中，也不需要`malloc和free`，所以拥有极快的读取和创建速度\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('31', 'chenin', 'iOS', 'iOS', '1. `UIView`和`CALayer`是什么关系\n\n> - `UIView`继承自`UIResponder`类，可以响应事件\n> - `CALayer`直接继承自`NSObject`类，不可以响应事件\n> - `UIView`是`CALayer`的`delegate`(`CALayerDelegate`)\n> - `UIView`主要处理事件，`CALayer`负责绘制\n> - 每个`UIView`内部都有一个`CALayer`在背后提供内容的绘制和显示，并且`UIView`的尺寸样式都由内部的`Layer`所提供。两者都有树状层级结构，`Layer`内部有`SubLayers`，`View`内部有`SubViews`，但是`Layer`比`View`多了个`AnchorPoint`\n\n1. `NSCache`和`NSMutableDictionary`的相同点与区别\n\n> 相同点： `NSCache`和`NSMutableDictionary`功能用法基本是相同的 区别： `NSCache`是线程安全的，`NSMutableDictionary`线程不安全，`Mutable开发的类`一般都是线程不安全的 当内存不足时`NSCache`会自动释放内存(所以从缓存中取数据的时候总要判断是否为空) `NSCache`可以指定缓存的限额，当缓存超出限额自动释放内存 `NSCache`的`Key`只是对对象进行了`Strong`引用，而非拷贝，所以不需要实现`NSCopying`协议\n\n1. `atomic`的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）\n\n> - `atomic`会对属性的`setter/getter`方法进行加锁，这仅仅只能保证在操作`setter/getter`方法是安全的。不能保证其他线程的安全\n> - 例如：线程1调用了某一属性的`setter`方法并进行到了一半，线程2调用其`getter`方法，那么会执行完`setter`操作后，再执行`getter`操作，线程2会获取到线程1`setter`后的完整的值；当几个线程同时调用同一属性的`setter、getter`方法时，会获取到一个完整的值，但获取到的值不可控\n\n1. iOS 中内省的几个方法\n\n> 对象在运行时获取其类型的能力称为内省。内省可以有多种方法实现 OC运行时内省的4个方法：\n\n- 判断对象类型：\n\n```\n-(BOOL) isKindOfClass:            // 判断是否是这个类或者这个类的子类的实例\n-(BOOL) isMemberOfClass:      // 判断是否是这个类的实例\n复制代码\n```\n\n- 判断对象/类是否有这个方法\n\n```\n-(BOOL) respondsToSelector:                      // 判断实例是否有这样方法\n+(BOOL) instancesRespondToSelector:      // 判断类是否有这个方法\n复制代码\n```\n\n1. `objc`在向一个对象发送消息时，发生了什么\n\n> 根据对象的isa指针找到该对象所属的类，去objc的对应的类中找方法 1.首先，在相应操作的对象中的缓存方法列表中找调用的方法，如果找到，转向相应实现并执行 2.如果没找到，在相应操作的对象中的方法列表中找调用的方法，如果找到，转向相应实现执行 3.如果没找到，去父类指针所指向的对象中执行1，2. 4.以此类推，如果一直到根类还没找到，转向拦截调用，走消息转发机制 5.如果没有重写拦截调用的方法，程序报错\n\n1. 你是否接触过OC中的反射机制？简单聊一下概念和使用\n\n- `class`反射\n- 通过类名的字符串形式实例化对象\n\n```\nClass class = NSClassFromString(@\"student\"); \nStudent *stu = [[class alloc] init];\n复制代码\n```\n\n- 将类名变为字符串\n\n```\nClass class = [Student class];\nNSString *className = NSStringFromClass(class);\n复制代码\n```\n\n- `SEL`的反射\n- 通过方法的字符串形式实例化方法\n\n```\nSEL selector = NSSelectorFromString(@\"setName\");\n[stu performSelector:selector withObject:@\"Mike\"];\n复制代码\n```\n\n- 将方法变成字符串 `NSStringFromSelector(@selector(setName:));`\n\n1. 这个写法会出什么问题`@property (nonatomic, copy) NSMutableArray *arr;`\n\n> 添加，删除，修改数组内元素的时候，程序会因为找不到对应的方法而崩溃。原因：是因为`copy`就是复制一个不可变`NSArray`的对象，不能对`NSArray`对象进行添加/修改\n\n1. 如何让自己的类用`copy`修饰符\n\n> 若想令自己所写的对象具有拷贝功能，则需实现`NSCopying`协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现`NSCopying`与`NSMutableCopying`协议。 具体步骤： 1.需声明该类遵从`NSCopying`协议 2.实现`NSCopying`协议的方法，具体区别[戳这里](http://www.jianshu.com/p/f84803356cbb)\n\n- `NSCopying`协议方法为：\n\n```\n- (id)copyWithZone:(NSZone *)zone {\n  MyObject *copy = [[[self class] allocWithZone: zone] init];\n  copy.username = self.username;\n  return copy;\n}\n复制代码\n```\n\n1. 为什么`assign`不能用于修饰对象\n\n> 首先我们需要明确，对象的内存一般被分配到堆上，基本数据类型和oc数据类型的内存一般被分配在栈上 如果用`assign`修饰对象，当对象被释放后，指针的地址还是存在的，也就是说指针并没有被置为`nil`，从而造成了野指针。因为对象是分配在堆上的，堆上的内存由程序员分配释放。而因为指针没有被置为`nil`，如果后续的内存分配中，刚好分配到了这块内存，就会造成崩溃 而`assign`修饰基本数据类型或oc数据类型，因为基本数据类型是分配在栈上的，由系统分配和释放，所以不会造成野指针\n\n1. 请写出以下代码输出\n\n```\n int a[5] = {1, 2, 3, 4, 5};\n int *ptr = (int *)(&a + 1);\n printf(\"%d, %d\", *(a + 1), *(ptr + 1));\n复制代码\n```\n\n> 参考答案：2，随机值 分析： `a`代表有5个元素的数组的首地址，`a[5]`的元素分别是1，2，3，4，5。接下来，`a + 1`表示数据首地址加1，那么就是`a[1]`，也就是对应于值为2，但是，这里是`&a + 1`，因为`a`代表的是整个数组，它的空间大小为`5 * sizeof(int)`，因此`&a + 1`就是`a + 5`。`a`是个常量指针，指向当前数组的首地址，指针+1就是移动`sizeof(int)`个字节 因此，`ptr`是指向`int *`类型的指针，而`ptr`指向的就是`a + 5`，那么`ptr + 1`也相当于`a + 6`，所以最后的`*(ptr + 1)`就是一个随机值了。而`*(ptr – 1)`就相当于`a + 4`，对应的值就是5\n\n1. 一个`view`已经初始化完毕，`view`上面添加了n个`button`（可能使用循环创建），除用`view`的`tag`之外，还可以采用什么办法来找到自己想要的`button`来修改`Button`的值\n\n> 第一种：如果是点击某个按钮后，才会刷新它的值，其它不用修改，那么不用引用任何按钮，直接在回调时，就已经将接收响应的按钮给传过来了，直接通过它修改即可 第二种：点击某个按钮后，所有与之同类型的按钮都要修改值，那么可以通过在创建按钮时将按钮存入到数组中，在需要的时候遍历查找\n\n1. `UIViewController`的`viewDidUnload、viewDidLoad`和`loadView`分别什么时候调用？`UIView`的`drawRect`和`layoutSubviews`分别起什么作用\n\n> 第一个问题： 在控制器被销毁前会调用`viewDidUnload`（`MRC`下才会调用） 在控制器没有任何`view`时，会调用`loadView` 在`view`加载完成时，会调用`viewDidLoad` 第二个问题： 在调用`setNeedsDisplay`后，会调用`drawRect`方法，我们通过在此方法中可以获取到`context`（设置上下文），就可以实现绘图 在调用`setNeedsLayout`后，会调用`layoutSubviews`方法，我们可以通过在此方法去调整UI。当然能引起`layoutSubviews`调用的方式有很多种的，比如添加子视图、滚动`scrollview`、修改视图的`frame`等\n\n1. 自动释放池工作原理\n\n> 自动释放池是`NSAutorelease`类的一个实例，当向一个对象发送`autorelease`消息时，该对象会自动入池，待池销毁时，将会向池中所有对象发送一条`release`消息，释放对象 `[pool release]、[pool drain]`表示的是池本身不会销毁，而是池子中的临时对象都被发送`release`，从而将对象销毁\n\n1. 苹果是如何实现`autoreleasepool`的\n\n> `autoreleasepool`是由`AutoreleasePoolPage`以双向链表的方式实现的，主要通过下列三个函数完成：\n>\n> - 由`objc_autoreleasePoolPush`作为自动释放池作用域的第一个函数\n> - 使用`objc_autorelease`将对象加入自动释放池\n> - 由`objc_autoreleasePoolPop`作为自动释放池作用域的最后一个函数\n\n1. `autorelease`的对象何时被释放\n\n> `RunLoop`在每个事件循环结束后会去自动释放池将所有自动释放对象的引用计数减一，若引用计数变成了0，则会将对象真正销毁掉，回收内存。 在没有手动添加`Autorelease Pool`的情况下，`autorelease`的对象是在每个事件循环结束后，自动释放池才会对所有自动释放的对象的引用计数减一，若引用计数变成了0，则释放对象，回收内存。因此，若想要早一点释放掉`autorelease`对象，那么我们可以在对象外加一个自动释放池。比如，在循环处理数据时，临时变量要快速释放，就应该采用这种方式：\n\n```\n// 通过alloc创建的对象，直接加入@autoreleasepool没有作用，需在创建对象后面显式添加autorelease\n// 通过类方法创建的对象不需要显式添加autorelease，原因是类方法创建的对象系统会自动添加autorelease\nfor (int i = 0; i < 1000000; i++) {\n @autoreleasepool {\n   NSString *str = @\"Abc\";\n   str = [str lowercaseString];\n   str = [str stringByAppendingString:@\"xyz\"];\n   NSLog(@\"%@\", str);\n } // 出了这里，就会去遍历该自动释放池了\n}\n复制代码\n```\n\n1. 简述内存管理基本原则\n\n> OC内存管理遵循`谁创建，谁释放，谁引用，谁管理`的机制，当使用`alloc、copy(mutableCopy)或者retian`一个对象时，你就有义务向它发送一条`release或者autorelease`消息释放该对象，其他方法创建的对象，不需要由你来管理内存，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制（`MRC`） 向一个对象发送一条`autorelease`消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池中每一个对象发送一条`release`消息，以此来释放对象 向一个对象发送`release`消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为0时，系统才会调用`dealloc`方法释放该对象和对象本身所拥有的实例\n\n1. `sizeof`关键字\n\n> `sizeof`是在编译阶段处理，且不能被编译为机器码。`sizeof`的结果等于对象或类型所占的内存字节数。`sizeof`的返回值类型为`size_t` 变量：`int a; sizeof(a)`为4； 指针：`int *p; sizeof(p)`为4； 数组：`int b[10]; sizeof(b)`为数组的大小4*10；`int c[0]; sizeof(c)`等于0 `sizeof(void)`等于1 `sizeof(void *)`等于4\n\n1. 什么是离屏渲染？什么情况下会触发？离屏渲染消耗性能的原因\n\n> 离屏渲染就是在当前屏幕缓冲区以外，新开辟一个缓冲区进行操作 离屏渲染触发的场景有以下：\n>\n> - 圆角（同时设置`layer.masksToBounds = YES、layer.cornerRadius`大于0）\n> - 图层蒙版\n> - 阴影，`layer.shadowXXX`，如果设置了`layer.shadowPath`就不会产生离屏渲染\n> - 遮罩，`layer.mask`\n> - 光栅化，`layer.shouldRasterize = YES`\n\n> 离屏渲染消耗性能的原因 需要创建新的缓冲区，离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（`On-Screen`）切换到离屏（`Off-Screen`）等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕\n\n1. ARC 下，不显式指定任何属性关键字时，默认的关键字都有哪些\n\n> 基本数据类型默认关键字是：`atomic, readwrite, assign` 普通`Objective-C`对象默认关键字是：`atomic, readwrite, strong`\n\n1. OC中的类方法和实例方法有什么本质区别和联系\n\n> 类方法：\n>\n> - 类方法是属于类对象的\n> - 类方法只能通过类对象调用\n> - 类方法中的 self 是类对象\n> - 类方法可以调用其他的类方法\n> - 类方法中不能访问成员变量\n> - 类方法中不能直接调用对象方法\n\n> 实例方法：\n>\n> - 实例方法是属于实例对象的\n> - 实例方法只能通过实例对象调用\n> - 实例方法中的 self 是实例对象\n> - 实例方法中可以访问成员变量\n> - 实例方法中直接调用实例方法\n> - 实例方法中也可以调用类方法（通过类名）\n\n1. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\n\n> - 不能向编译后得到的类中增加实例变量\n> - 能向运行时创建的类中添加实例变量\n> - 因为编译后的类已经注册在`runtime`中，类结构体中的`objc_ivar_list`实例变量的链表和`instance_size`实例变量的内存大小已经确定，同时`runtime`会调用`class_setIvarLayout`或`class_setWeakIvarLayout`来处理`strong weak`引用，所以不能向存在的类中添加实例变量 运行时创建的类是可以添加实例变量，调用`class_addIvar`函数。但是得在调用`objc_allocateClassPair`之后，`objc_registerClassPair`之前，原因同上\n\n1. `runtime`如何通过`selector`找到对应的`IMP`地址（分别考虑实例方法和类方法）`Selector、Method 和 IMP`的有什么区别与联系\n\n> 对于实例方法，每个实例的`isa`指针指向着对应类对象，而每一个类对象中都有一个对象方法列表。对于类方法，每个类对象的`isa`指针都指向着对应的元类对象，而每一个元类对象中都有一个类方法列表。方法列表中记录着方法的名称，方法实现，以及参数类型，其实`selector`本质就是方法名称，通过这个方法名称就可以在方法列表中找到对应的方法实现 `Selector、Method 和 IMP`的关系可以这样描述：在运行期分发消息，方法列表中的每一个实体都是一个方法（`Method`）它的名字叫做选择器（`SEL`）对应着一种方法实现（`IMP`）\n\n1. `objc_msgSend、_objc_msgForward`都是做什么的？OC 中的消息调用流程是怎样的\n\n> - `objc_msgSend`是用来做消息发送的。在`OC`中，对方法的调用都会被转换成内部的消息发送执行\n>\n> - `_objc_msgForward`是`IMP`类型（函数指针）用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发\n>\n> - 在消息调用的过程中，\n>\n>   ```\n>   objc_msgSend\n>   ```\n>\n>   的动作比较清晰：首先在\n>\n>   ```\n>   Class\n>   ```\n>\n>   中的缓存查找\n>\n>   ```\n>   IMP\n>   ```\n>\n>   （没缓存则初始化缓存）如果没找到，则向父类的\n>\n>   ```\n>   Class\n>   ```\n>\n>   查找。如果一直查找到根类仍旧没有实现，则用\n>\n>   ```\n>   _objc_msgForward\n>   ```\n>\n>   函数指针代替\n>\n>   ```\n>   IMP\n>   ```\n>\n>   。最后，执行这个\n>\n>   ```\n>   IMP\n>   ```\n>\n>   。当调用一个\n>\n>   ```\n>   NSObject\n>   ```\n>\n>   对象不存在的方法时，并不会马上抛出异常，而是会经过多层转发，层层调用对象的\n>\n>   ```\n>   -resolveInstanceMethod:、-forwardingTargetForSelector:、-methodSignatureForSelector:、-forwardInvocation:\n>   ```\n>\n>   等方法。其中最后\n>\n>   ```\n>   -forwardInvocation:\n>   ```\n>\n>   是会有一个\n>\n>   ```\n>   NSInvocation\n>   ```\n>\n>   对象，这个\n>\n>   ```\n>   NSInvocation\n>   ```\n>\n>   对象保存了这个方法调用的所有信息，包括\n>\n>   ```\n>   Selector名，参数和返回值类型\n>   ```\n>\n>   ，可以从这个\n>\n>   ```\n>   NSInvocation\n>   ```\n>\n>   对象里拿到调用的所有参数值\n>\n>   ![img](https://user-gold-cdn.xitu.io/2019/12/18/16f180e8604f5b40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n1. `class`方法和`objc_getClass`方法有什么区别\n\n> `object_getClass(obj)`返回的是`obj`中的`isa`指针，即指向类对象的指针；而`[obj class]`则分两种情况：一是当`obj`为实例对象时，`[obj class]`中`class`是实例方法，返回的是`obj`对象中的`isa`指针；二是当`obj`为类对象（包括元类和根类以及根元类）时，调用的是类方法，返回的结果为其本身\n\n1. OC中向一个`nil`对象发送消息将会发生什么\n\n> 在`OC`中向`nil`发送消息是完全有效的，只是在运行时不会有任何作用；向一个`nil`对象发送消息，首先在寻找对象的`isa`指针时就是`0地址`返回了，所以不会出现任何错误，也不会崩溃\n\n1. `_objc_msgForward`函数是做什么的？直接调用它将会发生什么\n\n> ```\n> _objc_msgForward`是一个函数指针（和`IMP`的类型一样）用于消息转发；当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发 `objc_msgSend`在`消息传递`中的作用。在`消息传递`过程中，`objc_msgSend`的动作比较清晰：首先在`Class`中的缓存查找`IMP`（`没有缓存则初始化缓存`）如果没找到，则向`父类的Class`查找。如果一直查找到`根类`仍旧没有实现，则用`_objc_msgForward`函数指针代替`IMP`，最后执行这个`IMP` 一旦调用了`_objc_msgForward`，将跳过查找`IMP`的过程，直接触发`消息转发`，如果调用了`_objc_msgForward`，即使这个对象确实已经实现了这个方法，你也会告诉`objc_msgSend`，我没有在这个对象里找到这个方法的实现，如果用不好会直接导致程序`Crash\n> ```\n\n1. 什么时候会报`unrecognized selector`的异常\n\n- 当调用该对象上某个方法，而该对象上没有实现这个方法的时候。可以通过\n\n  ```\n  消息转发\n  ```\n\n  进行解决，流程见下图\n\n  ![img](https://user-gold-cdn.xitu.io/2019/12/18/16f180e8604f5b40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n- `OC`在向一个对象发送消息时，`runtime`库会根据对象的`isa`指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常`unrecognized selector sent to XXX` **但是在这之前，OC的运行时会给出三次拯救程序崩溃的机会**\n\n- Method resolution（消息动态解析） `OC`运行时会调用`+resolveInstanceMethod:`或者`+resolveClassMethod:`，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则，运行时就会移到下一步，消息转发（`Message Forwarding`）\n\n```\n// 重写 resolveInstanceMethod: 添加对象方法实现\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    // 如果是执行 run 函数，就动态解析，指定新的 IMP\n    if (sel == NSSelectorFromString(@\"run:\")) {\n        // class: 给哪个类添加方法\n        // SEL: 添加哪个方法\n        // IMP: 方法实现 => 函数 => 函数入口 => 函数名\n        // type: 方法类型：void用v来表示，id参数用@来表示，SEL用:来表示\n        class_addMethod(self, sel, (IMP)runMethod, \"v@:@\");\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n\n//新的 run 函数\nvoid runMethod(id self, SEL _cmd, NSNumber *meter) {\n    NSLog(@\"跑了%@\", meter);\n}\n复制代码\n```\n\n- Fast forwarding（消息接受者重定向） 如果目标对象实现了`-forwardingTargetForSelector:`，`Runtime`这时就会调用这个方法，给你把这个消息转发给其他对象的机会。只要这个方法返回的不是`nil`和`self`，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续`Normal Fowarding`。 这里叫`Fast`，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个`NSInvocation`对象，所以相对更快点\n\n```\n// 消息接受者重定向\n- (id)forwardingTargetForSelector:(SEL)aSelector{\n    if (aSelector == @selector(run:)) {\n        return [[Person alloc] init];\n        // 返回 Person 对象，让 Person 对象接收这个消息\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n复制代码\n```\n\n- Normal forwarding（消息重定向） 这一步是`Runtime`最后一次给你挽救的机会。首先它会发送`-methodSignatureForSelector:`消息获得函数的参数和返回值类型。如果`-methodSignatureForSelector:`返回`nil`，`Runtime`则会发出`-doesNotRecognizeSelector:`消息，程序这时也就挂掉了。如果返回了一个函数签名，`Runtime`就会创建一个`NSInvocation`对象并发送`-forwardInvocation:`消息给目标对象\n\n```\n// 获取函数的参数和返回值类型，返回签名\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if ([NSStringFromSelector(aSelector) isEqualToString:@\"run:\"]) {\n        return [NSMethodSignature signatureWithObjCTypes:\"v@:@\"];\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n// 消息重定向\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    // 从 anInvocation 中获取消息\n    SEL sel = anInvocation.selector;\n    if (sel == NSSelectorFromString(@\"run:\")) {\n        // 1. 指定当前类的一个方法作为IMP\n        // anInvocation.selector = @selector(readBook:);\n        // [anInvocation invoke];\n        \n        // 2. 指定其他类来执行这个IMP\n        Person *p = [[Person alloc] init];\n        // 判断 Person 对象方法是否可以响应 sel\n        if([p respondsToSelector:sel]) {\n            // 若可以响应，则将消息转发给其他对象处理\n            [anInvocation invokeWithTarget:p];\n        } else {\n            // 若仍然无法响应，则报错：找不到响应方法\n            [self doesNotRecognizeSelector:sel];\n        }\n    }else{\n        [super forwardInvocation:anInvocation];\n    }\n}\n\n- (void)doesNotRecognizeSelector:(SEL)aSelector {\n    [super doesNotRecognizeSelector:aSelector];\n}\n复制代码\n```\n\n**既然`-forwardingTargetForSelector:`和`-forwardInvocation:`都可以将消息转发给其他对象处理，那么两者的区别在哪？** 区别就在于`-forwardingTargetForSelector:`只能将消息转发给一个对象。而`-forwardInvocation:`可以把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。修改消息的target，selector，参数等。将消息转发给多个对象\n\n1. `iOS layoutSubviews`什么时候会被调用\n\n> - `init`方法不会调用`layoutSubviews`，但是是用`initWithFrame`进行初始化时，当`rect`的值不为`CGRectZero`时，会触发\n> - `addSubview`会触发`layoutSubviews`方法\n> - `setFrame`只有当设置的`frame`的参数的`size`与原来的`size`不同，才会触发其`view`的`layoutSubviews`方法\n> - 滑动`UIScrollView`会调用`scrollview`及`scrollview`上的`view`的`layoutSubviews`方法\n> - 旋转设备只会调用`VC`的`view`的`layoutSubviews`方法\n> - 直接调用`[self setNeedsLayout];`（这个在上面苹果官方文档里有说明） `-layoutSubviews`方法：这个方法默认没有做任何事情，需要子类进行重写 `-setNeedsLayout`方法：标记为需要重新布局，异步调用`layoutIfNeeded`刷新布局，不立即刷新，但`layoutSubviews`一定会被调用 `-layoutIfNeeded`方法：如果有需要刷新的标记，立即调用`layoutSubviews`进行布局（如果没有标记，不会调用`layoutSubviews`） 如果要立即刷新，要先调用`[view setNeedsLayout]`，把标记设为需要布局，然后马上调用`[view layoutIfNeeded]`，实现布局 在视图第一次显示之前，标记总是`需要刷新`的，可以直接调用`[view layoutIfNeeded]`\n\n1. 下面代码会发生什么问题\n\n```\n@property (nonatomic, strong) NSString *str;\n\ndispatch_queue_t queue = dispatch_queue_create(\"parallel\", DISPATCH_QUEUE_CONCURRENT);\nfor (int i = 0; i < 1000000 ; i++) {\n    dispatch_async(queue, ^{\n        self.str = [NSString stringWithFormat:@\"changzifuchaung:%d\",i];\n    });\n}\n复制代码\n```\n\n会`crash`。因为在并行队列`DISPATCH_QUEUE_CONCURRENT`中异步`dispatch_async`对`str`属性进行赋值，就会导致`str`已经被`release`了，还会执行`release`。这就是向已释放内存的对象发送消息而发生`crash` 详细解析：对`str`属性`strong`修饰进行赋值，相当与`MRC`中的\n\n```\n- (void)setStr:(NSString *)str{\n    if (str == _str) return;\n    id pre = _str;\n    [str retain];//1.先保留新值\n    _str = str;//2.再进行赋值\n    [pre release];//3.释放旧值\n}\n复制代码\n```\n\n那么假如`并发队列`里调度的`线程A`执行到`步骤1`，还没到`步骤2`时，`线程B`执行到`步骤3`，那么当`线程A`再执行`步骤3`时，旧值就会被`过度释放`，导致向已释放内存的对象发送消息而崩溃\n\n- 追问：怎么修改这段代码变为不崩溃呢\n\n> 1、使用串行队列 将`set`方法改成在串行队列中执行就行，这样即使异步，但所有`block`操作追加在队列最后依次执行 2、使用`atomic` `atomic`关键字相当于在`setter`方法加锁，这样每次执行`setter`都是线程安全的，但这只是单独针对`setter`方法而言的狭义的线程安全 3、使用`weak`关键字 `weak`的`setter`没有`保留新值`的操作，所以不会引发重复释放。当然这个时候要看具体情况能否使用`weak`，可能值并不是所需要的值 4、使用互斥锁，保证数据访问的唯一性`@synchronized (self) {self.str = [NSString stringWithFormat:@\"changzifuchaung:%d\",i];}` 5、使用`Tagged Pointer` `Tagged Pointer`是苹果在64位系统引入的内存技术。简单来说就是对于`NSString`(内存小于60位的字符串)或`NSNumber`(小于2^31)，64位的指针有8个字节，完全可以直接用这个空间来直接表示值，这样的话其实会将`NSString`和`NSNumber`对象由一个`指针`转换成一个`值类型`，而值类型的`setter和getter`又是原子的，从而线程安全\n\n- 发散：下面代码会`crash`吗\n\n```\n@property (nonatomic, strong) NSString *str;\n\ndispatch_queue_t queue = dispatch_queue_create(\"parallel\", DISPATCH_QUEUE_CONCURRENT);\nfor (int i = 0; i < 1000000 ; i++) {\n    dispatch_async(queue, ^{\n        // 相比上面，仅字符串变短了\n        self.str = [NSString stringWithFormat:@\"%d\",i];\n        NSLog(@\"%d, %s, %p\", i, object_getClassName(self.str), self.str);\n    });\n}\n复制代码\n```\n\n不会`crash`。而且发现`str`这个字符串类型是`NSTaggedPointerString` `Tagged Pointer`是一个能够提升性能、节省内存的有趣的技术 `Tagged Pointer`专门用来存储小的对象，例如`NSNumber`和`NSDate`(后来可以存储小字符串) `Tagged Pointer指针的值`不再是`地址`了，而是`真正的值`。所以，实际上它不再是一个`对象`了，它只是一个披着对象皮的`普通变量`而已 它的内存并不存储在`堆`中，也不需要`malloc和free`，所以拥有极快的读取和创建速度\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('32', 'chenin', 'iOS', '面试经验', '1. `UIView`和`CALayer`是什么关系\n\n> - `UIView`继承自`UIResponder`类，可以响应事件\n> - `CALayer`直接继承自`NSObject`类，不可以响应事件\n> - `UIView`是`CALayer`的`delegate`(`CALayerDelegate`)\n> - `UIView`主要处理事件，`CALayer`负责绘制\n> - 每个`UIView`内部都有一个`CALayer`在背后提供内容的绘制和显示，并且`UIView`的尺寸样式都由内部的`Layer`所提供。两者都有树状层级结构，`Layer`内部有`SubLayers`，`View`内部有`SubViews`，但是`Layer`比`View`多了个`AnchorPoint`\n\n1. `NSCache`和`NSMutableDictionary`的相同点与区别\n\n> 相同点： `NSCache`和`NSMutableDictionary`功能用法基本是相同的 区别： `NSCache`是线程安全的，`NSMutableDictionary`线程不安全，`Mutable开发的类`一般都是线程不安全的 当内存不足时`NSCache`会自动释放内存(所以从缓存中取数据的时候总要判断是否为空) `NSCache`可以指定缓存的限额，当缓存超出限额自动释放内存 `NSCache`的`Key`只是对对象进行了`Strong`引用，而非拷贝，所以不需要实现`NSCopying`协议\n\n1. `atomic`的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）\n\n> - `atomic`会对属性的`setter/getter`方法进行加锁，这仅仅只能保证在操作`setter/getter`方法是安全的。不能保证其他线程的安全\n> - 例如：线程1调用了某一属性的`setter`方法并进行到了一半，线程2调用其`getter`方法，那么会执行完`setter`操作后，再执行`getter`操作，线程2会获取到线程1`setter`后的完整的值；当几个线程同时调用同一属性的`setter、getter`方法时，会获取到一个完整的值，但获取到的值不可控\n\n1. iOS 中内省的几个方法\n\n> 对象在运行时获取其类型的能力称为内省。内省可以有多种方法实现 OC运行时内省的4个方法：\n\n- 判断对象类型：\n\n```\n-(BOOL) isKindOfClass:            // 判断是否是这个类或者这个类的子类的实例\n-(BOOL) isMemberOfClass:      // 判断是否是这个类的实例\n复制代码\n```\n\n- 判断对象/类是否有这个方法\n\n```\n-(BOOL) respondsToSelector:                      // 判断实例是否有这样方法\n+(BOOL) instancesRespondToSelector:      // 判断类是否有这个方法\n复制代码\n```\n\n1. `objc`在向一个对象发送消息时，发生了什么\n\n> 根据对象的isa指针找到该对象所属的类，去objc的对应的类中找方法 1.首先，在相应操作的对象中的缓存方法列表中找调用的方法，如果找到，转向相应实现并执行 2.如果没找到，在相应操作的对象中的方法列表中找调用的方法，如果找到，转向相应实现执行 3.如果没找到，去父类指针所指向的对象中执行1，2. 4.以此类推，如果一直到根类还没找到，转向拦截调用，走消息转发机制 5.如果没有重写拦截调用的方法，程序报错\n\n1. 你是否接触过OC中的反射机制？简单聊一下概念和使用\n\n- `class`反射\n- 通过类名的字符串形式实例化对象\n\n```\nClass class = NSClassFromString(@\"student\"); \nStudent *stu = [[class alloc] init];\n复制代码\n```\n\n- 将类名变为字符串\n\n```\nClass class = [Student class];\nNSString *className = NSStringFromClass(class);\n复制代码\n```\n\n- `SEL`的反射\n- 通过方法的字符串形式实例化方法\n\n```\nSEL selector = NSSelectorFromString(@\"setName\");\n[stu performSelector:selector withObject:@\"Mike\"];\n复制代码\n```\n\n- 将方法变成字符串 `NSStringFromSelector(@selector(setName:));`\n\n1. 这个写法会出什么问题`@property (nonatomic, copy) NSMutableArray *arr;`\n\n> 添加，删除，修改数组内元素的时候，程序会因为找不到对应的方法而崩溃。原因：是因为`copy`就是复制一个不可变`NSArray`的对象，不能对`NSArray`对象进行添加/修改\n\n1. 如何让自己的类用`copy`修饰符\n\n> 若想令自己所写的对象具有拷贝功能，则需实现`NSCopying`协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现`NSCopying`与`NSMutableCopying`协议。 具体步骤： 1.需声明该类遵从`NSCopying`协议 2.实现`NSCopying`协议的方法，具体区别[戳这里](http://www.jianshu.com/p/f84803356cbb)\n\n- `NSCopying`协议方法为：\n\n```\n- (id)copyWithZone:(NSZone *)zone {\n  MyObject *copy = [[[self class] allocWithZone: zone] init];\n  copy.username = self.username;\n  return copy;\n}\n复制代码\n```\n\n1. 为什么`assign`不能用于修饰对象\n\n> 首先我们需要明确，对象的内存一般被分配到堆上，基本数据类型和oc数据类型的内存一般被分配在栈上 如果用`assign`修饰对象，当对象被释放后，指针的地址还是存在的，也就是说指针并没有被置为`nil`，从而造成了野指针。因为对象是分配在堆上的，堆上的内存由程序员分配释放。而因为指针没有被置为`nil`，如果后续的内存分配中，刚好分配到了这块内存，就会造成崩溃 而`assign`修饰基本数据类型或oc数据类型，因为基本数据类型是分配在栈上的，由系统分配和释放，所以不会造成野指针\n\n1. 请写出以下代码输出\n\n```\n int a[5] = {1, 2, 3, 4, 5};\n int *ptr = (int *)(&a + 1);\n printf(\"%d, %d\", *(a + 1), *(ptr + 1));\n复制代码\n```\n\n> 参考答案：2，随机值 分析： `a`代表有5个元素的数组的首地址，`a[5]`的元素分别是1，2，3，4，5。接下来，`a + 1`表示数据首地址加1，那么就是`a[1]`，也就是对应于值为2，但是，这里是`&a + 1`，因为`a`代表的是整个数组，它的空间大小为`5 * sizeof(int)`，因此`&a + 1`就是`a + 5`。`a`是个常量指针，指向当前数组的首地址，指针+1就是移动`sizeof(int)`个字节 因此，`ptr`是指向`int *`类型的指针，而`ptr`指向的就是`a + 5`，那么`ptr + 1`也相当于`a + 6`，所以最后的`*(ptr + 1)`就是一个随机值了。而`*(ptr – 1)`就相当于`a + 4`，对应的值就是5\n\n1. 一个`view`已经初始化完毕，`view`上面添加了n个`button`（可能使用循环创建），除用`view`的`tag`之外，还可以采用什么办法来找到自己想要的`button`来修改`Button`的值\n\n> 第一种：如果是点击某个按钮后，才会刷新它的值，其它不用修改，那么不用引用任何按钮，直接在回调时，就已经将接收响应的按钮给传过来了，直接通过它修改即可 第二种：点击某个按钮后，所有与之同类型的按钮都要修改值，那么可以通过在创建按钮时将按钮存入到数组中，在需要的时候遍历查找\n\n1. `UIViewController`的`viewDidUnload、viewDidLoad`和`loadView`分别什么时候调用？`UIView`的`drawRect`和`layoutSubviews`分别起什么作用\n\n> 第一个问题： 在控制器被销毁前会调用`viewDidUnload`（`MRC`下才会调用） 在控制器没有任何`view`时，会调用`loadView` 在`view`加载完成时，会调用`viewDidLoad` 第二个问题： 在调用`setNeedsDisplay`后，会调用`drawRect`方法，我们通过在此方法中可以获取到`context`（设置上下文），就可以实现绘图 在调用`setNeedsLayout`后，会调用`layoutSubviews`方法，我们可以通过在此方法去调整UI。当然能引起`layoutSubviews`调用的方式有很多种的，比如添加子视图、滚动`scrollview`、修改视图的`frame`等\n\n1. 自动释放池工作原理\n\n> 自动释放池是`NSAutorelease`类的一个实例，当向一个对象发送`autorelease`消息时，该对象会自动入池，待池销毁时，将会向池中所有对象发送一条`release`消息，释放对象 `[pool release]、[pool drain]`表示的是池本身不会销毁，而是池子中的临时对象都被发送`release`，从而将对象销毁\n\n1. 苹果是如何实现`autoreleasepool`的\n\n> `autoreleasepool`是由`AutoreleasePoolPage`以双向链表的方式实现的，主要通过下列三个函数完成：\n>\n> - 由`objc_autoreleasePoolPush`作为自动释放池作用域的第一个函数\n> - 使用`objc_autorelease`将对象加入自动释放池\n> - 由`objc_autoreleasePoolPop`作为自动释放池作用域的最后一个函数\n\n1. `autorelease`的对象何时被释放\n\n> `RunLoop`在每个事件循环结束后会去自动释放池将所有自动释放对象的引用计数减一，若引用计数变成了0，则会将对象真正销毁掉，回收内存。 在没有手动添加`Autorelease Pool`的情况下，`autorelease`的对象是在每个事件循环结束后，自动释放池才会对所有自动释放的对象的引用计数减一，若引用计数变成了0，则释放对象，回收内存。因此，若想要早一点释放掉`autorelease`对象，那么我们可以在对象外加一个自动释放池。比如，在循环处理数据时，临时变量要快速释放，就应该采用这种方式：\n\n```\n// 通过alloc创建的对象，直接加入@autoreleasepool没有作用，需在创建对象后面显式添加autorelease\n// 通过类方法创建的对象不需要显式添加autorelease，原因是类方法创建的对象系统会自动添加autorelease\nfor (int i = 0; i < 1000000; i++) {\n @autoreleasepool {\n   NSString *str = @\"Abc\";\n   str = [str lowercaseString];\n   str = [str stringByAppendingString:@\"xyz\"];\n   NSLog(@\"%@\", str);\n } // 出了这里，就会去遍历该自动释放池了\n}\n复制代码\n```\n\n1. 简述内存管理基本原则\n\n> OC内存管理遵循`谁创建，谁释放，谁引用，谁管理`的机制，当使用`alloc、copy(mutableCopy)或者retian`一个对象时，你就有义务向它发送一条`release或者autorelease`消息释放该对象，其他方法创建的对象，不需要由你来管理内存，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制（`MRC`） 向一个对象发送一条`autorelease`消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池中每一个对象发送一条`release`消息，以此来释放对象 向一个对象发送`release`消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为0时，系统才会调用`dealloc`方法释放该对象和对象本身所拥有的实例\n\n1. `sizeof`关键字\n\n> `sizeof`是在编译阶段处理，且不能被编译为机器码。`sizeof`的结果等于对象或类型所占的内存字节数。`sizeof`的返回值类型为`size_t` 变量：`int a; sizeof(a)`为4； 指针：`int *p; sizeof(p)`为4； 数组：`int b[10]; sizeof(b)`为数组的大小4*10；`int c[0]; sizeof(c)`等于0 `sizeof(void)`等于1 `sizeof(void *)`等于4\n\n1. 什么是离屏渲染？什么情况下会触发？离屏渲染消耗性能的原因\n\n> 离屏渲染就是在当前屏幕缓冲区以外，新开辟一个缓冲区进行操作 离屏渲染触发的场景有以下：\n>\n> - 圆角（同时设置`layer.masksToBounds = YES、layer.cornerRadius`大于0）\n> - 图层蒙版\n> - 阴影，`layer.shadowXXX`，如果设置了`layer.shadowPath`就不会产生离屏渲染\n> - 遮罩，`layer.mask`\n> - 光栅化，`layer.shouldRasterize = YES`\n\n> 离屏渲染消耗性能的原因 需要创建新的缓冲区，离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（`On-Screen`）切换到离屏（`Off-Screen`）等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕\n\n1. ARC 下，不显式指定任何属性关键字时，默认的关键字都有哪些\n\n> 基本数据类型默认关键字是：`atomic, readwrite, assign` 普通`Objective-C`对象默认关键字是：`atomic, readwrite, strong`\n\n1. OC中的类方法和实例方法有什么本质区别和联系\n\n> 类方法：\n>\n> - 类方法是属于类对象的\n> - 类方法只能通过类对象调用\n> - 类方法中的 self 是类对象\n> - 类方法可以调用其他的类方法\n> - 类方法中不能访问成员变量\n> - 类方法中不能直接调用对象方法\n\n> 实例方法：\n>\n> - 实例方法是属于实例对象的\n> - 实例方法只能通过实例对象调用\n> - 实例方法中的 self 是实例对象\n> - 实例方法中可以访问成员变量\n> - 实例方法中直接调用实例方法\n> - 实例方法中也可以调用类方法（通过类名）\n\n1. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\n\n> - 不能向编译后得到的类中增加实例变量\n> - 能向运行时创建的类中添加实例变量\n> - 因为编译后的类已经注册在`runtime`中，类结构体中的`objc_ivar_list`实例变量的链表和`instance_size`实例变量的内存大小已经确定，同时`runtime`会调用`class_setIvarLayout`或`class_setWeakIvarLayout`来处理`strong weak`引用，所以不能向存在的类中添加实例变量 运行时创建的类是可以添加实例变量，调用`class_addIvar`函数。但是得在调用`objc_allocateClassPair`之后，`objc_registerClassPair`之前，原因同上\n\n1. `runtime`如何通过`selector`找到对应的`IMP`地址（分别考虑实例方法和类方法）`Selector、Method 和 IMP`的有什么区别与联系\n\n> 对于实例方法，每个实例的`isa`指针指向着对应类对象，而每一个类对象中都有一个对象方法列表。对于类方法，每个类对象的`isa`指针都指向着对应的元类对象，而每一个元类对象中都有一个类方法列表。方法列表中记录着方法的名称，方法实现，以及参数类型，其实`selector`本质就是方法名称，通过这个方法名称就可以在方法列表中找到对应的方法实现 `Selector、Method 和 IMP`的关系可以这样描述：在运行期分发消息，方法列表中的每一个实体都是一个方法（`Method`）它的名字叫做选择器（`SEL`）对应着一种方法实现（`IMP`）\n\n1. `objc_msgSend、_objc_msgForward`都是做什么的？OC 中的消息调用流程是怎样的\n\n> - `objc_msgSend`是用来做消息发送的。在`OC`中，对方法的调用都会被转换成内部的消息发送执行\n>\n> - `_objc_msgForward`是`IMP`类型（函数指针）用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发\n>\n> - 在消息调用的过程中，\n>\n>   ```\n>   objc_msgSend\n>   ```\n>\n>   的动作比较清晰：首先在\n>\n>   ```\n>   Class\n>   ```\n>\n>   中的缓存查找\n>\n>   ```\n>   IMP\n>   ```\n>\n>   （没缓存则初始化缓存）如果没找到，则向父类的\n>\n>   ```\n>   Class\n>   ```\n>\n>   查找。如果一直查找到根类仍旧没有实现，则用\n>\n>   ```\n>   _objc_msgForward\n>   ```\n>\n>   函数指针代替\n>\n>   ```\n>   IMP\n>   ```\n>\n>   。最后，执行这个\n>\n>   ```\n>   IMP\n>   ```\n>\n>   。当调用一个\n>\n>   ```\n>   NSObject\n>   ```\n>\n>   对象不存在的方法时，并不会马上抛出异常，而是会经过多层转发，层层调用对象的\n>\n>   ```\n>   -resolveInstanceMethod:、-forwardingTargetForSelector:、-methodSignatureForSelector:、-forwardInvocation:\n>   ```\n>\n>   等方法。其中最后\n>\n>   ```\n>   -forwardInvocation:\n>   ```\n>\n>   是会有一个\n>\n>   ```\n>   NSInvocation\n>   ```\n>\n>   对象，这个\n>\n>   ```\n>   NSInvocation\n>   ```\n>\n>   对象保存了这个方法调用的所有信息，包括\n>\n>   ```\n>   Selector名，参数和返回值类型\n>   ```\n>\n>   ，可以从这个\n>\n>   ```\n>   NSInvocation\n>   ```\n>\n>   对象里拿到调用的所有参数值\n>\n>   ![img](https://user-gold-cdn.xitu.io/2019/12/18/16f180e8604f5b40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n1. `class`方法和`objc_getClass`方法有什么区别\n\n> `object_getClass(obj)`返回的是`obj`中的`isa`指针，即指向类对象的指针；而`[obj class]`则分两种情况：一是当`obj`为实例对象时，`[obj class]`中`class`是实例方法，返回的是`obj`对象中的`isa`指针；二是当`obj`为类对象（包括元类和根类以及根元类）时，调用的是类方法，返回的结果为其本身\n\n1. OC中向一个`nil`对象发送消息将会发生什么\n\n> 在`OC`中向`nil`发送消息是完全有效的，只是在运行时不会有任何作用；向一个`nil`对象发送消息，首先在寻找对象的`isa`指针时就是`0地址`返回了，所以不会出现任何错误，也不会崩溃\n\n1. `_objc_msgForward`函数是做什么的？直接调用它将会发生什么\n\n> ```\n> _objc_msgForward`是一个函数指针（和`IMP`的类型一样）用于消息转发；当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发 `objc_msgSend`在`消息传递`中的作用。在`消息传递`过程中，`objc_msgSend`的动作比较清晰：首先在`Class`中的缓存查找`IMP`（`没有缓存则初始化缓存`）如果没找到，则向`父类的Class`查找。如果一直查找到`根类`仍旧没有实现，则用`_objc_msgForward`函数指针代替`IMP`，最后执行这个`IMP` 一旦调用了`_objc_msgForward`，将跳过查找`IMP`的过程，直接触发`消息转发`，如果调用了`_objc_msgForward`，即使这个对象确实已经实现了这个方法，你也会告诉`objc_msgSend`，我没有在这个对象里找到这个方法的实现，如果用不好会直接导致程序`Crash\n> ```\n\n1. 什么时候会报`unrecognized selector`的异常\n\n- 当调用该对象上某个方法，而该对象上没有实现这个方法的时候。可以通过\n\n  ```\n  消息转发\n  ```\n\n  进行解决，流程见下图\n\n  ![img](https://user-gold-cdn.xitu.io/2019/12/18/16f180e8604f5b40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n- `OC`在向一个对象发送消息时，`runtime`库会根据对象的`isa`指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常`unrecognized selector sent to XXX` **但是在这之前，OC的运行时会给出三次拯救程序崩溃的机会**\n\n- Method resolution（消息动态解析） `OC`运行时会调用`+resolveInstanceMethod:`或者`+resolveClassMethod:`，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则，运行时就会移到下一步，消息转发（`Message Forwarding`）\n\n```\n// 重写 resolveInstanceMethod: 添加对象方法实现\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    // 如果是执行 run 函数，就动态解析，指定新的 IMP\n    if (sel == NSSelectorFromString(@\"run:\")) {\n        // class: 给哪个类添加方法\n        // SEL: 添加哪个方法\n        // IMP: 方法实现 => 函数 => 函数入口 => 函数名\n        // type: 方法类型：void用v来表示，id参数用@来表示，SEL用:来表示\n        class_addMethod(self, sel, (IMP)runMethod, \"v@:@\");\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n\n//新的 run 函数\nvoid runMethod(id self, SEL _cmd, NSNumber *meter) {\n    NSLog(@\"跑了%@\", meter);\n}\n复制代码\n```\n\n- Fast forwarding（消息接受者重定向） 如果目标对象实现了`-forwardingTargetForSelector:`，`Runtime`这时就会调用这个方法，给你把这个消息转发给其他对象的机会。只要这个方法返回的不是`nil`和`self`，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续`Normal Fowarding`。 这里叫`Fast`，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个`NSInvocation`对象，所以相对更快点\n\n```\n// 消息接受者重定向\n- (id)forwardingTargetForSelector:(SEL)aSelector{\n    if (aSelector == @selector(run:)) {\n        return [[Person alloc] init];\n        // 返回 Person 对象，让 Person 对象接收这个消息\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n复制代码\n```\n\n- Normal forwarding（消息重定向） 这一步是`Runtime`最后一次给你挽救的机会。首先它会发送`-methodSignatureForSelector:`消息获得函数的参数和返回值类型。如果`-methodSignatureForSelector:`返回`nil`，`Runtime`则会发出`-doesNotRecognizeSelector:`消息，程序这时也就挂掉了。如果返回了一个函数签名，`Runtime`就会创建一个`NSInvocation`对象并发送`-forwardInvocation:`消息给目标对象\n\n```\n// 获取函数的参数和返回值类型，返回签名\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if ([NSStringFromSelector(aSelector) isEqualToString:@\"run:\"]) {\n        return [NSMethodSignature signatureWithObjCTypes:\"v@:@\"];\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n// 消息重定向\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    // 从 anInvocation 中获取消息\n    SEL sel = anInvocation.selector;\n    if (sel == NSSelectorFromString(@\"run:\")) {\n        // 1. 指定当前类的一个方法作为IMP\n        // anInvocation.selector = @selector(readBook:);\n        // [anInvocation invoke];\n        \n        // 2. 指定其他类来执行这个IMP\n        Person *p = [[Person alloc] init];\n        // 判断 Person 对象方法是否可以响应 sel\n        if([p respondsToSelector:sel]) {\n            // 若可以响应，则将消息转发给其他对象处理\n            [anInvocation invokeWithTarget:p];\n        } else {\n            // 若仍然无法响应，则报错：找不到响应方法\n            [self doesNotRecognizeSelector:sel];\n        }\n    }else{\n        [super forwardInvocation:anInvocation];\n    }\n}\n\n- (void)doesNotRecognizeSelector:(SEL)aSelector {\n    [super doesNotRecognizeSelector:aSelector];\n}\n复制代码\n```\n\n**既然`-forwardingTargetForSelector:`和`-forwardInvocation:`都可以将消息转发给其他对象处理，那么两者的区别在哪？** 区别就在于`-forwardingTargetForSelector:`只能将消息转发给一个对象。而`-forwardInvocation:`可以把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。修改消息的target，selector，参数等。将消息转发给多个对象\n\n1. `iOS layoutSubviews`什么时候会被调用\n\n> - `init`方法不会调用`layoutSubviews`，但是是用`initWithFrame`进行初始化时，当`rect`的值不为`CGRectZero`时，会触发\n> - `addSubview`会触发`layoutSubviews`方法\n> - `setFrame`只有当设置的`frame`的参数的`size`与原来的`size`不同，才会触发其`view`的`layoutSubviews`方法\n> - 滑动`UIScrollView`会调用`scrollview`及`scrollview`上的`view`的`layoutSubviews`方法\n> - 旋转设备只会调用`VC`的`view`的`layoutSubviews`方法\n> - 直接调用`[self setNeedsLayout];`（这个在上面苹果官方文档里有说明） `-layoutSubviews`方法：这个方法默认没有做任何事情，需要子类进行重写 `-setNeedsLayout`方法：标记为需要重新布局，异步调用`layoutIfNeeded`刷新布局，不立即刷新，但`layoutSubviews`一定会被调用 `-layoutIfNeeded`方法：如果有需要刷新的标记，立即调用`layoutSubviews`进行布局（如果没有标记，不会调用`layoutSubviews`） 如果要立即刷新，要先调用`[view setNeedsLayout]`，把标记设为需要布局，然后马上调用`[view layoutIfNeeded]`，实现布局 在视图第一次显示之前，标记总是`需要刷新`的，可以直接调用`[view layoutIfNeeded]`\n\n1. 下面代码会发生什么问题\n\n```\n@property (nonatomic, strong) NSString *str;\n\ndispatch_queue_t queue = dispatch_queue_create(\"parallel\", DISPATCH_QUEUE_CONCURRENT);\nfor (int i = 0; i < 1000000 ; i++) {\n    dispatch_async(queue, ^{\n        self.str = [NSString stringWithFormat:@\"changzifuchaung:%d\",i];\n    });\n}\n复制代码\n```\n\n会`crash`。因为在并行队列`DISPATCH_QUEUE_CONCURRENT`中异步`dispatch_async`对`str`属性进行赋值，就会导致`str`已经被`release`了，还会执行`release`。这就是向已释放内存的对象发送消息而发生`crash` 详细解析：对`str`属性`strong`修饰进行赋值，相当与`MRC`中的\n\n```\n- (void)setStr:(NSString *)str{\n    if (str == _str) return;\n    id pre = _str;\n    [str retain];//1.先保留新值\n    _str = str;//2.再进行赋值\n    [pre release];//3.释放旧值\n}\n复制代码\n```\n\n那么假如`并发队列`里调度的`线程A`执行到`步骤1`，还没到`步骤2`时，`线程B`执行到`步骤3`，那么当`线程A`再执行`步骤3`时，旧值就会被`过度释放`，导致向已释放内存的对象发送消息而崩溃\n\n- 追问：怎么修改这段代码变为不崩溃呢\n\n> 1、使用串行队列 将`set`方法改成在串行队列中执行就行，这样即使异步，但所有`block`操作追加在队列最后依次执行 2、使用`atomic` `atomic`关键字相当于在`setter`方法加锁，这样每次执行`setter`都是线程安全的，但这只是单独针对`setter`方法而言的狭义的线程安全 3、使用`weak`关键字 `weak`的`setter`没有`保留新值`的操作，所以不会引发重复释放。当然这个时候要看具体情况能否使用`weak`，可能值并不是所需要的值 4、使用互斥锁，保证数据访问的唯一性`@synchronized (self) {self.str = [NSString stringWithFormat:@\"changzifuchaung:%d\",i];}` 5、使用`Tagged Pointer` `Tagged Pointer`是苹果在64位系统引入的内存技术。简单来说就是对于`NSString`(内存小于60位的字符串)或`NSNumber`(小于2^31)，64位的指针有8个字节，完全可以直接用这个空间来直接表示值，这样的话其实会将`NSString`和`NSNumber`对象由一个`指针`转换成一个`值类型`，而值类型的`setter和getter`又是原子的，从而线程安全\n\n- 发散：下面代码会`crash`吗\n\n```\n@property (nonatomic, strong) NSString *str;\n\ndispatch_queue_t queue = dispatch_queue_create(\"parallel\", DISPATCH_QUEUE_CONCURRENT);\nfor (int i = 0; i < 1000000 ; i++) {\n    dispatch_async(queue, ^{\n        // 相比上面，仅字符串变短了\n        self.str = [NSString stringWithFormat:@\"%d\",i];\n        NSLog(@\"%d, %s, %p\", i, object_getClassName(self.str), self.str);\n    });\n}\n复制代码\n```\n\n不会`crash`。而且发现`str`这个字符串类型是`NSTaggedPointerString` `Tagged Pointer`是一个能够提升性能、节省内存的有趣的技术 `Tagged Pointer`专门用来存储小的对象，例如`NSNumber`和`NSDate`(后来可以存储小字符串) `Tagged Pointer指针的值`不再是`地址`了，而是`真正的值`。所以，实际上它不再是一个`对象`了，它只是一个披着对象皮的`普通变量`而已 它的内存并不存储在`堆`中，也不需要`malloc和free`，所以拥有极快的读取和创建速度\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('33', 'chenin', 'iOS', 'iOS相关知识', '1. `UIView`和`CALayer`是什么关系\n\n> - `UIView`继承自`UIResponder`类，可以响应事件\n> - `CALayer`直接继承自`NSObject`类，不可以响应事件\n> - `UIView`是`CALayer`的`delegate`(`CALayerDelegate`)\n> - `UIView`主要处理事件，`CALayer`负责绘制\n> - 每个`UIView`内部都有一个`CALayer`在背后提供内容的绘制和显示，并且`UIView`的尺寸样式都由内部的`Layer`所提供。两者都有树状层级结构，`Layer`内部有`SubLayers`，`View`内部有`SubViews`，但是`Layer`比`View`多了个`AnchorPoint`\n\n1. `NSCache`和`NSMutableDictionary`的相同点与区别\n\n> 相同点： `NSCache`和`NSMutableDictionary`功能用法基本是相同的 区别： `NSCache`是线程安全的，`NSMutableDictionary`线程不安全，`Mutable开发的类`一般都是线程不安全的 当内存不足时`NSCache`会自动释放内存(所以从缓存中取数据的时候总要判断是否为空) `NSCache`可以指定缓存的限额，当缓存超出限额自动释放内存 `NSCache`的`Key`只是对对象进行了`Strong`引用，而非拷贝，所以不需要实现`NSCopying`协议\n\n1. `atomic`的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）\n\n> - `atomic`会对属性的`setter/getter`方法进行加锁，这仅仅只能保证在操作`setter/getter`方法是安全的。不能保证其他线程的安全\n> - 例如：线程1调用了某一属性的`setter`方法并进行到了一半，线程2调用其`getter`方法，那么会执行完`setter`操作后，再执行`getter`操作，线程2会获取到线程1`setter`后的完整的值；当几个线程同时调用同一属性的`setter、getter`方法时，会获取到一个完整的值，但获取到的值不可控\n\n1. iOS 中内省的几个方法\n\n> 对象在运行时获取其类型的能力称为内省。内省可以有多种方法实现 OC运行时内省的4个方法：\n\n- 判断对象类型：\n\n```\n-(BOOL) isKindOfClass:            // 判断是否是这个类或者这个类的子类的实例\n-(BOOL) isMemberOfClass:      // 判断是否是这个类的实例\n复制代码\n```\n\n- 判断对象/类是否有这个方法\n\n```\n-(BOOL) respondsToSelector:                      // 判断实例是否有这样方法\n+(BOOL) instancesRespondToSelector:      // 判断类是否有这个方法\n复制代码\n```\n\n1. `objc`在向一个对象发送消息时，发生了什么\n\n> 根据对象的isa指针找到该对象所属的类，去objc的对应的类中找方法 1.首先，在相应操作的对象中的缓存方法列表中找调用的方法，如果找到，转向相应实现并执行 2.如果没找到，在相应操作的对象中的方法列表中找调用的方法，如果找到，转向相应实现执行 3.如果没找到，去父类指针所指向的对象中执行1，2. 4.以此类推，如果一直到根类还没找到，转向拦截调用，走消息转发机制 5.如果没有重写拦截调用的方法，程序报错\n\n1. 你是否接触过OC中的反射机制？简单聊一下概念和使用\n\n- `class`反射\n- 通过类名的字符串形式实例化对象\n\n```\nClass class = NSClassFromString(@\"student\"); \nStudent *stu = [[class alloc] init];\n复制代码\n```\n\n- 将类名变为字符串\n\n```\nClass class = [Student class];\nNSString *className = NSStringFromClass(class);\n复制代码\n```\n\n- `SEL`的反射\n- 通过方法的字符串形式实例化方法\n\n```\nSEL selector = NSSelectorFromString(@\"setName\");\n[stu performSelector:selector withObject:@\"Mike\"];\n复制代码\n```\n\n- 将方法变成字符串 `NSStringFromSelector(@selector(setName:));`\n\n1. 这个写法会出什么问题`@property (nonatomic, copy) NSMutableArray *arr;`\n\n> 添加，删除，修改数组内元素的时候，程序会因为找不到对应的方法而崩溃。原因：是因为`copy`就是复制一个不可变`NSArray`的对象，不能对`NSArray`对象进行添加/修改\n\n1. 如何让自己的类用`copy`修饰符\n\n> 若想令自己所写的对象具有拷贝功能，则需实现`NSCopying`协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现`NSCopying`与`NSMutableCopying`协议。 具体步骤： 1.需声明该类遵从`NSCopying`协议 2.实现`NSCopying`协议的方法，具体区别[戳这里](http://www.jianshu.com/p/f84803356cbb)\n\n- `NSCopying`协议方法为：\n\n```\n- (id)copyWithZone:(NSZone *)zone {\n  MyObject *copy = [[[self class] allocWithZone: zone] init];\n  copy.username = self.username;\n  return copy;\n}\n复制代码\n```\n\n1. 为什么`assign`不能用于修饰对象\n\n> 首先我们需要明确，对象的内存一般被分配到堆上，基本数据类型和oc数据类型的内存一般被分配在栈上 如果用`assign`修饰对象，当对象被释放后，指针的地址还是存在的，也就是说指针并没有被置为`nil`，从而造成了野指针。因为对象是分配在堆上的，堆上的内存由程序员分配释放。而因为指针没有被置为`nil`，如果后续的内存分配中，刚好分配到了这块内存，就会造成崩溃 而`assign`修饰基本数据类型或oc数据类型，因为基本数据类型是分配在栈上的，由系统分配和释放，所以不会造成野指针\n\n1. 请写出以下代码输出\n\n```\n int a[5] = {1, 2, 3, 4, 5};\n int *ptr = (int *)(&a + 1);\n printf(\"%d, %d\", *(a + 1), *(ptr + 1));\n复制代码\n```\n\n> 参考答案：2，随机值 分析： `a`代表有5个元素的数组的首地址，`a[5]`的元素分别是1，2，3，4，5。接下来，`a + 1`表示数据首地址加1，那么就是`a[1]`，也就是对应于值为2，但是，这里是`&a + 1`，因为`a`代表的是整个数组，它的空间大小为`5 * sizeof(int)`，因此`&a + 1`就是`a + 5`。`a`是个常量指针，指向当前数组的首地址，指针+1就是移动`sizeof(int)`个字节 因此，`ptr`是指向`int *`类型的指针，而`ptr`指向的就是`a + 5`，那么`ptr + 1`也相当于`a + 6`，所以最后的`*(ptr + 1)`就是一个随机值了。而`*(ptr – 1)`就相当于`a + 4`，对应的值就是5\n\n1. 一个`view`已经初始化完毕，`view`上面添加了n个`button`（可能使用循环创建），除用`view`的`tag`之外，还可以采用什么办法来找到自己想要的`button`来修改`Button`的值\n\n> 第一种：如果是点击某个按钮后，才会刷新它的值，其它不用修改，那么不用引用任何按钮，直接在回调时，就已经将接收响应的按钮给传过来了，直接通过它修改即可 第二种：点击某个按钮后，所有与之同类型的按钮都要修改值，那么可以通过在创建按钮时将按钮存入到数组中，在需要的时候遍历查找\n\n1. `UIViewController`的`viewDidUnload、viewDidLoad`和`loadView`分别什么时候调用？`UIView`的`drawRect`和`layoutSubviews`分别起什么作用\n\n> 第一个问题： 在控制器被销毁前会调用`viewDidUnload`（`MRC`下才会调用） 在控制器没有任何`view`时，会调用`loadView` 在`view`加载完成时，会调用`viewDidLoad` 第二个问题： 在调用`setNeedsDisplay`后，会调用`drawRect`方法，我们通过在此方法中可以获取到`context`（设置上下文），就可以实现绘图 在调用`setNeedsLayout`后，会调用`layoutSubviews`方法，我们可以通过在此方法去调整UI。当然能引起`layoutSubviews`调用的方式有很多种的，比如添加子视图、滚动`scrollview`、修改视图的`frame`等\n\n1. 自动释放池工作原理\n\n> 自动释放池是`NSAutorelease`类的一个实例，当向一个对象发送`autorelease`消息时，该对象会自动入池，待池销毁时，将会向池中所有对象发送一条`release`消息，释放对象 `[pool release]、[pool drain]`表示的是池本身不会销毁，而是池子中的临时对象都被发送`release`，从而将对象销毁\n\n1. 苹果是如何实现`autoreleasepool`的\n\n> `autoreleasepool`是由`AutoreleasePoolPage`以双向链表的方式实现的，主要通过下列三个函数完成：\n>\n> - 由`objc_autoreleasePoolPush`作为自动释放池作用域的第一个函数\n> - 使用`objc_autorelease`将对象加入自动释放池\n> - 由`objc_autoreleasePoolPop`作为自动释放池作用域的最后一个函数\n\n1. `autorelease`的对象何时被释放\n\n> `RunLoop`在每个事件循环结束后会去自动释放池将所有自动释放对象的引用计数减一，若引用计数变成了0，则会将对象真正销毁掉，回收内存。 在没有手动添加`Autorelease Pool`的情况下，`autorelease`的对象是在每个事件循环结束后，自动释放池才会对所有自动释放的对象的引用计数减一，若引用计数变成了0，则释放对象，回收内存。因此，若想要早一点释放掉`autorelease`对象，那么我们可以在对象外加一个自动释放池。比如，在循环处理数据时，临时变量要快速释放，就应该采用这种方式：\n\n```\n// 通过alloc创建的对象，直接加入@autoreleasepool没有作用，需在创建对象后面显式添加autorelease\n// 通过类方法创建的对象不需要显式添加autorelease，原因是类方法创建的对象系统会自动添加autorelease\nfor (int i = 0; i < 1000000; i++) {\n @autoreleasepool {\n   NSString *str = @\"Abc\";\n   str = [str lowercaseString];\n   str = [str stringByAppendingString:@\"xyz\"];\n   NSLog(@\"%@\", str);\n } // 出了这里，就会去遍历该自动释放池了\n}\n复制代码\n```\n\n1. 简述内存管理基本原则\n\n> OC内存管理遵循`谁创建，谁释放，谁引用，谁管理`的机制，当使用`alloc、copy(mutableCopy)或者retian`一个对象时，你就有义务向它发送一条`release或者autorelease`消息释放该对象，其他方法创建的对象，不需要由你来管理内存，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制（`MRC`） 向一个对象发送一条`autorelease`消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池中每一个对象发送一条`release`消息，以此来释放对象 向一个对象发送`release`消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为0时，系统才会调用`dealloc`方法释放该对象和对象本身所拥有的实例\n\n1. `sizeof`关键字\n\n> `sizeof`是在编译阶段处理，且不能被编译为机器码。`sizeof`的结果等于对象或类型所占的内存字节数。`sizeof`的返回值类型为`size_t` 变量：`int a; sizeof(a)`为4； 指针：`int *p; sizeof(p)`为4； 数组：`int b[10]; sizeof(b)`为数组的大小4*10；`int c[0]; sizeof(c)`等于0 `sizeof(void)`等于1 `sizeof(void *)`等于4\n\n1. 什么是离屏渲染？什么情况下会触发？离屏渲染消耗性能的原因\n\n> 离屏渲染就是在当前屏幕缓冲区以外，新开辟一个缓冲区进行操作 离屏渲染触发的场景有以下：\n>\n> - 圆角（同时设置`layer.masksToBounds = YES、layer.cornerRadius`大于0）\n> - 图层蒙版\n> - 阴影，`layer.shadowXXX`，如果设置了`layer.shadowPath`就不会产生离屏渲染\n> - 遮罩，`layer.mask`\n> - 光栅化，`layer.shouldRasterize = YES`\n\n> 离屏渲染消耗性能的原因 需要创建新的缓冲区，离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（`On-Screen`）切换到离屏（`Off-Screen`）等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕\n\n1. ARC 下，不显式指定任何属性关键字时，默认的关键字都有哪些\n\n> 基本数据类型默认关键字是：`atomic, readwrite, assign` 普通`Objective-C`对象默认关键字是：`atomic, readwrite, strong`\n\n1. OC中的类方法和实例方法有什么本质区别和联系\n\n> 类方法：\n>\n> - 类方法是属于类对象的\n> - 类方法只能通过类对象调用\n> - 类方法中的 self 是类对象\n> - 类方法可以调用其他的类方法\n> - 类方法中不能访问成员变量\n> - 类方法中不能直接调用对象方法\n\n> 实例方法：\n>\n> - 实例方法是属于实例对象的\n> - 实例方法只能通过实例对象调用\n> - 实例方法中的 self 是实例对象\n> - 实例方法中可以访问成员变量\n> - 实例方法中直接调用实例方法\n> - 实例方法中也可以调用类方法（通过类名）\n\n1. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\n\n> - 不能向编译后得到的类中增加实例变量\n> - 能向运行时创建的类中添加实例变量\n> - 因为编译后的类已经注册在`runtime`中，类结构体中的`objc_ivar_list`实例变量的链表和`instance_size`实例变量的内存大小已经确定，同时`runtime`会调用`class_setIvarLayout`或`class_setWeakIvarLayout`来处理`strong weak`引用，所以不能向存在的类中添加实例变量 运行时创建的类是可以添加实例变量，调用`class_addIvar`函数。但是得在调用`objc_allocateClassPair`之后，`objc_registerClassPair`之前，原因同上\n\n1. `runtime`如何通过`selector`找到对应的`IMP`地址（分别考虑实例方法和类方法）`Selector、Method 和 IMP`的有什么区别与联系\n\n> 对于实例方法，每个实例的`isa`指针指向着对应类对象，而每一个类对象中都有一个对象方法列表。对于类方法，每个类对象的`isa`指针都指向着对应的元类对象，而每一个元类对象中都有一个类方法列表。方法列表中记录着方法的名称，方法实现，以及参数类型，其实`selector`本质就是方法名称，通过这个方法名称就可以在方法列表中找到对应的方法实现 `Selector、Method 和 IMP`的关系可以这样描述：在运行期分发消息，方法列表中的每一个实体都是一个方法（`Method`）它的名字叫做选择器（`SEL`）对应着一种方法实现（`IMP`）\n\n1. `objc_msgSend、_objc_msgForward`都是做什么的？OC 中的消息调用流程是怎样的\n\n> - `objc_msgSend`是用来做消息发送的。在`OC`中，对方法的调用都会被转换成内部的消息发送执行\n>\n> - `_objc_msgForward`是`IMP`类型（函数指针）用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发\n>\n> - 在消息调用的过程中，\n>\n>   ```\n>   objc_msgSend\n>   ```\n>\n>   的动作比较清晰：首先在\n>\n>   ```\n>   Class\n>   ```\n>\n>   中的缓存查找\n>\n>   ```\n>   IMP\n>   ```\n>\n>   （没缓存则初始化缓存）如果没找到，则向父类的\n>\n>   ```\n>   Class\n>   ```\n>\n>   查找。如果一直查找到根类仍旧没有实现，则用\n>\n>   ```\n>   _objc_msgForward\n>   ```\n>\n>   函数指针代替\n>\n>   ```\n>   IMP\n>   ```\n>\n>   。最后，执行这个\n>\n>   ```\n>   IMP\n>   ```\n>\n>   。当调用一个\n>\n>   ```\n>   NSObject\n>   ```\n>\n>   对象不存在的方法时，并不会马上抛出异常，而是会经过多层转发，层层调用对象的\n>\n>   ```\n>   -resolveInstanceMethod:、-forwardingTargetForSelector:、-methodSignatureForSelector:、-forwardInvocation:\n>   ```\n>\n>   等方法。其中最后\n>\n>   ```\n>   -forwardInvocation:\n>   ```\n>\n>   是会有一个\n>\n>   ```\n>   NSInvocation\n>   ```\n>\n>   对象，这个\n>\n>   ```\n>   NSInvocation\n>   ```\n>\n>   对象保存了这个方法调用的所有信息，包括\n>\n>   ```\n>   Selector名，参数和返回值类型\n>   ```\n>\n>   ，可以从这个\n>\n>   ```\n>   NSInvocation\n>   ```\n>\n>   对象里拿到调用的所有参数值\n>\n>   ![img](https://user-gold-cdn.xitu.io/2019/12/18/16f180e8604f5b40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n1. `class`方法和`objc_getClass`方法有什么区别\n\n> `object_getClass(obj)`返回的是`obj`中的`isa`指针，即指向类对象的指针；而`[obj class]`则分两种情况：一是当`obj`为实例对象时，`[obj class]`中`class`是实例方法，返回的是`obj`对象中的`isa`指针；二是当`obj`为类对象（包括元类和根类以及根元类）时，调用的是类方法，返回的结果为其本身\n\n1. OC中向一个`nil`对象发送消息将会发生什么\n\n> 在`OC`中向`nil`发送消息是完全有效的，只是在运行时不会有任何作用；向一个`nil`对象发送消息，首先在寻找对象的`isa`指针时就是`0地址`返回了，所以不会出现任何错误，也不会崩溃\n\n1. `_objc_msgForward`函数是做什么的？直接调用它将会发生什么\n\n> ```\n> _objc_msgForward`是一个函数指针（和`IMP`的类型一样）用于消息转发；当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发 `objc_msgSend`在`消息传递`中的作用。在`消息传递`过程中，`objc_msgSend`的动作比较清晰：首先在`Class`中的缓存查找`IMP`（`没有缓存则初始化缓存`）如果没找到，则向`父类的Class`查找。如果一直查找到`根类`仍旧没有实现，则用`_objc_msgForward`函数指针代替`IMP`，最后执行这个`IMP` 一旦调用了`_objc_msgForward`，将跳过查找`IMP`的过程，直接触发`消息转发`，如果调用了`_objc_msgForward`，即使这个对象确实已经实现了这个方法，你也会告诉`objc_msgSend`，我没有在这个对象里找到这个方法的实现，如果用不好会直接导致程序`Crash\n> ```\n\n1. 什么时候会报`unrecognized selector`的异常\n\n- 当调用该对象上某个方法，而该对象上没有实现这个方法的时候。可以通过\n\n  ```\n  消息转发\n  ```\n\n  进行解决，流程见下图\n\n  ![img](https://user-gold-cdn.xitu.io/2019/12/18/16f180e8604f5b40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n- `OC`在向一个对象发送消息时，`runtime`库会根据对象的`isa`指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常`unrecognized selector sent to XXX` **但是在这之前，OC的运行时会给出三次拯救程序崩溃的机会**\n\n- Method resolution（消息动态解析） `OC`运行时会调用`+resolveInstanceMethod:`或者`+resolveClassMethod:`，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则，运行时就会移到下一步，消息转发（`Message Forwarding`）\n\n```\n// 重写 resolveInstanceMethod: 添加对象方法实现\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    // 如果是执行 run 函数，就动态解析，指定新的 IMP\n    if (sel == NSSelectorFromString(@\"run:\")) {\n        // class: 给哪个类添加方法\n        // SEL: 添加哪个方法\n        // IMP: 方法实现 => 函数 => 函数入口 => 函数名\n        // type: 方法类型：void用v来表示，id参数用@来表示，SEL用:来表示\n        class_addMethod(self, sel, (IMP)runMethod, \"v@:@\");\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n\n//新的 run 函数\nvoid runMethod(id self, SEL _cmd, NSNumber *meter) {\n    NSLog(@\"跑了%@\", meter);\n}\n复制代码\n```\n\n- Fast forwarding（消息接受者重定向） 如果目标对象实现了`-forwardingTargetForSelector:`，`Runtime`这时就会调用这个方法，给你把这个消息转发给其他对象的机会。只要这个方法返回的不是`nil`和`self`，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续`Normal Fowarding`。 这里叫`Fast`，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个`NSInvocation`对象，所以相对更快点\n\n```\n// 消息接受者重定向\n- (id)forwardingTargetForSelector:(SEL)aSelector{\n    if (aSelector == @selector(run:)) {\n        return [[Person alloc] init];\n        // 返回 Person 对象，让 Person 对象接收这个消息\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n复制代码\n```\n\n- Normal forwarding（消息重定向） 这一步是`Runtime`最后一次给你挽救的机会。首先它会发送`-methodSignatureForSelector:`消息获得函数的参数和返回值类型。如果`-methodSignatureForSelector:`返回`nil`，`Runtime`则会发出`-doesNotRecognizeSelector:`消息，程序这时也就挂掉了。如果返回了一个函数签名，`Runtime`就会创建一个`NSInvocation`对象并发送`-forwardInvocation:`消息给目标对象\n\n```\n// 获取函数的参数和返回值类型，返回签名\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if ([NSStringFromSelector(aSelector) isEqualToString:@\"run:\"]) {\n        return [NSMethodSignature signatureWithObjCTypes:\"v@:@\"];\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n// 消息重定向\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    // 从 anInvocation 中获取消息\n    SEL sel = anInvocation.selector;\n    if (sel == NSSelectorFromString(@\"run:\")) {\n        // 1. 指定当前类的一个方法作为IMP\n        // anInvocation.selector = @selector(readBook:);\n        // [anInvocation invoke];\n        \n        // 2. 指定其他类来执行这个IMP\n        Person *p = [[Person alloc] init];\n        // 判断 Person 对象方法是否可以响应 sel\n        if([p respondsToSelector:sel]) {\n            // 若可以响应，则将消息转发给其他对象处理\n            [anInvocation invokeWithTarget:p];\n        } else {\n            // 若仍然无法响应，则报错：找不到响应方法\n            [self doesNotRecognizeSelector:sel];\n        }\n    }else{\n        [super forwardInvocation:anInvocation];\n    }\n}\n\n- (void)doesNotRecognizeSelector:(SEL)aSelector {\n    [super doesNotRecognizeSelector:aSelector];\n}\n复制代码\n```\n\n**既然`-forwardingTargetForSelector:`和`-forwardInvocation:`都可以将消息转发给其他对象处理，那么两者的区别在哪？** 区别就在于`-forwardingTargetForSelector:`只能将消息转发给一个对象。而`-forwardInvocation:`可以把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。修改消息的target，selector，参数等。将消息转发给多个对象\n\n1. `iOS layoutSubviews`什么时候会被调用\n\n> - `init`方法不会调用`layoutSubviews`，但是是用`initWithFrame`进行初始化时，当`rect`的值不为`CGRectZero`时，会触发\n> - `addSubview`会触发`layoutSubviews`方法\n> - `setFrame`只有当设置的`frame`的参数的`size`与原来的`size`不同，才会触发其`view`的`layoutSubviews`方法\n> - 滑动`UIScrollView`会调用`scrollview`及`scrollview`上的`view`的`layoutSubviews`方法\n> - 旋转设备只会调用`VC`的`view`的`layoutSubviews`方法\n> - 直接调用`[self setNeedsLayout];`（这个在上面苹果官方文档里有说明） `-layoutSubviews`方法：这个方法默认没有做任何事情，需要子类进行重写 `-setNeedsLayout`方法：标记为需要重新布局，异步调用`layoutIfNeeded`刷新布局，不立即刷新，但`layoutSubviews`一定会被调用 `-layoutIfNeeded`方法：如果有需要刷新的标记，立即调用`layoutSubviews`进行布局（如果没有标记，不会调用`layoutSubviews`） 如果要立即刷新，要先调用`[view setNeedsLayout]`，把标记设为需要布局，然后马上调用`[view layoutIfNeeded]`，实现布局 在视图第一次显示之前，标记总是`需要刷新`的，可以直接调用`[view layoutIfNeeded]`\n\n1. 下面代码会发生什么问题\n\n```\n@property (nonatomic, strong) NSString *str;\n\ndispatch_queue_t queue = dispatch_queue_create(\"parallel\", DISPATCH_QUEUE_CONCURRENT);\nfor (int i = 0; i < 1000000 ; i++) {\n    dispatch_async(queue, ^{\n        self.str = [NSString stringWithFormat:@\"changzifuchaung:%d\",i];\n    });\n}\n复制代码\n```\n\n会`crash`。因为在并行队列`DISPATCH_QUEUE_CONCURRENT`中异步`dispatch_async`对`str`属性进行赋值，就会导致`str`已经被`release`了，还会执行`release`。这就是向已释放内存的对象发送消息而发生`crash` 详细解析：对`str`属性`strong`修饰进行赋值，相当与`MRC`中的\n\n```\n- (void)setStr:(NSString *)str{\n    if (str == _str) return;\n    id pre = _str;\n    [str retain];//1.先保留新值\n    _str = str;//2.再进行赋值\n    [pre release];//3.释放旧值\n}\n复制代码\n```\n\n那么假如`并发队列`里调度的`线程A`执行到`步骤1`，还没到`步骤2`时，`线程B`执行到`步骤3`，那么当`线程A`再执行`步骤3`时，旧值就会被`过度释放`，导致向已释放内存的对象发送消息而崩溃\n\n- 追问：怎么修改这段代码变为不崩溃呢\n\n> 1、使用串行队列 将`set`方法改成在串行队列中执行就行，这样即使异步，但所有`block`操作追加在队列最后依次执行 2、使用`atomic` `atomic`关键字相当于在`setter`方法加锁，这样每次执行`setter`都是线程安全的，但这只是单独针对`setter`方法而言的狭义的线程安全 3、使用`weak`关键字 `weak`的`setter`没有`保留新值`的操作，所以不会引发重复释放。当然这个时候要看具体情况能否使用`weak`，可能值并不是所需要的值 4、使用互斥锁，保证数据访问的唯一性`@synchronized (self) {self.str = [NSString stringWithFormat:@\"changzifuchaung:%d\",i];}` 5、使用`Tagged Pointer` `Tagged Pointer`是苹果在64位系统引入的内存技术。简单来说就是对于`NSString`(内存小于60位的字符串)或`NSNumber`(小于2^31)，64位的指针有8个字节，完全可以直接用这个空间来直接表示值，这样的话其实会将`NSString`和`NSNumber`对象由一个`指针`转换成一个`值类型`，而值类型的`setter和getter`又是原子的，从而线程安全\n\n- 发散：下面代码会`crash`吗\n\n```\n@property (nonatomic, strong) NSString *str;\n\ndispatch_queue_t queue = dispatch_queue_create(\"parallel\", DISPATCH_QUEUE_CONCURRENT);\nfor (int i = 0; i < 1000000 ; i++) {\n    dispatch_async(queue, ^{\n        // 相比上面，仅字符串变短了\n        self.str = [NSString stringWithFormat:@\"%d\",i];\n        NSLog(@\"%d, %s, %p\", i, object_getClassName(self.str), self.str);\n    });\n}\n复制代码\n```\n\n不会`crash`。而且发现`str`这个字符串类型是`NSTaggedPointerString` `Tagged Pointer`是一个能够提升性能、节省内存的有趣的技术 `Tagged Pointer`专门用来存储小的对象，例如`NSNumber`和`NSDate`(后来可以存储小字符串) `Tagged Pointer指针的值`不再是`地址`了，而是`真正的值`。所以，实际上它不再是一个`对象`了，它只是一个披着对象皮的`普通变量`而已 它的内存并不存储在`堆`中，也不需要`malloc和free`，所以拥有极快的读取和创建速度\n\n', '0', '0', '2019-12-19');
INSERT INTO `articles` VALUES ('34', 'chenin', '阅读', '123456', '## hello !', '0', '0', '2019-12-23');
INSERT INTO `articles` VALUES ('35', 'chenin', '前端', 'Vue', '# vue组件化\n\n------\n\n\n\n## 组件设计\n\n---\n\n### 表单组件、组件分层\n\n1. From负责定义检验规则\n2. FromItem负责显示错误信息\n3. k-input负责数据双向绑定\n4. 使用provide和inject内部共享数据\n\n\n\n## provide&inject\n\n---\n\n~~~js\nprovide(){				\n	return	{						\n		form:\"kaikeba\"				\n	}		\n},\n//子组件注入\nvar	Child	=	{		\n	inject:	[\'form\'],		\n	created	()	{\n   		 console.log(this.form)		\n    }		\n  }\n~~~\n\n\n\n## k-input使用v-model实现双向数据绑定\n\n---\n\nv-model是一个特殊属性，相当于绑定：value和@input两个事件\n\n~~~vue\n<template>\n  <div>\n    <input :type=\"inputtype\" :value=\"inputValue\" @input=\"handleinput\" @blur=\"handleBlur\" />\n    <p>{{inputValue}}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {	//获取value初始值，input的类型type\n    value: {\n      type: String,\n      default: \"\",\n      required: true\n    },\n    type: {\n      type: String,\n      default: \"text\"\n    }\n  },\n  data() {\n    return {    //单向数据流原则：组件内不能修改props属性\n      inputValue: this.value,\n      inputtype: this.type\n    };\n  },\n  methods: {\n    handleinput(e) {\n      const value = e.target.value;\n      this.inputValue = value;\n      console.log(this.inputValue);\n      //通知父组件值更新\n      this.$emit(\"input\", value);\n\n      //通知FromItem做校验\n      this.$parent.$emit(\"validate\", this.inputValue);\n    },\n    handleBlur() {	//输入框失去焦点时通知FromItem做校验\n      this.$parent.$emit(\"validate\", this.inputValue);\n    }\n  }\n};\n</script>\n~~~\n\n\n\n\n\n## FromItem\n\n---\n\n1. 获取当前输入框的规则\n2. 获取输入框的值对rules规则进行匹配过滤不是自己的输入事件\n3. 如果输入值和rules不匹配显示错误信息\n\n~~~vue\n<template>\n  <div>\n    <label v-if=\"label!=\'\'\">{{label}}</label>\n    <div>\n      <slot></slot>\n      <p v-if=\"validateStatus == \'error\'\" class=\"error\">{{errorMessage}}</p>\n    </div>\n  </div>\n</template>\n\n<script>\nimport schema from \"async-validator\";	//数据检验插件\nexport default {\n  inject: [\"from\"],	// 注入form，获取model和rules\n  props: {\n    label: {\n      type: String,\n      default: \"\"\n    },\n    prop: {\n      type: String\n    }\n  },\n  data() {\n    return {\n      validateStatus: \"\",\n      errorMessage: \"\"\n    };\n  },\n  created() {\n    this.$on(\"validate\", this.validate);\n  },\n  mounted() {\n    //挂载到from上时，派发一个添加事件\n    if (this.prop) {\n      this.$parent.$emit(\"fromItemAdd\", this);\n    }\n  },\n  methods: {\n     validate() {\n      return new Promise(resolve => {\n        //npm install --save async-validator\n        //检验当前项 async-validate\n        const descriptor = {\n          //获取检验规则\n          [this.prop]: this.from.rules[this.prop]\n        };\n        const validator = new schema(descriptor);\n           // 使用es6计算属性动态设置key\n        validator.validate({ [this.prop]: this.from.model[this.prop] }, error => {\n          if (error) {\n            //检验失败\n            this.validateStatus = \"error\";\n            this.errorMessage = error[0].message;\n            resolve(false);\n          } else {\n            this.validateStatus = \"\";\n            this.errorMessage = \"\";\n            resolve(true);\n          }\n        });\n      });\n    }\n  }\n};\n</script>\n~~~\n\n\n\n## From\n\n---\n\n\n\n~~~vue\n<template>\n    <div>\n        <form>\n            <slot></slot>\n        </form>\n    </div>\n</template>\n\n<script>\n    export default {\n        provide(){\n            return {    //将表单实列传递给后代\n                from: this\n            }\n        },\n        props: {\n            model: {\n                type: Object,\n                required: true\n            },\n            rules:{\n                type: Object\n            }\n        },\n        created () {\n            //缓存需要校验的表单项\n            this.fields = [];\n            this.$on(\'fromItemAdd\',item=>this.fields.push(item))\n        },\n        methods: {\n            async validate(callback) {\n                //将FromItem数组转换为validate（）返回的promise数组\n                const tasks = this.fields.map(item => item.validate())\n                //获取所有结果统一处理\n                const results = await Promise.all(tasks);\n                let ret = true;\n                results.forEach(valid =>{\n                    if(!valid){\n                        ret = false;//只要一个失败就失败\n                    }\n                });\n                callback(ret);\n            }\n        },\n    }\n</script>\n~~~\n\n\n\n## 组件使用\n\n---\n\n~~~vue\n<template>\n  <div>\n    <k-from :model=\"from\" :rules=\"rules\" ref=\"loginfrom\">\n      <k-fromitem label=\"用户名\" prop=\"name\">\n        <k-input v-model=\"from.name\"></k-input>\n      </k-fromitem>\n      <k-fromitem label=\"密码\" prop=\"password\">\n        <k-input v-model=\"from.password\" type=\"password\"></k-input>\n      </k-fromitem>\n      <k-fromitem>\n        <button @click=\"submit\">登录</button>\n      </k-fromitem>\n    </k-from>\n  </div>\n</template>\n\n<script>\nimport KInput from \"./Basefromitem/KInput.vue\";\nimport KFromitem from \"./Basefromitem/KFromitem.vue\";\nimport KFrom from \"./Basefromitem/KFrom.vue\";\n\nexport default {\n  components: {KInput, KFromitem,KFrom },\n  data() {\n    return {\n      from: {\n        name: \"\",\n        password: \"\"\n      },\n      rules: {	//检验规则\n        name: [\n          { required: true, message: \"用户名不能为空！\" },\n          { min: 6, max: 10, message: \"请输入6~10位用户名\" }\n        ],\n        password: [{ required: true, message: \"密码不能为空！\" }]\n      }\n    };\n  },\n  methods: {\n    submit() {\n      this.$refs.loginfrom.validate(valid => {\n        if (valid) {\n          alert(\"提交登录！\");\n        } else {\n          console.log(\"校验失败\");\n          return false;\n        }\n      });\n    }\n  }\n};\n</script>\n~~~\n', '0', '0', '2019-12-23');
INSERT INTO `articles` VALUES ('36', 'chenin', '前端', 'vue学习', '# vue组件化\n\n------\n\n\n\n## 组件设计\n\n---\n\n### 表单组件、组件分层\n\n1. From负责定义检验规则\n2. FromItem负责显示错误信息\n3. k-input负责数据双向绑定\n4. 使用provide和inject内部共享数据\n\n\n\n## provide&inject\n\n---\n\n~~~js\nprovide(){				\n	return	{						\n		form:\"kaikeba\"				\n	}		\n},\n//子组件注入\nvar	Child	=	{		\n	inject:	[\'form\'],		\n	created	()	{\n   		 console.log(this.form)		\n    }		\n  }\n~~~\n\n\n\n## k-input使用v-model实现双向数据绑定\n\n---\n\nv-model是一个特殊属性，相当于绑定：value和@input两个事件\n\n~~~vue\n<template>\n  <div>\n    <input :type=\"inputtype\" :value=\"inputValue\" @input=\"handleinput\" @blur=\"handleBlur\" />\n    <p>{{inputValue}}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {	//获取value初始值，input的类型type\n    value: {\n      type: String,\n      default: \"\",\n      required: true\n    },\n    type: {\n      type: String,\n      default: \"text\"\n    }\n  },\n  data() {\n    return {    //单向数据流原则：组件内不能修改props属性\n      inputValue: this.value,\n      inputtype: this.type\n    };\n  },\n  methods: {\n    handleinput(e) {\n      const value = e.target.value;\n      this.inputValue = value;\n      console.log(this.inputValue);\n      //通知父组件值更新\n      this.$emit(\"input\", value);\n\n      //通知FromItem做校验\n      this.$parent.$emit(\"validate\", this.inputValue);\n    },\n    handleBlur() {	//输入框失去焦点时通知FromItem做校验\n      this.$parent.$emit(\"validate\", this.inputValue);\n    }\n  }\n};\n</script>\n~~~\n\n\n\n\n\n## FromItem\n\n---\n\n1. 获取当前输入框的规则\n2. 获取输入框的值对rules规则进行匹配过滤不是自己的输入事件\n3. 如果输入值和rules不匹配显示错误信息\n\n~~~vue\n<template>\n  <div>\n    <label v-if=\"label!=\'\'\">{{label}}</label>\n    <div>\n      <slot></slot>\n      <p v-if=\"validateStatus == \'error\'\" class=\"error\">{{errorMessage}}</p>\n    </div>\n  </div>\n</template>\n\n<script>\nimport schema from \"async-validator\";	//数据检验插件\nexport default {\n  inject: [\"from\"],	// 注入form，获取model和rules\n  props: {\n    label: {\n      type: String,\n      default: \"\"\n    },\n    prop: {\n      type: String\n    }\n  },\n  data() {\n    return {\n      validateStatus: \"\",\n      errorMessage: \"\"\n    };\n  },\n  created() {\n    this.$on(\"validate\", this.validate);\n  },\n  mounted() {\n    //挂载到from上时，派发一个添加事件\n    if (this.prop) {\n      this.$parent.$emit(\"fromItemAdd\", this);\n    }\n  },\n  methods: {\n     validate() {\n      return new Promise(resolve => {\n        //npm install --save async-validator\n        //检验当前项 async-validate\n        const descriptor = {\n          //获取检验规则\n          [this.prop]: this.from.rules[this.prop]\n        };\n        const validator = new schema(descriptor);\n           // 使用es6计算属性动态设置key\n        validator.validate({ [this.prop]: this.from.model[this.prop] }, error => {\n          if (error) {\n            //检验失败\n            this.validateStatus = \"error\";\n            this.errorMessage = error[0].message;\n            resolve(false);\n          } else {\n            this.validateStatus = \"\";\n            this.errorMessage = \"\";\n            resolve(true);\n          }\n        });\n      });\n    }\n  }\n};\n</script>\n~~~\n\n\n\n## From\n\n---\n\n\n\n~~~vue\n<template>\n    <div>\n        <form>\n            <slot></slot>\n        </form>\n    </div>\n</template>\n\n<script>\n    export default {\n        provide(){\n            return {    //将表单实列传递给后代\n                from: this\n            }\n        },\n        props: {\n            model: {\n                type: Object,\n                required: true\n            },\n            rules:{\n                type: Object\n            }\n        },\n        created () {\n            //缓存需要校验的表单项\n            this.fields = [];\n            this.$on(\'fromItemAdd\',item=>this.fields.push(item))\n        },\n        methods: {\n            async validate(callback) {\n                //将FromItem数组转换为validate（）返回的promise数组\n                const tasks = this.fields.map(item => item.validate())\n                //获取所有结果统一处理\n                const results = await Promise.all(tasks);\n                let ret = true;\n                results.forEach(valid =>{\n                    if(!valid){\n                        ret = false;//只要一个失败就失败\n                    }\n                });\n                callback(ret);\n            }\n        },\n    }\n</script>\n~~~\n\n\n\n## 组件使用\n\n---\n\n~~~vue\n<template>\n  <div>\n    <k-from :model=\"from\" :rules=\"rules\" ref=\"loginfrom\">\n      <k-fromitem label=\"用户名\" prop=\"name\">\n        <k-input v-model=\"from.name\"></k-input>\n      </k-fromitem>\n      <k-fromitem label=\"密码\" prop=\"password\">\n        <k-input v-model=\"from.password\" type=\"password\"></k-input>\n      </k-fromitem>\n      <k-fromitem>\n        <button @click=\"submit\">登录</button>\n      </k-fromitem>\n    </k-from>\n  </div>\n</template>\n\n<script>\nimport KInput from \"./Basefromitem/KInput.vue\";\nimport KFromitem from \"./Basefromitem/KFromitem.vue\";\nimport KFrom from \"./Basefromitem/KFrom.vue\";\n\nexport default {\n  components: {KInput, KFromitem,KFrom },\n  data() {\n    return {\n      from: {\n        name: \"\",\n        password: \"\"\n      },\n      rules: {	//检验规则\n        name: [\n          { required: true, message: \"用户名不能为空！\" },\n          { min: 6, max: 10, message: \"请输入6~10位用户名\" }\n        ],\n        password: [{ required: true, message: \"密码不能为空！\" }]\n      }\n    };\n  },\n  methods: {\n    submit() {\n      this.$refs.loginfrom.validate(valid => {\n        if (valid) {\n          alert(\"提交登录！\");\n        } else {\n          console.log(\"校验失败\");\n          return false;\n        }\n      });\n    }\n  }\n};\n</script>\n~~~\n', '0', '0', '2019-12-23');

-- ----------------------------
-- Table structure for `comments`
-- ----------------------------
DROP TABLE IF EXISTS `comments`;
CREATE TABLE `comments` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_id` bigint(20) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  `infomation` varchar(255) NOT NULL,
  `createtime` date NOT NULL,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comments
-- ----------------------------
INSERT INTO `comments` VALUES ('4', '1', '1', '前端小白', '2019-12-22', 'chenin');
INSERT INTO `comments` VALUES ('8', '3', '1', 'Vue组件化开发', '2019-12-22', 'chenin');
INSERT INTO `comments` VALUES ('9', '1', '1', '关于Vue mock模拟数据', '2019-12-22', 'chenin');
INSERT INTO `comments` VALUES ('10', '1', '1', 'vue学习模块', '2019-12-23', 'chenin');

-- ----------------------------
-- Table structure for `users`
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(64) NOT NULL,
  `phone` varchar(25) NOT NULL,
  `password` varchar(255) NOT NULL,
  `headimg` varchar(255) NOT NULL DEFAULT 'http://tvax4.sinaimg.cn/crop.0.0.480.480.180/768c39d5ly8fjje1d0teej20dc0dcq35.jpg',
  `email` varchar(64) DEFAULT NULL,
  `updatetime` date NOT NULL,
  `createtime` date NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of users
-- ----------------------------
INSERT INTO `users` VALUES ('1', 'chenin', '13539537481', '$2a$10$1ouixrMmOphyiFG0Q9UZBO0R5Ref9tfY9KH2RmsS8rvyXSsHnhPiG', 'http://tvax4.sinaimg.cn/crop.0.0.480.480.180/768c39d5ly8fjje1d0teej20dc0dcq35.jpg', '1185288254@qq.com', '2019-12-15', '2019-12-15');
INSERT INTO `users` VALUES ('2', 'chen', '13539537482', '$2a$10$FjRzCGh4ePJvlkBJa41fu..GhkuVQW7ChgyT1B2q/rQtUm0izzWSW', 'http://tvax4.sinaimg.cn/crop.0.0.480.480.180/768c39d5ly8fjje1d0teej20dc0dcq35.jpg', '123456789@qq.com', '2019-12-16', '2019-12-16');
INSERT INTO `users` VALUES ('3', 'chenin', '1353953748', '$2a$10$159nOGe9JtDsGXG0ZIsj8e.VFt0nYctQL7ZxEROInMptK7TO93sGS', 'http://tvax4.sinaimg.cn/crop.0.0.480.480.180/768c39d5ly8fjje1d0teej20dc0dcq35.jpg', null, '2019-12-18', '2019-12-18');
